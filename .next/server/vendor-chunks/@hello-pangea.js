"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hello-pangea";
exports.ids = ["vendor-chunks/@hello-pangea"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@hello-pangea/dnd/dist/dnd.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragDropContext: () => (/* binding */ DragDropContext),\n/* harmony export */   Draggable: () => (/* binding */ PublicDraggable),\n/* harmony export */   Droppable: () => (/* binding */ ConnectedDroppable),\n/* harmony export */   useKeyboardSensor: () => (/* binding */ useKeyboardSensor),\n/* harmony export */   useMouseSensor: () => (/* binding */ useMouseSensor),\n/* harmony export */   useTouchSensor: () => (/* binding */ useTouchSensor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var css_box_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! css-box-model */ \"(ssr)/./node_modules/css-box-model/dist/css-box-model.esm.js\");\n/* harmony import */ var raf_schd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! raf-schd */ \"(ssr)/./node_modules/raf-schd/dist/raf-schd.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n\n\n\n\n\n\n\nconst isProduction$1 = \"development\" === \"production\";\nconst spacesAndTabs = /[ \\t]{2,}/g;\nconst lineStartWithSpaces = /^[ \\t]*/gm;\nconst clean$2 = (value)=>value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\nconst getDevMessage = (message)=>clean$2(`\n  %c@hello-pangea/dnd\n\n  %c${clean$2(message)}\n\n  %cðŸ‘·â€ This is a development only message. It will be removed in production builds.\n`);\nconst getFormattedMessage = (message)=>[\n        getDevMessage(message),\n        \"color: #00C584; font-size: 1.2em; font-weight: bold;\",\n        \"line-height: 1.5\",\n        \"color: #723874;\"\n    ];\nconst isDisabledFlag = \"__@hello-pangea/dnd-disable-dev-warnings\";\nfunction log(type, message) {\n    if (isProduction$1) {\n        return;\n    }\n    if (false) {}\n    console[type](...getFormattedMessage(message));\n}\nconst warning = log.bind(null, \"warn\");\nconst error = log.bind(null, \"error\");\nfunction noop$2() {}\nfunction getOptions(shared, fromBinding) {\n    return {\n        ...shared,\n        ...fromBinding\n    };\n}\nfunction bindEvents(el, bindings, sharedOptions) {\n    const unbindings = bindings.map((binding)=>{\n        const options = getOptions(sharedOptions, binding.options);\n        el.addEventListener(binding.eventName, binding.fn, options);\n        return function unbind() {\n            el.removeEventListener(binding.eventName, binding.fn, options);\n        };\n    });\n    return function unbindAll() {\n        unbindings.forEach((unbind)=>{\n            unbind();\n        });\n    };\n}\nconst isProduction = \"development\" === \"production\";\nconst prefix$1 = \"Invariant failed\";\nclass RbdInvariant extends Error {\n}\nRbdInvariant.prototype.toString = function toString() {\n    return this.message;\n};\nfunction invariant(condition, message) {\n    if (isProduction) {\n        throw new RbdInvariant(prefix$1);\n    } else {\n        throw new RbdInvariant(`${prefix$1}: ${message || \"\"}`);\n    }\n}\nclass ErrorBoundary extends (react__WEBPACK_IMPORTED_MODULE_0___default().Component) {\n    constructor(...args){\n        super(...args);\n        this.callbacks = null;\n        this.unbind = noop$2;\n        this.onWindowError = (event)=>{\n            const callbacks = this.getCallbacks();\n            if (callbacks.isDragging()) {\n                callbacks.tryAbort();\n                 true ? warning(`\n        An error was caught by our window 'error' event listener while a drag was occurring.\n        The active drag has been aborted.\n      `) : 0;\n            }\n            const err = event.error;\n            if (err instanceof RbdInvariant) {\n                event.preventDefault();\n                if (true) {\n                    error(err.message);\n                }\n            }\n        };\n        this.getCallbacks = ()=>{\n            if (!this.callbacks) {\n                throw new Error(\"Unable to find AppCallbacks in <ErrorBoundary/>\");\n            }\n            return this.callbacks;\n        };\n        this.setCallbacks = (callbacks)=>{\n            this.callbacks = callbacks;\n        };\n    }\n    componentDidMount() {\n        this.unbind = bindEvents(window, [\n            {\n                eventName: \"error\",\n                fn: this.onWindowError\n            }\n        ]);\n    }\n    componentDidCatch(err) {\n        if (err instanceof RbdInvariant) {\n            if (true) {\n                error(err.message);\n            }\n            this.setState({});\n            return;\n        }\n        throw err;\n    }\n    componentWillUnmount() {\n        this.unbind();\n    }\n    render() {\n        return this.props.children(this.setCallbacks);\n    }\n}\nconst dragHandleUsageInstructions = `\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n`;\nconst position = (index)=>index + 1;\nconst onDragStart = (start)=>`\n  You have lifted an item in position ${position(start.source.index)}\n`;\nconst withLocation = (source, destination)=>{\n    const isInHomeList = source.droppableId === destination.droppableId;\n    const startPosition = position(source.index);\n    const endPosition = position(destination.index);\n    if (isInHomeList) {\n        return `\n      You have moved the item from position ${startPosition}\n      to position ${endPosition}\n    `;\n    }\n    return `\n    You have moved the item from position ${startPosition}\n    in list ${source.droppableId}\n    to list ${destination.droppableId}\n    in position ${endPosition}\n  `;\n};\nconst withCombine = (id, source, combine)=>{\n    const inHomeList = source.droppableId === combine.droppableId;\n    if (inHomeList) {\n        return `\n      The item ${id}\n      has been combined with ${combine.draggableId}`;\n    }\n    return `\n      The item ${id}\n      in list ${source.droppableId}\n      has been combined with ${combine.draggableId}\n      in list ${combine.droppableId}\n    `;\n};\nconst onDragUpdate = (update)=>{\n    const location = update.destination;\n    if (location) {\n        return withLocation(update.source, location);\n    }\n    const combine = update.combine;\n    if (combine) {\n        return withCombine(update.draggableId, update.source, combine);\n    }\n    return \"You are over an area that cannot be dropped on\";\n};\nconst returnedToStart = (source)=>`\n  The item has returned to its starting position\n  of ${position(source.index)}\n`;\nconst onDragEnd = (result)=>{\n    if (result.reason === \"CANCEL\") {\n        return `\n      Movement cancelled.\n      ${returnedToStart(result.source)}\n    `;\n    }\n    const location = result.destination;\n    const combine = result.combine;\n    if (location) {\n        return `\n      You have dropped the item.\n      ${withLocation(result.source, location)}\n    `;\n    }\n    if (combine) {\n        return `\n      You have dropped the item.\n      ${withCombine(result.draggableId, result.source, combine)}\n    `;\n    }\n    return `\n    The item has been dropped while not over a drop area.\n    ${returnedToStart(result.source)}\n  `;\n};\nconst preset = {\n    dragHandleUsageInstructions,\n    onDragStart,\n    onDragUpdate,\n    onDragEnd\n};\nfunction isEqual$2(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (Number.isNaN(first) && Number.isNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for(let i = 0; i < newInputs.length; i++){\n        if (!isEqual$2(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction useMemo(getResult, inputs) {\n    const initial = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>({\n            inputs,\n            result: getResult()\n        }))[0];\n    const isFirstRun = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const committed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initial);\n    const useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));\n    const cache = useCache ? committed.current : {\n        inputs,\n        result: getResult()\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        isFirstRun.current = false;\n        committed.current = cache;\n    }, [\n        cache\n    ]);\n    return cache.result;\n}\nfunction useCallback(callback, inputs) {\n    return useMemo(()=>callback, inputs);\n}\nconst origin = {\n    x: 0,\n    y: 0\n};\nconst add = (point1, point2)=>({\n        x: point1.x + point2.x,\n        y: point1.y + point2.y\n    });\nconst subtract = (point1, point2)=>({\n        x: point1.x - point2.x,\n        y: point1.y - point2.y\n    });\nconst isEqual$1 = (point1, point2)=>point1.x === point2.x && point1.y === point2.y;\nconst negate = (point)=>({\n        x: point.x !== 0 ? -point.x : 0,\n        y: point.y !== 0 ? -point.y : 0\n    });\nconst patch = (line, value, otherValue = 0)=>{\n    if (line === \"x\") {\n        return {\n            x: value,\n            y: otherValue\n        };\n    }\n    return {\n        x: otherValue,\n        y: value\n    };\n};\nconst distance = (point1, point2)=>Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);\nconst closest$1 = (target, points)=>Math.min(...points.map((point)=>distance(target, point)));\nconst apply = (fn)=>(point)=>({\n            x: fn(point.x),\n            y: fn(point.y)\n        });\nvar executeClip = (frame, subject)=>{\n    const result = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n        top: Math.max(subject.top, frame.top),\n        right: Math.min(subject.right, frame.right),\n        bottom: Math.min(subject.bottom, frame.bottom),\n        left: Math.max(subject.left, frame.left)\n    });\n    if (result.width <= 0 || result.height <= 0) {\n        return null;\n    }\n    return result;\n};\nconst offsetByPosition = (spacing, point)=>({\n        top: spacing.top + point.y,\n        left: spacing.left + point.x,\n        bottom: spacing.bottom + point.y,\n        right: spacing.right + point.x\n    });\nconst getCorners = (spacing)=>[\n        {\n            x: spacing.left,\n            y: spacing.top\n        },\n        {\n            x: spacing.right,\n            y: spacing.top\n        },\n        {\n            x: spacing.left,\n            y: spacing.bottom\n        },\n        {\n            x: spacing.right,\n            y: spacing.bottom\n        }\n    ];\nconst noSpacing = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n};\nconst scroll$1 = (target, frame)=>{\n    if (!frame) {\n        return target;\n    }\n    return offsetByPosition(target, frame.scroll.diff.displacement);\n};\nconst increase = (target, axis, withPlaceholder)=>{\n    if (withPlaceholder && withPlaceholder.increasedBy) {\n        return {\n            ...target,\n            [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]\n        };\n    }\n    return target;\n};\nconst clip = (target, frame)=>{\n    if (frame && frame.shouldClipSubject) {\n        return executeClip(frame.pageMarginBox, target);\n    }\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(target);\n};\nvar getSubject = ({ page, withPlaceholder, axis, frame })=>{\n    const scrolled = scroll$1(page.marginBox, frame);\n    const increased = increase(scrolled, axis, withPlaceholder);\n    const clipped = clip(increased, frame);\n    return {\n        page,\n        withPlaceholder,\n        active: clipped\n    };\n};\nvar scrollDroppable = (droppable, newScroll)=>{\n    !droppable.frame ?  true ? invariant() : 0 : void 0;\n    const scrollable = droppable.frame;\n    const scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n    const scrollDisplacement = negate(scrollDiff);\n    const frame = {\n        ...scrollable,\n        scroll: {\n            initial: scrollable.scroll.initial,\n            current: newScroll,\n            diff: {\n                value: scrollDiff,\n                displacement: scrollDisplacement\n            },\n            max: scrollable.scroll.max\n        }\n    };\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: droppable.subject.withPlaceholder,\n        axis: droppable.axis,\n        frame\n    });\n    const result = {\n        ...droppable,\n        frame,\n        subject\n    };\n    return result;\n};\nfunction memoizeOne(resultFn, isEqual = areInputsEqual) {\n    let cache = null;\n    function memoized(...newArgs) {\n        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {\n            return cache.lastResult;\n        }\n        const lastResult = resultFn.apply(this, newArgs);\n        cache = {\n            lastResult,\n            lastArgs: newArgs,\n            lastThis: this\n        };\n        return lastResult;\n    }\n    memoized.clear = function clear() {\n        cache = null;\n    };\n    return memoized;\n}\nconst toDroppableMap = memoizeOne((droppables)=>droppables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDraggableMap = memoizeOne((draggables)=>draggables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDroppableList = memoizeOne((droppables)=>Object.values(droppables));\nconst toDraggableList = memoizeOne((draggables)=>Object.values(draggables));\nvar getDraggablesInsideDroppable = memoizeOne((droppableId, draggables)=>{\n    const result = toDraggableList(draggables).filter((draggable)=>droppableId === draggable.descriptor.droppableId).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n    return result;\n});\nfunction tryGetDestination(impact) {\n    if (impact.at && impact.at.type === \"REORDER\") {\n        return impact.at.destination;\n    }\n    return null;\n}\nfunction tryGetCombine(impact) {\n    if (impact.at && impact.at.type === \"COMBINE\") {\n        return impact.at.combine;\n    }\n    return null;\n}\nvar removeDraggableFromList = memoizeOne((remove, list)=>list.filter((item)=>item.descriptor.id !== remove.descriptor.id));\nvar moveToNextCombine = ({ isMovingForward, draggable, destination, insideDestination, previousImpact })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const location = tryGetDestination(previousImpact);\n    if (!location) {\n        return null;\n    }\n    function getImpact(target) {\n        const at = {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: target,\n                droppableId: destination.descriptor.id\n            }\n        };\n        return {\n            ...previousImpact,\n            at\n        };\n    }\n    const all = previousImpact.displaced.all;\n    const closestId = all.length ? all[0] : null;\n    if (isMovingForward) {\n        return closestId ? getImpact(closestId) : null;\n    }\n    const withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n    if (!closestId) {\n        if (!withoutDraggable.length) {\n            return null;\n        }\n        const last = withoutDraggable[withoutDraggable.length - 1];\n        return getImpact(last.descriptor.id);\n    }\n    const indexOfClosest = withoutDraggable.findIndex((d)=>d.descriptor.id === closestId);\n    !(indexOfClosest !== -1) ?  true ? invariant(false, \"Could not find displaced item in set\") : 0 : void 0;\n    const proposedIndex = indexOfClosest - 1;\n    if (proposedIndex < 0) {\n        return null;\n    }\n    const before = withoutDraggable[proposedIndex];\n    return getImpact(before.descriptor.id);\n};\nvar isHomeOf = (draggable, destination)=>draggable.descriptor.droppableId === destination.descriptor.id;\nconst noDisplacedBy = {\n    point: origin,\n    value: 0\n};\nconst emptyGroups = {\n    invisible: {},\n    visible: {},\n    all: []\n};\nconst noImpact = {\n    displaced: emptyGroups,\n    displacedBy: noDisplacedBy,\n    at: null\n};\nvar isWithin = (lowerBound, upperBound)=>(value)=>lowerBound <= value && value <= upperBound;\nvar isPartiallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        if (isContained) {\n            return true;\n        }\n        const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n        const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n        const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n        if (isPartiallyContained) {\n            return true;\n        }\n        const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n        const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n        const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n        if (isTargetBiggerThanFrame) {\n            return true;\n        }\n        const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n        return isTargetBiggerOnOneAxis;\n    };\n};\nvar isTotallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        return isContained;\n    };\n};\nconst vertical = {\n    direction: \"vertical\",\n    line: \"y\",\n    crossAxisLine: \"x\",\n    start: \"top\",\n    end: \"bottom\",\n    size: \"height\",\n    crossAxisStart: \"left\",\n    crossAxisEnd: \"right\",\n    crossAxisSize: \"width\"\n};\nconst horizontal = {\n    direction: \"horizontal\",\n    line: \"x\",\n    crossAxisLine: \"y\",\n    start: \"left\",\n    end: \"right\",\n    size: \"width\",\n    crossAxisStart: \"top\",\n    crossAxisEnd: \"bottom\",\n    crossAxisSize: \"height\"\n};\nvar isTotallyVisibleThroughFrameOnAxis = (axis)=>(frame)=>{\n        const isWithinVertical = isWithin(frame.top, frame.bottom);\n        const isWithinHorizontal = isWithin(frame.left, frame.right);\n        return (subject)=>{\n            if (axis === vertical) {\n                return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n            }\n            return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        };\n    };\nconst getDroppableDisplaced = (target, destination)=>{\n    const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n    return offsetByPosition(target, displacement);\n};\nconst isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn)=>{\n    if (!destination.subject.active) {\n        return false;\n    }\n    return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\nconst isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn)=>isVisibleThroughFrameFn(viewport)(target);\nconst isVisible$1 = ({ target: toBeDisplaced, destination, viewport, withDroppableDisplacement, isVisibleThroughFrameFn })=>{\n    const displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n    return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\nconst isPartiallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n    });\nconst isTotallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n    });\nconst isTotallyVisibleOnAxis = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n    });\nconst getShouldAnimate = (id, last, forceShouldAnimate)=>{\n    if (typeof forceShouldAnimate === \"boolean\") {\n        return forceShouldAnimate;\n    }\n    if (!last) {\n        return true;\n    }\n    const { invisible, visible } = last;\n    if (invisible[id]) {\n        return false;\n    }\n    const previous = visible[id];\n    return previous ? previous.shouldAnimate : true;\n};\nfunction getTarget(draggable, displacedBy) {\n    const marginBox = draggable.page.marginBox;\n    const expandBy = {\n        top: displacedBy.point.y,\n        right: 0,\n        bottom: 0,\n        left: displacedBy.point.x\n    };\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)((0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.expand)(marginBox, expandBy));\n}\nfunction getDisplacementGroups({ afterDragging, destination, displacedBy, viewport, forceShouldAnimate, last }) {\n    return afterDragging.reduce(function process(groups, draggable) {\n        const target = getTarget(draggable, displacedBy);\n        const id = draggable.descriptor.id;\n        groups.all.push(id);\n        const isVisible = isPartiallyVisible({\n            target,\n            destination,\n            viewport,\n            withDroppableDisplacement: true\n        });\n        if (!isVisible) {\n            groups.invisible[draggable.descriptor.id] = true;\n            return groups;\n        }\n        const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n        const displacement = {\n            draggableId: id,\n            shouldAnimate\n        };\n        groups.visible[id] = displacement;\n        return groups;\n    }, {\n        all: [],\n        visible: {},\n        invisible: {}\n    });\n}\nfunction getIndexOfLastItem(draggables, options) {\n    if (!draggables.length) {\n        return 0;\n    }\n    const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n    return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\nfunction goAtEnd({ insideDestination, inHomeList, displacedBy, destination }) {\n    const newIndex = getIndexOfLastItem(insideDestination, {\n        inHomeList\n    });\n    return {\n        displaced: emptyGroups,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index: newIndex\n            }\n        }\n    };\n}\nfunction calculateReorderImpact({ draggable, insideDestination, destination, viewport, displacedBy, last, index, forceShouldAnimate }) {\n    const inHomeList = isHomeOf(draggable, destination);\n    if (index == null) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const match = insideDestination.find((item)=>item.descriptor.index === index);\n    if (!match) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const sliceFrom = insideDestination.indexOf(match);\n    const impacted = withoutDragging.slice(sliceFrom);\n    const displaced = getDisplacementGroups({\n        afterDragging: impacted,\n        destination,\n        displacedBy,\n        last,\n        viewport: viewport.frame,\n        forceShouldAnimate\n    });\n    return {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index\n            }\n        }\n    };\n}\nfunction didStartAfterCritical(draggableId, afterCritical) {\n    return Boolean(afterCritical.effected[draggableId]);\n}\nvar fromCombine = ({ isMovingForward, destination, draggables, combine, afterCritical })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const combineId = combine.draggableId;\n    const combineWith = draggables[combineId];\n    const combineWithIndex = combineWith.descriptor.index;\n    const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n    if (didCombineWithStartAfterCritical) {\n        if (isMovingForward) {\n            return combineWithIndex;\n        }\n        return combineWithIndex - 1;\n    }\n    if (isMovingForward) {\n        return combineWithIndex + 1;\n    }\n    return combineWithIndex;\n};\nvar fromReorder = ({ isMovingForward, isInHomeList, insideDestination, location })=>{\n    if (!insideDestination.length) {\n        return null;\n    }\n    const currentIndex = location.index;\n    const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n    const firstIndex = insideDestination[0].descriptor.index;\n    const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n    const upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n    if (proposedIndex < firstIndex) {\n        return null;\n    }\n    if (proposedIndex > upperBound) {\n        return null;\n    }\n    return proposedIndex;\n};\nvar moveToNextIndex = ({ isMovingForward, isInHomeList, draggable, draggables, destination, insideDestination, previousImpact, viewport, afterCritical })=>{\n    const wasAt = previousImpact.at;\n    !wasAt ?  true ? invariant(false, \"Cannot move in direction without previous impact location\") : 0 : void 0;\n    if (wasAt.type === \"REORDER\") {\n        const newIndex = fromReorder({\n            isMovingForward,\n            isInHomeList,\n            location: wasAt.destination,\n            insideDestination\n        });\n        if (newIndex == null) {\n            return null;\n        }\n        return calculateReorderImpact({\n            draggable,\n            insideDestination,\n            destination,\n            viewport,\n            last: previousImpact.displaced,\n            displacedBy: previousImpact.displacedBy,\n            index: newIndex\n        });\n    }\n    const newIndex = fromCombine({\n        isMovingForward,\n        destination,\n        displaced: previousImpact.displaced,\n        draggables,\n        combine: wasAt.combine,\n        afterCritical\n    });\n    if (newIndex == null) {\n        return null;\n    }\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last: previousImpact.displaced,\n        displacedBy: previousImpact.displacedBy,\n        index: newIndex\n    });\n};\nvar getCombinedItemDisplacement = ({ displaced, afterCritical, combineWith, displacedBy })=>{\n    const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n    if (didStartAfterCritical(combineWith, afterCritical)) {\n        return isDisplaced ? origin : negate(displacedBy.point);\n    }\n    return isDisplaced ? displacedBy.point : origin;\n};\nvar whenCombining = ({ afterCritical, impact, draggables })=>{\n    const combine = tryGetCombine(impact);\n    !combine ?  true ? invariant() : 0 : void 0;\n    const combineWith = combine.draggableId;\n    const center = draggables[combineWith].page.borderBox.center;\n    const displaceBy = getCombinedItemDisplacement({\n        displaced: impact.displaced,\n        afterCritical,\n        combineWith,\n        displacedBy: impact.displacedBy\n    });\n    return add(center, displaceBy);\n};\nconst distanceFromStartToBorderBoxCenter = (axis, box)=>box.margin[axis.start] + box.borderBox[axis.size] / 2;\nconst distanceFromEndToBorderBoxCenter = (axis, box)=>box.margin[axis.end] + box.borderBox[axis.size] / 2;\nconst getCrossAxisBorderBoxCenter = (axis, target, isMoving)=>target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\nconst goAfter = ({ axis, moveRelativeTo, isMoving })=>patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goBefore = ({ axis, moveRelativeTo, isMoving })=>patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goIntoStart = ({ axis, moveInto, isMoving })=>patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\nvar whenReordering = ({ impact, draggable, draggables, droppable, afterCritical })=>{\n    const insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const draggablePage = draggable.page;\n    const axis = droppable.axis;\n    if (!insideDestination.length) {\n        return goIntoStart({\n            axis,\n            moveInto: droppable.page,\n            isMoving: draggablePage\n        });\n    }\n    const { displaced, displacedBy } = impact;\n    const closestAfter = displaced.all[0];\n    if (closestAfter) {\n        const closest = draggables[closestAfter];\n        if (didStartAfterCritical(closestAfter, afterCritical)) {\n            return goBefore({\n                axis,\n                moveRelativeTo: closest.page,\n                isMoving: draggablePage\n            });\n        }\n        const withDisplacement = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(closest.page, displacedBy.point);\n        return goBefore({\n            axis,\n            moveRelativeTo: withDisplacement,\n            isMoving: draggablePage\n        });\n    }\n    const last = insideDestination[insideDestination.length - 1];\n    if (last.descriptor.id === draggable.descriptor.id) {\n        return draggablePage.borderBox.center;\n    }\n    if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n        const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(last.page, negate(afterCritical.displacedBy.point));\n        return goAfter({\n            axis,\n            moveRelativeTo: page,\n            isMoving: draggablePage\n        });\n    }\n    return goAfter({\n        axis,\n        moveRelativeTo: last.page,\n        isMoving: draggablePage\n    });\n};\nvar withDroppableDisplacement = (droppable, point)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return point;\n    }\n    return add(point, frame.scroll.diff.displacement);\n};\nconst getResultWithoutDroppableDisplacement = ({ impact, draggable, droppable, draggables, afterCritical })=>{\n    const original = draggable.page.borderBox.center;\n    const at = impact.at;\n    if (!droppable) {\n        return original;\n    }\n    if (!at) {\n        return original;\n    }\n    if (at.type === \"REORDER\") {\n        return whenReordering({\n            impact,\n            draggable,\n            draggables,\n            droppable,\n            afterCritical\n        });\n    }\n    return whenCombining({\n        impact,\n        draggables,\n        afterCritical\n    });\n};\nvar getPageBorderBoxCenterFromImpact = (args)=>{\n    const withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n    const droppable = args.droppable;\n    const withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n    return withDisplacement;\n};\nvar scrollViewport = (viewport, newScroll)=>{\n    const diff = subtract(newScroll, viewport.scroll.initial);\n    const displacement = negate(diff);\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n        top: newScroll.y,\n        bottom: newScroll.y + viewport.frame.height,\n        left: newScroll.x,\n        right: newScroll.x + viewport.frame.width\n    });\n    const updated = {\n        frame,\n        scroll: {\n            initial: viewport.scroll.initial,\n            max: viewport.scroll.max,\n            current: newScroll,\n            diff: {\n                value: diff,\n                displacement\n            }\n        }\n    };\n    return updated;\n};\nfunction getDraggables$1(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nfunction tryGetVisible(id, groups) {\n    for(let i = 0; i < groups.length; i++){\n        const displacement = groups[i].visible[id];\n        if (displacement) {\n            return displacement;\n        }\n    }\n    return null;\n}\nvar speculativelyIncrease = ({ impact, viewport, destination, draggables, maxScrollChange })=>{\n    const scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n    const scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n    const last = impact.displaced;\n    const withViewportScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: scrolledViewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const withDroppableScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination: scrolledDroppable,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const invisible = {};\n    const visible = {};\n    const groups = [\n        last,\n        withViewportScroll,\n        withDroppableScroll\n    ];\n    last.all.forEach((id)=>{\n        const displacement = tryGetVisible(id, groups);\n        if (displacement) {\n            visible[id] = displacement;\n            return;\n        }\n        invisible[id] = true;\n    });\n    const newImpact = {\n        ...impact,\n        displaced: {\n            all: last.all,\n            invisible,\n            visible\n        }\n    };\n    return newImpact;\n};\nvar withViewportDisplacement = (viewport, point)=>add(viewport.scroll.diff.displacement, point);\nvar getClientFromPageBorderBoxCenter = ({ pageBorderBoxCenter, draggable, viewport })=>{\n    const withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n    const offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n    return add(draggable.client.borderBox.center, offset);\n};\nvar isTotallyVisibleInNewLocation = ({ draggable, destination, newPageBorderBoxCenter, viewport, withDroppableDisplacement, onlyOnMainAxis = false })=>{\n    const changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n    const shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n    const args = {\n        target: shifted,\n        destination,\n        withDroppableDisplacement,\n        viewport\n    };\n    return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n};\nvar moveToNextPlace = ({ isMovingForward, draggable, destination, draggables, previousImpact, viewport, previousPageBorderBoxCenter, previousClientSelection, afterCritical })=>{\n    if (!destination.isEnabled) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const isInHomeList = isHomeOf(draggable, destination);\n    const impact = moveToNextCombine({\n        isMovingForward,\n        draggable,\n        destination,\n        insideDestination,\n        previousImpact\n    }) || moveToNextIndex({\n        isMovingForward,\n        isInHomeList,\n        draggable,\n        draggables,\n        destination,\n        insideDestination,\n        previousImpact,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n        draggable,\n        destination,\n        newPageBorderBoxCenter: pageBorderBoxCenter,\n        viewport: viewport.frame,\n        withDroppableDisplacement: false,\n        onlyOnMainAxis: true\n    });\n    if (isVisibleInNewLocation) {\n        const clientSelection = getClientFromPageBorderBoxCenter({\n            pageBorderBoxCenter,\n            draggable,\n            viewport\n        });\n        return {\n            clientSelection,\n            impact,\n            scrollJumpRequest: null\n        };\n    }\n    const distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n    const cautious = speculativelyIncrease({\n        impact,\n        viewport,\n        destination,\n        draggables,\n        maxScrollChange: distance\n    });\n    return {\n        clientSelection: previousClientSelection,\n        impact: cautious,\n        scrollJumpRequest: distance\n    };\n};\nconst getKnownActive = (droppable)=>{\n    const rect = droppable.subject.active;\n    !rect ?  true ? invariant(false, \"Cannot get clipped area from droppable\") : 0 : void 0;\n    return rect;\n};\nvar getBestCrossAxisDroppable = ({ isMovingForward, pageBorderBoxCenter, source, droppables, viewport })=>{\n    const active = source.subject.active;\n    if (!active) {\n        return null;\n    }\n    const axis = source.axis;\n    const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n    const candidates = toDroppableList(droppables).filter((droppable)=>droppable !== source).filter((droppable)=>droppable.isEnabled).filter((droppable)=>Boolean(droppable.subject.active)).filter((droppable)=>isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        if (isMovingForward) {\n            return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n        }\n        return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n    }).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n        return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n    }).sort((a, b)=>{\n        const first = getKnownActive(a)[axis.crossAxisStart];\n        const second = getKnownActive(b)[axis.crossAxisStart];\n        if (isMovingForward) {\n            return first - second;\n        }\n        return second - first;\n    }).filter((droppable, index, array)=>getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0];\n    }\n    const contains = candidates.filter((droppable)=>{\n        const isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n        return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n    });\n    if (contains.length === 1) {\n        return contains[0];\n    }\n    if (contains.length > 1) {\n        return contains.sort((a, b)=>getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];\n    }\n    return candidates.sort((a, b)=>{\n        const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n        const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n        if (first !== second) {\n            return first - second;\n        }\n        return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n};\nconst getCurrentPageBorderBoxCenter = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox.center;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nconst getCurrentPageBorderBox = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\nvar getClosestDraggable = ({ pageBorderBoxCenter, viewport, destination, insideDestination, afterCritical })=>{\n    const sorted = insideDestination.filter((draggable)=>isTotallyVisible({\n            target: getCurrentPageBorderBox(draggable, afterCritical),\n            destination,\n            viewport: viewport.frame,\n            withDroppableDisplacement: true\n        })).sort((a, b)=>{\n        const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n        const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n        if (distanceToA < distanceToB) {\n            return -1;\n        }\n        if (distanceToB < distanceToA) {\n            return 1;\n        }\n        return a.descriptor.index - b.descriptor.index;\n    });\n    return sorted[0] || null;\n};\nvar getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {\n    const displacement = displaceBy[axis.line];\n    return {\n        value: displacement,\n        point: patch(axis.line, displacement)\n    };\n});\nconst getRequiredGrowthForPlaceholder = (droppable, placeholderSize, draggables)=>{\n    const axis = droppable.axis;\n    if (droppable.descriptor.mode === \"virtual\") {\n        return patch(axis.line, placeholderSize[axis.line]);\n    }\n    const availableSpace = droppable.subject.page.contentBox[axis.size];\n    const insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const spaceUsed = insideDroppable.reduce((sum, dimension)=>sum + dimension.client.marginBox[axis.size], 0);\n    const requiredSpace = spaceUsed + placeholderSize[axis.line];\n    const needsToGrowBy = requiredSpace - availableSpace;\n    if (needsToGrowBy <= 0) {\n        return null;\n    }\n    return patch(axis.line, needsToGrowBy);\n};\nconst withMaxScroll = (frame, max)=>({\n        ...frame,\n        scroll: {\n            ...frame.scroll,\n            max\n        }\n    });\nconst addPlaceholder = (droppable, draggable, draggables)=>{\n    const frame = droppable.frame;\n    !!isHomeOf(draggable, droppable) ?  true ? invariant(false, \"Should not add placeholder space to home list\") : 0 : void 0;\n    !!droppable.subject.withPlaceholder ?  true ? invariant(false, \"Cannot add placeholder size to a subject when it already has one\") : 0 : void 0;\n    const placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n    const requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n    const added = {\n        placeholderSize,\n        increasedBy: requiredGrowth,\n        oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n    };\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            withPlaceholder: added,\n            axis: droppable.axis,\n            frame: droppable.frame\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n    const newFrame = withMaxScroll(frame, maxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: added,\n        axis: droppable.axis,\n        frame: newFrame\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nconst removePlaceholder = (droppable)=>{\n    const added = droppable.subject.withPlaceholder;\n    !added ?  true ? invariant(false, \"Cannot remove placeholder form subject when there was none\") : 0 : void 0;\n    const frame = droppable.frame;\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            axis: droppable.axis,\n            frame: null,\n            withPlaceholder: null\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const oldMaxScroll = added.oldFrameMaxScroll;\n    !oldMaxScroll ?  true ? invariant(false, \"Expected droppable with frame to have old max frame scroll when removing placeholder\") : 0 : void 0;\n    const newFrame = withMaxScroll(frame, oldMaxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        axis: droppable.axis,\n        frame: newFrame,\n        withPlaceholder: null\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nvar moveToNewDroppable = ({ previousPageBorderBoxCenter, moveRelativeTo, insideDestination, draggable, draggables, destination, viewport, afterCritical })=>{\n    if (!moveRelativeTo) {\n        if (insideDestination.length) {\n            return null;\n        }\n        const proposed = {\n            displaced: emptyGroups,\n            displacedBy: noDisplacedBy,\n            at: {\n                type: \"REORDER\",\n                destination: {\n                    droppableId: destination.descriptor.id,\n                    index: 0\n                }\n            }\n        };\n        const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n            impact: proposed,\n            draggable,\n            droppable: destination,\n            draggables,\n            afterCritical\n        });\n        const withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n        const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n            draggable,\n            destination: withPlaceholder,\n            newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n            viewport: viewport.frame,\n            withDroppableDisplacement: false,\n            onlyOnMainAxis: true\n        });\n        return isVisibleInNewLocation ? proposed : null;\n    }\n    const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n    const proposedIndex = (()=>{\n        const relativeTo = moveRelativeTo.descriptor.index;\n        if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n            return relativeTo;\n        }\n        if (isGoingBeforeTarget) {\n            return relativeTo;\n        }\n        return relativeTo + 1;\n    })();\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        displacedBy,\n        last: emptyGroups,\n        index: proposedIndex\n    });\n};\nvar moveCrossAxis = ({ isMovingForward, previousPageBorderBoxCenter, draggable, isOver, draggables, droppables, viewport, afterCritical })=>{\n    const destination = getBestCrossAxisDroppable({\n        isMovingForward,\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        source: isOver,\n        droppables,\n        viewport\n    });\n    if (!destination) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const moveRelativeTo = getClosestDraggable({\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        viewport,\n        destination,\n        insideDestination,\n        afterCritical\n    });\n    const impact = moveToNewDroppable({\n        previousPageBorderBoxCenter,\n        destination,\n        draggable,\n        draggables,\n        moveRelativeTo,\n        insideDestination,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const clientSelection = getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n    return {\n        clientSelection,\n        impact,\n        scrollJumpRequest: null\n    };\n};\nvar whatIsDraggedOver = (impact)=>{\n    const at = impact.at;\n    if (!at) {\n        return null;\n    }\n    if (at.type === \"REORDER\") {\n        return at.destination.droppableId;\n    }\n    return at.combine.droppableId;\n};\nconst getDroppableOver$1 = (impact, droppables)=>{\n    const id = whatIsDraggedOver(impact);\n    return id ? droppables[id] : null;\n};\nvar moveInDirection = ({ state, type })=>{\n    const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);\n    const isMainAxisMovementAllowed = Boolean(isActuallyOver);\n    const home = state.dimensions.droppables[state.critical.droppable.id];\n    const isOver = isActuallyOver || home;\n    const direction = isOver.axis.direction;\n    const isMovingOnMainAxis = direction === \"vertical\" && (type === \"MOVE_UP\" || type === \"MOVE_DOWN\") || direction === \"horizontal\" && (type === \"MOVE_LEFT\" || type === \"MOVE_RIGHT\");\n    if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n        return null;\n    }\n    const isMovingForward = type === \"MOVE_DOWN\" || type === \"MOVE_RIGHT\";\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n    const { draggables, droppables } = state.dimensions;\n    return isMovingOnMainAxis ? moveToNextPlace({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        destination: isOver,\n        draggables,\n        viewport: state.viewport,\n        previousClientSelection: state.current.client.selection,\n        previousImpact: state.impact,\n        afterCritical: state.afterCritical\n    }) : moveCrossAxis({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        isOver,\n        draggables,\n        droppables,\n        viewport: state.viewport,\n        afterCritical: state.afterCritical\n    });\n};\nfunction isMovementAllowed(state) {\n    return state.phase === \"DRAGGING\" || state.phase === \"COLLECTING\";\n}\nfunction isPositionInFrame(frame) {\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function run(point) {\n        return isWithinVertical(point.y) && isWithinHorizontal(point.x);\n    };\n}\nfunction getHasOverlap(first, second) {\n    return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;\n}\nfunction getFurthestAway({ pageBorderBox, draggable, candidates }) {\n    const startCenter = draggable.page.borderBox.center;\n    const sorted = candidates.map((candidate)=>{\n        const axis = candidate.axis;\n        const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);\n        return {\n            id: candidate.descriptor.id,\n            distance: distance(startCenter, target)\n        };\n    }).sort((a, b)=>b.distance - a.distance);\n    return sorted[0] ? sorted[0].id : null;\n}\nfunction getDroppableOver({ pageBorderBox, draggable, droppables }) {\n    const candidates = toDroppableList(droppables).filter((item)=>{\n        if (!item.isEnabled) {\n            return false;\n        }\n        const active = item.subject.active;\n        if (!active) {\n            return false;\n        }\n        if (!getHasOverlap(pageBorderBox, active)) {\n            return false;\n        }\n        if (isPositionInFrame(active)(pageBorderBox.center)) {\n            return true;\n        }\n        const axis = item.axis;\n        const childCenter = active.center[axis.crossAxisLine];\n        const crossAxisStart = pageBorderBox[axis.crossAxisStart];\n        const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];\n        const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);\n        const isStartContained = isContained(crossAxisStart);\n        const isEndContained = isContained(crossAxisEnd);\n        if (!isStartContained && !isEndContained) {\n            return true;\n        }\n        if (isStartContained) {\n            return crossAxisStart < childCenter;\n        }\n        return crossAxisEnd > childCenter;\n    });\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0].descriptor.id;\n    }\n    return getFurthestAway({\n        pageBorderBox,\n        draggable,\n        candidates\n    });\n}\nconst offsetRectByPosition = (rect, point)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(offsetByPosition(rect, point));\nvar withDroppableScroll = (droppable, area)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return area;\n    }\n    return offsetRectByPosition(area, frame.scroll.diff.value);\n};\nfunction getIsDisplaced({ displaced, id }) {\n    return Boolean(displaced.visible[id] || displaced.invisible[id]);\n}\nfunction atIndex({ draggable, closest, inHomeList }) {\n    if (!closest) {\n        return null;\n    }\n    if (!inHomeList) {\n        return closest.descriptor.index;\n    }\n    if (closest.descriptor.index > draggable.descriptor.index) {\n        return closest.descriptor.index - 1;\n    }\n    return closest.descriptor.index;\n}\nvar getReorderImpact = ({ pageBorderBoxWithDroppableScroll: targetRect, draggable, destination, insideDestination, last, viewport, afterCritical })=>{\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const closest = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childCenter = child.page.borderBox.center[axis.line];\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: last,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd <= childCenter;\n            }\n            return targetStart < childCenter - displacement;\n        }\n        if (isDisplaced) {\n            return targetEnd <= childCenter + displacement;\n        }\n        return targetStart < childCenter;\n    }) || null;\n    const newIndex = atIndex({\n        draggable,\n        closest,\n        inHomeList: isHomeOf(draggable, destination)\n    });\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last,\n        displacedBy,\n        index: newIndex\n    });\n};\nconst combineThresholdDivisor = 4;\nvar getCombineImpact = ({ draggable, pageBorderBoxWithDroppableScroll: targetRect, previousImpact, destination, insideDestination, afterCritical })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const combineWith = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childRect = child.page.borderBox;\n        const childSize = childRect[axis.size];\n        const threshold = childSize / combineThresholdDivisor;\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: previousImpact.displaced,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;\n            }\n            return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;\n        }\n        if (isDisplaced) {\n            return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;\n        }\n        return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;\n    });\n    if (!combineWith) {\n        return null;\n    }\n    const impact = {\n        displacedBy,\n        displaced: previousImpact.displaced,\n        at: {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: combineWith.descriptor.id,\n                droppableId: destination.descriptor.id\n            }\n        }\n    };\n    return impact;\n};\nvar getDragImpact = ({ pageOffset, draggable, draggables, droppables, previousImpact, viewport, afterCritical })=>{\n    const pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);\n    const destinationId = getDroppableOver({\n        pageBorderBox,\n        draggable,\n        droppables\n    });\n    if (!destinationId) {\n        return noImpact;\n    }\n    const destination = droppables[destinationId];\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);\n    return getCombineImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        previousImpact,\n        destination,\n        insideDestination,\n        afterCritical\n    }) || getReorderImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        destination,\n        insideDestination,\n        last: previousImpact.displaced,\n        viewport,\n        afterCritical\n    });\n};\nvar patchDroppableMap = (droppables, updated)=>({\n        ...droppables,\n        [updated.descriptor.id]: updated\n    });\nconst clearUnusedPlaceholder = ({ previousImpact, impact, droppables })=>{\n    const last = whatIsDraggedOver(previousImpact);\n    const now = whatIsDraggedOver(impact);\n    if (!last) {\n        return droppables;\n    }\n    if (last === now) {\n        return droppables;\n    }\n    const lastDroppable = droppables[last];\n    if (!lastDroppable.subject.withPlaceholder) {\n        return droppables;\n    }\n    const updated = removePlaceholder(lastDroppable);\n    return patchDroppableMap(droppables, updated);\n};\nvar recomputePlaceholders = ({ draggable, draggables, droppables, previousImpact, impact })=>{\n    const cleaned = clearUnusedPlaceholder({\n        previousImpact,\n        impact,\n        droppables\n    });\n    const isOver = whatIsDraggedOver(impact);\n    if (!isOver) {\n        return cleaned;\n    }\n    const droppable = droppables[isOver];\n    if (isHomeOf(draggable, droppable)) {\n        return cleaned;\n    }\n    if (droppable.subject.withPlaceholder) {\n        return cleaned;\n    }\n    const patched = addPlaceholder(droppable, draggable, draggables);\n    return patchDroppableMap(cleaned, patched);\n};\nvar update = ({ state, clientSelection: forcedClientSelection, dimensions: forcedDimensions, viewport: forcedViewport, impact: forcedImpact, scrollJumpRequest })=>{\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const clientSelection = forcedClientSelection || state.current.client.selection;\n    const offset = subtract(clientSelection, state.initial.client.selection);\n    const client = {\n        offset,\n        selection: clientSelection,\n        borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n    };\n    const page = {\n        selection: add(client.selection, viewport.scroll.current),\n        borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),\n        offset: add(client.offset, viewport.scroll.diff.value)\n    };\n    const current = {\n        client,\n        page\n    };\n    if (state.phase === \"COLLECTING\") {\n        return {\n            ...state,\n            dimensions,\n            viewport,\n            current\n        };\n    }\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const newImpact = forcedImpact || getDragImpact({\n        pageOffset: page.offset,\n        draggable,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact: state.impact,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    const withUpdatedPlaceholders = recomputePlaceholders({\n        draggable,\n        impact: newImpact,\n        previousImpact: state.impact,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables\n    });\n    const result = {\n        ...state,\n        current,\n        dimensions: {\n            draggables: dimensions.draggables,\n            droppables: withUpdatedPlaceholders\n        },\n        impact: newImpact,\n        viewport,\n        scrollJumpRequest: scrollJumpRequest || null,\n        forceShouldAnimate: scrollJumpRequest ? false : null\n    };\n    return result;\n};\nfunction getDraggables(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nvar recompute = ({ impact, viewport, draggables, destination, forceShouldAnimate })=>{\n    const last = impact.displaced;\n    const afterDragging = getDraggables(last.all, draggables);\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        forceShouldAnimate,\n        last\n    });\n    return {\n        ...impact,\n        displaced\n    };\n};\nvar getClientBorderBoxCenter = ({ impact, draggable, droppable, draggables, viewport, afterCritical })=>{\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        draggables,\n        droppable,\n        afterCritical\n    });\n    return getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n};\nvar refreshSnap = ({ state, dimensions: forcedDimensions, viewport: forcedViewport })=>{\n    !(state.movementMode === \"SNAP\") ?  true ? invariant() : 0 : void 0;\n    const needsVisibilityCheck = state.impact;\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const { draggables, droppables } = dimensions;\n    const draggable = draggables[state.critical.draggable.id];\n    const isOver = whatIsDraggedOver(needsVisibilityCheck);\n    !isOver ?  true ? invariant(false, \"Must be over a destination in SNAP movement mode\") : 0 : void 0;\n    const destination = droppables[isOver];\n    const impact = recompute({\n        impact: needsVisibilityCheck,\n        viewport,\n        destination,\n        draggables\n    });\n    const clientSelection = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    return update({\n        impact,\n        clientSelection,\n        state,\n        dimensions,\n        viewport\n    });\n};\nvar getHomeLocation = (descriptor)=>({\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n    });\nvar getLiftEffect = ({ draggable, home, draggables, viewport })=>{\n    const displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n    const insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n    const rawIndex = insideHome.indexOf(draggable);\n    !(rawIndex !== -1) ?  true ? invariant(false, \"Expected draggable to be inside home list\") : 0 : void 0;\n    const afterDragging = insideHome.slice(rawIndex + 1);\n    const effected = afterDragging.reduce((previous, item)=>{\n        previous[item.descriptor.id] = true;\n        return previous;\n    }, {});\n    const afterCritical = {\n        inVirtualList: home.descriptor.mode === \"virtual\",\n        displacedBy,\n        effected\n    };\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination: home,\n        displacedBy,\n        last: null,\n        viewport: viewport.frame,\n        forceShouldAnimate: false\n    });\n    const impact = {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: getHomeLocation(draggable.descriptor)\n        }\n    };\n    return {\n        impact,\n        afterCritical\n    };\n};\nvar patchDimensionMap = (dimensions, updated)=>({\n        draggables: dimensions.draggables,\n        droppables: patchDroppableMap(dimensions.droppables, updated)\n    });\nconst start = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nconst finish = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nvar offsetDraggable = ({ draggable, offset: offset$1, initialWindowScroll })=>{\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(draggable.client, offset$1);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, initialWindowScroll);\n    const moved = {\n        ...draggable,\n        placeholder: {\n            ...draggable.placeholder,\n            client\n        },\n        client,\n        page\n    };\n    return moved;\n};\nvar getFrame = (droppable)=>{\n    const frame = droppable.frame;\n    !frame ?  true ? invariant(false, \"Expected Droppable to have a frame\") : 0 : void 0;\n    return frame;\n};\nvar adjustAdditionsForScrollChanges = ({ additions, updatedDroppables, viewport })=>{\n    const windowScrollChange = viewport.scroll.diff.value;\n    return additions.map((draggable)=>{\n        const droppableId = draggable.descriptor.droppableId;\n        const modified = updatedDroppables[droppableId];\n        const frame = getFrame(modified);\n        const droppableScrollChange = frame.scroll.diff.value;\n        const totalChange = add(windowScrollChange, droppableScrollChange);\n        const moved = offsetDraggable({\n            draggable,\n            offset: totalChange,\n            initialWindowScroll: viewport.scroll.initial\n        });\n        return moved;\n    });\n};\nvar publishWhileDraggingInVirtual = ({ state, published })=>{\n    start();\n    const withScrollChange = published.modified.map((update)=>{\n        const existing = state.dimensions.droppables[update.droppableId];\n        const scrolled = scrollDroppable(existing, update.scroll);\n        return scrolled;\n    });\n    const droppables = {\n        ...state.dimensions.droppables,\n        ...toDroppableMap(withScrollChange)\n    };\n    const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n        additions: published.additions,\n        updatedDroppables: droppables,\n        viewport: state.viewport\n    }));\n    const draggables = {\n        ...state.dimensions.draggables,\n        ...updatedAdditions\n    };\n    published.removals.forEach((id)=>{\n        delete draggables[id];\n    });\n    const dimensions = {\n        droppables,\n        draggables\n    };\n    const wasOverId = whatIsDraggedOver(state.impact);\n    const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const home = dimensions.droppables[state.critical.droppable.id];\n    const { impact: onLiftImpact, afterCritical } = getLiftEffect({\n        draggable,\n        home,\n        draggables,\n        viewport: state.viewport\n    });\n    const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n    const impact = getDragImpact({\n        pageOffset: state.current.page.offset,\n        draggable: dimensions.draggables[state.critical.draggable.id],\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact,\n        viewport: state.viewport,\n        afterCritical\n    });\n    finish();\n    const draggingState = {\n        ...state,\n        phase: \"DRAGGING\",\n        impact,\n        onLiftImpact,\n        dimensions,\n        afterCritical,\n        forceShouldAnimate: false\n    };\n    if (state.phase === \"COLLECTING\") {\n        return draggingState;\n    }\n    const dropPending = {\n        ...draggingState,\n        phase: \"DROP_PENDING\",\n        reason: state.reason,\n        isWaiting: false\n    };\n    return dropPending;\n};\nconst isSnapping = (state)=>state.movementMode === \"SNAP\";\nconst postDroppableChange = (state, updated, isEnabledChanging)=>{\n    const dimensions = patchDimensionMap(state.dimensions, updated);\n    if (!isSnapping(state) || isEnabledChanging) {\n        return update({\n            state,\n            dimensions\n        });\n    }\n    return refreshSnap({\n        state,\n        dimensions\n    });\n};\nfunction removeScrollJumpRequest(state) {\n    if (state.isDragging && state.movementMode === \"SNAP\") {\n        return {\n            ...state,\n            scrollJumpRequest: null\n        };\n    }\n    return state;\n}\nconst idle$2 = {\n    phase: \"IDLE\",\n    completed: null,\n    shouldFlush: false\n};\nvar reducer = (state = idle$2, action)=>{\n    if (action.type === \"FLUSH\") {\n        return {\n            ...idle$2,\n            shouldFlush: true\n        };\n    }\n    if (action.type === \"INITIAL_PUBLISH\") {\n        !(state.phase === \"IDLE\") ?  true ? invariant(false, \"INITIAL_PUBLISH must come after a IDLE phase\") : 0 : void 0;\n        const { critical, clientSelection, viewport, dimensions, movementMode } = action.payload;\n        const draggable = dimensions.draggables[critical.draggable.id];\n        const home = dimensions.droppables[critical.droppable.id];\n        const client = {\n            selection: clientSelection,\n            borderBoxCenter: draggable.client.borderBox.center,\n            offset: origin\n        };\n        const initial = {\n            client,\n            page: {\n                selection: add(client.selection, viewport.scroll.initial),\n                borderBoxCenter: add(client.selection, viewport.scroll.initial),\n                offset: add(client.selection, viewport.scroll.diff.value)\n            }\n        };\n        const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every((item)=>!item.isFixedOnPage);\n        const { impact, afterCritical } = getLiftEffect({\n            draggable,\n            home,\n            draggables: dimensions.draggables,\n            viewport\n        });\n        const result = {\n            phase: \"DRAGGING\",\n            isDragging: true,\n            critical,\n            movementMode,\n            dimensions,\n            initial,\n            current: initial,\n            isWindowScrollAllowed,\n            impact,\n            afterCritical,\n            onLiftImpact: impact,\n            viewport,\n            scrollJumpRequest: null,\n            forceShouldAnimate: null\n        };\n        return result;\n    }\n    if (action.type === \"COLLECTION_STARTING\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `Collection cannot start from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            ...state,\n            phase: \"COLLECTING\"\n        };\n        return result;\n    }\n    if (action.type === \"PUBLISH_WHILE_DRAGGING\") {\n        !(state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Unexpected ${action.type} received in phase ${state.phase}`) : 0 : void 0;\n        return publishWhileDraggingInVirtual({\n            state,\n            published: action.payload\n        });\n    }\n    if (action.type === \"MOVE\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { client: clientSelection } = action.payload;\n        if (isEqual$1(clientSelection, state.current.client.selection)) {\n            return state;\n        }\n        return update({\n            state,\n            clientSelection,\n            impact: isSnapping(state) ? state.impact : null\n        });\n    }\n    if (action.type === \"UPDATE_DROPPABLE_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return removeScrollJumpRequest(state);\n        }\n        if (state.phase === \"COLLECTING\") {\n            return removeScrollJumpRequest(state);\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { id, newScroll } = action.payload;\n        const target = state.dimensions.droppables[id];\n        if (!target) {\n            return state;\n        }\n        const scrolled = scrollDroppable(target, newScroll);\n        return postDroppableChange(state, scrolled, false);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its enabled state`) : 0 : void 0;\n        !(target.isEnabled !== isEnabled) ?  true ? invariant(false, `Trying to set droppable isEnabled to ${String(isEnabled)}\n      but it is already ${String(target.isEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isCombineEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its isCombineEnabled state`) : 0 : void 0;\n        !(target.isCombineEnabled !== isCombineEnabled) ?  true ? invariant(false, `Trying to set droppable isCombineEnabled to ${String(isCombineEnabled)}\n      but it is already ${String(target.isCombineEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isCombineEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"MOVE_BY_WINDOW_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\" || state.phase === \"DROP_ANIMATING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Cannot move by window in phase ${state.phase}`) : 0 : void 0;\n        !state.isWindowScrollAllowed ?  true ? invariant(false, \"Window scrolling is currently not supported for fixed lists\") : 0 : void 0;\n        const newScroll = action.payload.newScroll;\n        if (isEqual$1(state.viewport.scroll.current, newScroll)) {\n            return removeScrollJumpRequest(state);\n        }\n        const viewport = scrollViewport(state.viewport, newScroll);\n        if (isSnapping(state)) {\n            return refreshSnap({\n                state,\n                viewport\n            });\n        }\n        return update({\n            state,\n            viewport\n        });\n    }\n    if (action.type === \"UPDATE_VIEWPORT_MAX_SCROLL\") {\n        if (!isMovementAllowed(state)) {\n            return state;\n        }\n        const maxScroll = action.payload.maxScroll;\n        if (isEqual$1(maxScroll, state.viewport.scroll.max)) {\n            return state;\n        }\n        const withMaxScroll = {\n            ...state.viewport,\n            scroll: {\n                ...state.viewport.scroll,\n                max: maxScroll\n            }\n        };\n        return {\n            ...state,\n            viewport: withMaxScroll\n        };\n    }\n    if (action.type === \"MOVE_UP\" || action.type === \"MOVE_DOWN\" || action.type === \"MOVE_LEFT\" || action.type === \"MOVE_RIGHT\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `${action.type} received while not in DRAGGING phase`) : 0 : void 0;\n        const result = moveInDirection({\n            state,\n            type: action.type\n        });\n        if (!result) {\n            return state;\n        }\n        return update({\n            state,\n            impact: result.impact,\n            clientSelection: result.clientSelection,\n            scrollJumpRequest: result.scrollJumpRequest\n        });\n    }\n    if (action.type === \"DROP_PENDING\") {\n        const reason = action.payload.reason;\n        !(state.phase === \"COLLECTING\") ?  true ? invariant(false, \"Can only move into the DROP_PENDING phase from the COLLECTING phase\") : 0 : void 0;\n        const newState = {\n            ...state,\n            phase: \"DROP_PENDING\",\n            isWaiting: true,\n            reason\n        };\n        return newState;\n    }\n    if (action.type === \"DROP_ANIMATE\") {\n        const { completed, dropDuration, newHomeClientOffset } = action.payload;\n        !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot animate drop from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            phase: \"DROP_ANIMATING\",\n            completed,\n            dropDuration,\n            newHomeClientOffset,\n            dimensions: state.dimensions\n        };\n        return result;\n    }\n    if (action.type === \"DROP_COMPLETE\") {\n        const { completed } = action.payload;\n        return {\n            phase: \"IDLE\",\n            completed,\n            shouldFlush: false\n        };\n    }\n    return state;\n};\nfunction guard(action, predicate) {\n    return action instanceof Object && \"type\" in action && action.type === predicate;\n}\nconst beforeInitialCapture = (args)=>({\n        type: \"BEFORE_INITIAL_CAPTURE\",\n        payload: args\n    });\nconst lift$1 = (args)=>({\n        type: \"LIFT\",\n        payload: args\n    });\nconst initialPublish = (args)=>({\n        type: \"INITIAL_PUBLISH\",\n        payload: args\n    });\nconst publishWhileDragging = (args)=>({\n        type: \"PUBLISH_WHILE_DRAGGING\",\n        payload: args\n    });\nconst collectionStarting = ()=>({\n        type: \"COLLECTION_STARTING\",\n        payload: null\n    });\nconst updateDroppableScroll = (args)=>({\n        type: \"UPDATE_DROPPABLE_SCROLL\",\n        payload: args\n    });\nconst updateDroppableIsEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_ENABLED\",\n        payload: args\n    });\nconst updateDroppableIsCombineEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\",\n        payload: args\n    });\nconst move = (args)=>({\n        type: \"MOVE\",\n        payload: args\n    });\nconst moveByWindowScroll = (args)=>({\n        type: \"MOVE_BY_WINDOW_SCROLL\",\n        payload: args\n    });\nconst updateViewportMaxScroll = (args)=>({\n        type: \"UPDATE_VIEWPORT_MAX_SCROLL\",\n        payload: args\n    });\nconst moveUp = ()=>({\n        type: \"MOVE_UP\",\n        payload: null\n    });\nconst moveDown = ()=>({\n        type: \"MOVE_DOWN\",\n        payload: null\n    });\nconst moveRight = ()=>({\n        type: \"MOVE_RIGHT\",\n        payload: null\n    });\nconst moveLeft = ()=>({\n        type: \"MOVE_LEFT\",\n        payload: null\n    });\nconst flush = ()=>({\n        type: \"FLUSH\",\n        payload: null\n    });\nconst animateDrop = (args)=>({\n        type: \"DROP_ANIMATE\",\n        payload: args\n    });\nconst completeDrop = (args)=>({\n        type: \"DROP_COMPLETE\",\n        payload: args\n    });\nconst drop = (args)=>({\n        type: \"DROP\",\n        payload: args\n    });\nconst dropPending = (args)=>({\n        type: \"DROP_PENDING\",\n        payload: args\n    });\nconst dropAnimationFinished = ()=>({\n        type: \"DROP_ANIMATION_FINISHED\",\n        payload: null\n    });\nfunction checkIndexes(insideDestination) {\n    if (insideDestination.length <= 1) {\n        return;\n    }\n    const indexes = insideDestination.map((d)=>d.descriptor.index);\n    const errors = {};\n    for(let i = 1; i < indexes.length; i++){\n        const current = indexes[i];\n        const previous = indexes[i - 1];\n        if (current !== previous + 1) {\n            errors[current] = true;\n        }\n    }\n    if (!Object.keys(errors).length) {\n        return;\n    }\n    const formatted = indexes.map((index)=>{\n        const hasError = Boolean(errors[index]);\n        return hasError ? `[ðŸ”¥${index}]` : `${index}`;\n    }).join(\", \");\n     true ? warning(`\n    Detected non-consecutive <Draggable /> indexes.\n\n    (This can cause unexpected bugs)\n\n    ${formatted}\n  `) : 0;\n}\nfunction validateDimensions(critical, dimensions) {\n    if (true) {\n        const insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n        checkIndexes(insideDestination);\n    }\n}\nvar lift = (marshal)=>({ getState, dispatch })=>(next)=>(action)=>{\n                if (!guard(action, \"LIFT\")) {\n                    next(action);\n                    return;\n                }\n                const { id, clientSelection, movementMode } = action.payload;\n                const initial = getState();\n                if (initial.phase === \"DROP_ANIMATING\") {\n                    dispatch(completeDrop({\n                        completed: initial.completed\n                    }));\n                }\n                !(getState().phase === \"IDLE\") ?  true ? invariant(false, \"Unexpected phase to start a drag\") : 0 : void 0;\n                dispatch(flush());\n                dispatch(beforeInitialCapture({\n                    draggableId: id,\n                    movementMode\n                }));\n                const scrollOptions = {\n                    shouldPublishImmediately: movementMode === \"SNAP\"\n                };\n                const request = {\n                    draggableId: id,\n                    scrollOptions\n                };\n                const { critical, dimensions, viewport } = marshal.startPublishing(request);\n                validateDimensions(critical, dimensions);\n                dispatch(initialPublish({\n                    critical,\n                    dimensions,\n                    clientSelection,\n                    movementMode,\n                    viewport\n                }));\n            };\nvar style = (marshal)=>()=>(next)=>(action)=>{\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    marshal.dragging();\n                }\n                if (guard(action, \"DROP_ANIMATE\")) {\n                    marshal.dropping(action.payload.completed.result.reason);\n                }\n                if (guard(action, \"FLUSH\") || guard(action, \"DROP_COMPLETE\")) {\n                    marshal.resting();\n                }\n                next(action);\n            };\nconst curves = {\n    outOfTheWay: \"cubic-bezier(0.2, 0, 0, 1)\",\n    drop: \"cubic-bezier(.2,1,.1,1)\"\n};\nconst combine = {\n    opacity: {\n        drop: 0,\n        combining: 0.7\n    },\n    scale: {\n        drop: 0.75\n    }\n};\nconst timings = {\n    outOfTheWay: 0.2,\n    minDropTime: 0.33,\n    maxDropTime: 0.55\n};\nconst outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;\nconst transitions = {\n    fluid: `opacity ${outOfTheWayTiming}`,\n    snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,\n    drop: (duration)=>{\n        const timing = `${duration}s ${curves.drop}`;\n        return `transform ${timing}, opacity ${timing}`;\n    },\n    outOfTheWay: `transform ${outOfTheWayTiming}`,\n    placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`\n};\nconst moveTo = (offset)=>isEqual$1(offset, origin) ? undefined : `translate(${offset.x}px, ${offset.y}px)`;\nconst transforms = {\n    moveTo,\n    drop: (offset, isCombining)=>{\n        const translate = moveTo(offset);\n        if (!translate) {\n            return undefined;\n        }\n        if (!isCombining) {\n            return translate;\n        }\n        return `${translate} scale(${combine.scale.drop})`;\n    }\n};\nconst { minDropTime, maxDropTime } = timings;\nconst dropTimeRange = maxDropTime - minDropTime;\nconst maxDropTimeAtDistance = 1500;\nconst cancelDropModifier = 0.6;\nvar getDropDuration = ({ current, destination, reason })=>{\n    const distance$1 = distance(current, destination);\n    if (distance$1 <= 0) {\n        return minDropTime;\n    }\n    if (distance$1 >= maxDropTimeAtDistance) {\n        return maxDropTime;\n    }\n    const percentage = distance$1 / maxDropTimeAtDistance;\n    const duration = minDropTime + dropTimeRange * percentage;\n    const withDuration = reason === \"CANCEL\" ? duration * cancelDropModifier : duration;\n    return Number(withDuration.toFixed(2));\n};\nvar getNewHomeClientOffset = ({ impact, draggable, dimensions, viewport, afterCritical })=>{\n    const { draggables, droppables } = dimensions;\n    const droppableId = whatIsDraggedOver(impact);\n    const destination = droppableId ? droppables[droppableId] : null;\n    const home = droppables[draggable.descriptor.droppableId];\n    const newClientCenter = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        draggables,\n        afterCritical,\n        droppable: destination || home,\n        viewport\n    });\n    const offset = subtract(newClientCenter, draggable.client.borderBox.center);\n    return offset;\n};\nvar getDropImpact = ({ draggables, reason, lastImpact, home, viewport, onLiftImpact })=>{\n    if (!lastImpact.at || reason !== \"DROP\") {\n        const recomputedHomeImpact = recompute({\n            draggables,\n            impact: onLiftImpact,\n            destination: home,\n            viewport,\n            forceShouldAnimate: true\n        });\n        return {\n            impact: recomputedHomeImpact,\n            didDropInsideDroppable: false\n        };\n    }\n    if (lastImpact.at.type === \"REORDER\") {\n        return {\n            impact: lastImpact,\n            didDropInsideDroppable: true\n        };\n    }\n    const withoutMovement = {\n        ...lastImpact,\n        displaced: emptyGroups\n    };\n    return {\n        impact: withoutMovement,\n        didDropInsideDroppable: true\n    };\n};\nconst dropMiddleware = ({ getState, dispatch })=>(next)=>(action)=>{\n            if (!guard(action, \"DROP\")) {\n                next(action);\n                return;\n            }\n            const state = getState();\n            const reason = action.payload.reason;\n            if (state.phase === \"COLLECTING\") {\n                dispatch(dropPending({\n                    reason\n                }));\n                return;\n            }\n            if (state.phase === \"IDLE\") {\n                return;\n            }\n            const isWaitingForDrop = state.phase === \"DROP_PENDING\" && state.isWaiting;\n            !!isWaitingForDrop ?  true ? invariant(false, \"A DROP action occurred while DROP_PENDING and still waiting\") : 0 : void 0;\n            !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot drop in phase: ${state.phase}`) : 0 : void 0;\n            const critical = state.critical;\n            const dimensions = state.dimensions;\n            const draggable = dimensions.draggables[state.critical.draggable.id];\n            const { impact, didDropInsideDroppable } = getDropImpact({\n                reason,\n                lastImpact: state.impact,\n                afterCritical: state.afterCritical,\n                onLiftImpact: state.onLiftImpact,\n                home: state.dimensions.droppables[state.critical.droppable.id],\n                viewport: state.viewport,\n                draggables: state.dimensions.draggables\n            });\n            const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n            const combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n            const source = {\n                index: critical.draggable.index,\n                droppableId: critical.droppable.id\n            };\n            const result = {\n                draggableId: draggable.descriptor.id,\n                type: draggable.descriptor.type,\n                source,\n                reason,\n                mode: state.movementMode,\n                destination,\n                combine\n            };\n            const newHomeClientOffset = getNewHomeClientOffset({\n                impact,\n                draggable,\n                dimensions,\n                viewport: state.viewport,\n                afterCritical: state.afterCritical\n            });\n            const completed = {\n                critical: state.critical,\n                afterCritical: state.afterCritical,\n                result,\n                impact\n            };\n            const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n            if (!isAnimationRequired) {\n                dispatch(completeDrop({\n                    completed\n                }));\n                return;\n            }\n            const dropDuration = getDropDuration({\n                current: state.current.client.offset,\n                destination: newHomeClientOffset,\n                reason\n            });\n            const args = {\n                newHomeClientOffset,\n                dropDuration,\n                completed\n            };\n            dispatch(animateDrop(args));\n        };\nvar getWindowScroll = ()=>({\n        x: window.pageXOffset,\n        y: window.pageYOffset\n    });\nfunction getWindowScrollBinding(update) {\n    return {\n        eventName: \"scroll\",\n        options: {\n            passive: true,\n            capture: false\n        },\n        fn: (event)=>{\n            if (event.target !== window && event.target !== window.document) {\n                return;\n            }\n            update();\n        }\n    };\n}\nfunction getScrollListener({ onWindowScroll }) {\n    function updateScroll() {\n        onWindowScroll(getWindowScroll());\n    }\n    const scheduled = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(updateScroll);\n    const binding = getWindowScrollBinding(scheduled);\n    let unbind = noop$2;\n    function isActive() {\n        return unbind !== noop$2;\n    }\n    function start() {\n        !!isActive() ?  true ? invariant(false, \"Cannot start scroll listener when already active\") : 0 : void 0;\n        unbind = bindEvents(window, [\n            binding\n        ]);\n    }\n    function stop() {\n        !isActive() ?  true ? invariant(false, \"Cannot stop scroll listener when not active\") : 0 : void 0;\n        scheduled.cancel();\n        unbind();\n        unbind = noop$2;\n    }\n    return {\n        start,\n        stop,\n        isActive\n    };\n}\nconst shouldStop$1 = (action)=>guard(action, \"DROP_COMPLETE\") || guard(action, \"DROP_ANIMATE\") || guard(action, \"FLUSH\");\nconst scrollListener = (store)=>{\n    const listener = getScrollListener({\n        onWindowScroll: (newScroll)=>{\n            store.dispatch(moveByWindowScroll({\n                newScroll\n            }));\n        }\n    });\n    return (next)=>(action)=>{\n            if (!listener.isActive() && guard(action, \"INITIAL_PUBLISH\")) {\n                listener.start();\n            }\n            if (listener.isActive() && shouldStop$1(action)) {\n                listener.stop();\n            }\n            next(action);\n        };\n};\nvar getExpiringAnnounce = (announce)=>{\n    let wasCalled = false;\n    let isExpired = false;\n    const timeoutId = setTimeout(()=>{\n        isExpired = true;\n    });\n    const result = (message)=>{\n        if (wasCalled) {\n             true ? warning(\"Announcement already made. Not making a second announcement\") : 0;\n            return;\n        }\n        if (isExpired) {\n             true ? warning(`\n        Announcements cannot be made asynchronously.\n        Default message has already been announced.\n      `) : 0;\n            return;\n        }\n        wasCalled = true;\n        announce(message);\n        clearTimeout(timeoutId);\n    };\n    result.wasCalled = ()=>wasCalled;\n    return result;\n};\nvar getAsyncMarshal = ()=>{\n    const entries = [];\n    const execute = (timerId)=>{\n        const index = entries.findIndex((item)=>item.timerId === timerId);\n        !(index !== -1) ?  true ? invariant(false, \"Could not find timer\") : 0 : void 0;\n        const [entry] = entries.splice(index, 1);\n        entry.callback();\n    };\n    const add = (fn)=>{\n        const timerId = setTimeout(()=>execute(timerId));\n        const entry = {\n            timerId,\n            callback: fn\n        };\n        entries.push(entry);\n    };\n    const flush = ()=>{\n        if (!entries.length) {\n            return;\n        }\n        const shallow = [\n            ...entries\n        ];\n        entries.length = 0;\n        shallow.forEach((entry)=>{\n            clearTimeout(entry.timerId);\n            entry.callback();\n        });\n    };\n    return {\n        add,\n        flush\n    };\n};\nconst areLocationsEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.droppableId === second.droppableId && first.index === second.index;\n};\nconst isCombineEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nconst isCriticalEqual = (first, second)=>{\n    if (first === second) {\n        return true;\n    }\n    const isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n    const isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n    return isDraggableEqual && isDroppableEqual;\n};\nconst withTimings = (key, fn)=>{\n    start();\n    fn();\n    finish();\n};\nconst getDragStart = (critical, mode)=>({\n        draggableId: critical.draggable.id,\n        type: critical.droppable.type,\n        source: {\n            droppableId: critical.droppable.id,\n            index: critical.draggable.index\n        },\n        mode\n    });\nfunction execute(responder, data, announce, getDefaultMessage) {\n    if (!responder) {\n        announce(getDefaultMessage(data));\n        return;\n    }\n    const willExpire = getExpiringAnnounce(announce);\n    const provided = {\n        announce: willExpire\n    };\n    responder(data, provided);\n    if (!willExpire.wasCalled()) {\n        announce(getDefaultMessage(data));\n    }\n}\nvar getPublisher = (getResponders, announce)=>{\n    const asyncMarshal = getAsyncMarshal();\n    let dragging = null;\n    const beforeCapture = (draggableId, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeCapture as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeCapture\", ()=>{\n            const fn = getResponders().onBeforeCapture;\n            if (fn) {\n                const before = {\n                    draggableId,\n                    mode\n                };\n                fn(before);\n            }\n        });\n    };\n    const beforeStart = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeDragStart\", ()=>{\n            const fn = getResponders().onBeforeDragStart;\n            if (fn) {\n                fn(getDragStart(critical, mode));\n            }\n        });\n    };\n    const start = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        const data = getDragStart(critical, mode);\n        dragging = {\n            mode,\n            lastCritical: critical,\n            lastLocation: data.source,\n            lastCombine: null\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragStart\", ()=>execute(getResponders().onDragStart, data, announce, preset.onDragStart));\n        });\n    };\n    const update = (critical, impact)=>{\n        const location = tryGetDestination(impact);\n        const combine = tryGetCombine(impact);\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragMove when onDragStart has not been called\") : 0 : void 0;\n        const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n        if (hasCriticalChanged) {\n            dragging.lastCritical = critical;\n        }\n        const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n        if (hasLocationChanged) {\n            dragging.lastLocation = location;\n        }\n        const hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n        if (hasGroupingChanged) {\n            dragging.lastCombine = combine;\n        }\n        if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n            return;\n        }\n        const data = {\n            ...getDragStart(critical, dragging.mode),\n            combine,\n            destination: location\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragUpdate\", ()=>execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate));\n        });\n    };\n    const flush = ()=>{\n        !dragging ?  true ? invariant(false, \"Can only flush responders while dragging\") : 0 : void 0;\n        asyncMarshal.flush();\n    };\n    const drop = (result)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragEnd when there is no matching onDragStart\") : 0 : void 0;\n        dragging = null;\n        withTimings(\"onDragEnd\", ()=>execute(getResponders().onDragEnd, result, announce, preset.onDragEnd));\n    };\n    const abort = ()=>{\n        if (!dragging) {\n            return;\n        }\n        const result = {\n            ...getDragStart(dragging.lastCritical, dragging.mode),\n            combine: null,\n            destination: null,\n            reason: \"CANCEL\"\n        };\n        drop(result);\n    };\n    return {\n        beforeCapture,\n        beforeStart,\n        start,\n        update,\n        flush,\n        drop,\n        abort\n    };\n};\nvar responders = (getResponders, announce)=>{\n    const publisher = getPublisher(getResponders, announce);\n    return (store)=>(next)=>(action)=>{\n                if (guard(action, \"BEFORE_INITIAL_CAPTURE\")) {\n                    publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);\n                    return;\n                }\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    const critical = action.payload.critical;\n                    publisher.beforeStart(critical, action.payload.movementMode);\n                    next(action);\n                    publisher.start(critical, action.payload.movementMode);\n                    return;\n                }\n                if (guard(action, \"DROP_COMPLETE\")) {\n                    const result = action.payload.completed.result;\n                    publisher.flush();\n                    next(action);\n                    publisher.drop(result);\n                    return;\n                }\n                next(action);\n                if (guard(action, \"FLUSH\")) {\n                    publisher.abort();\n                    return;\n                }\n                const state = store.getState();\n                if (state.phase === \"DRAGGING\") {\n                    publisher.update(state.critical, state.impact);\n                }\n            };\n};\nconst dropAnimationFinishMiddleware = (store)=>(next)=>(action)=>{\n            if (!guard(action, \"DROP_ANIMATION_FINISHED\")) {\n                next(action);\n                return;\n            }\n            const state = store.getState();\n            !(state.phase === \"DROP_ANIMATING\") ?  true ? invariant(false, \"Cannot finish a drop animating when no drop is occurring\") : 0 : void 0;\n            store.dispatch(completeDrop({\n                completed: state.completed\n            }));\n        };\nconst dropAnimationFlushOnScrollMiddleware = (store)=>{\n    let unbind = null;\n    let frameId = null;\n    function clear() {\n        if (frameId) {\n            cancelAnimationFrame(frameId);\n            frameId = null;\n        }\n        if (unbind) {\n            unbind();\n            unbind = null;\n        }\n    }\n    return (next)=>(action)=>{\n            if (guard(action, \"FLUSH\") || guard(action, \"DROP_COMPLETE\") || guard(action, \"DROP_ANIMATION_FINISHED\")) {\n                clear();\n            }\n            next(action);\n            if (!guard(action, \"DROP_ANIMATE\")) {\n                return;\n            }\n            const binding = {\n                eventName: \"scroll\",\n                options: {\n                    capture: true,\n                    passive: false,\n                    once: true\n                },\n                fn: function flushDropAnimation() {\n                    const state = store.getState();\n                    if (state.phase === \"DROP_ANIMATING\") {\n                        store.dispatch(dropAnimationFinished());\n                    }\n                }\n            };\n            frameId = requestAnimationFrame(()=>{\n                frameId = null;\n                unbind = bindEvents(window, [\n                    binding\n                ]);\n            });\n        };\n};\nvar dimensionMarshalStopper = (marshal)=>()=>(next)=>(action)=>{\n                if (guard(action, \"DROP_COMPLETE\") || guard(action, \"FLUSH\") || guard(action, \"DROP_ANIMATE\")) {\n                    marshal.stopPublishing();\n                }\n                next(action);\n            };\nvar focus = (marshal)=>{\n    let isWatching = false;\n    return ()=>(next)=>(action)=>{\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    isWatching = true;\n                    marshal.tryRecordFocus(action.payload.critical.draggable.id);\n                    next(action);\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                next(action);\n                if (!isWatching) {\n                    return;\n                }\n                if (guard(action, \"FLUSH\")) {\n                    isWatching = false;\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                if (guard(action, \"DROP_COMPLETE\")) {\n                    isWatching = false;\n                    const result = action.payload.completed.result;\n                    if (result.combine) {\n                        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n                    }\n                    marshal.tryRestoreFocusRecorded();\n                }\n            };\n};\nconst shouldStop = (action)=>guard(action, \"DROP_COMPLETE\") || guard(action, \"DROP_ANIMATE\") || guard(action, \"FLUSH\");\nvar autoScroll = (autoScroller)=>(store)=>(next)=>(action)=>{\n                if (shouldStop(action)) {\n                    autoScroller.stop();\n                    next(action);\n                    return;\n                }\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    next(action);\n                    const state = store.getState();\n                    !(state.phase === \"DRAGGING\") ?  true ? invariant(false, \"Expected phase to be DRAGGING after INITIAL_PUBLISH\") : 0 : void 0;\n                    autoScroller.start(state);\n                    return;\n                }\n                next(action);\n                autoScroller.scroll(store.getState());\n            };\nconst pendingDrop = (store)=>(next)=>(action)=>{\n            next(action);\n            if (!guard(action, \"PUBLISH_WHILE_DRAGGING\")) {\n                return;\n            }\n            const postActionState = store.getState();\n            if (postActionState.phase !== \"DROP_PENDING\") {\n                return;\n            }\n            if (postActionState.isWaiting) {\n                return;\n            }\n            store.dispatch(drop({\n                reason: postActionState.reason\n            }));\n        };\nconst composeEnhancers =  false ? 0 : redux__WEBPACK_IMPORTED_MODULE_5__.compose;\nvar createStore = ({ dimensionMarshal, focusMarshal, styleMarshal, getResponders, announce, autoScroller })=>(0,redux__WEBPACK_IMPORTED_MODULE_5__.createStore)(reducer, composeEnhancers((0,redux__WEBPACK_IMPORTED_MODULE_5__.applyMiddleware)(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), dropMiddleware, dropAnimationFinishMiddleware, dropAnimationFlushOnScrollMiddleware, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\nconst clean$1 = ()=>({\n        additions: {},\n        removals: {},\n        modified: {}\n    });\nfunction createPublisher({ registry, callbacks }) {\n    let staging = clean$1();\n    let frameId = null;\n    const collect = ()=>{\n        if (frameId) {\n            return;\n        }\n        callbacks.collectionStarting();\n        frameId = requestAnimationFrame(()=>{\n            frameId = null;\n            start();\n            const { additions, removals, modified } = staging;\n            const added = Object.keys(additions).map((id)=>registry.draggable.getById(id).getDimension(origin)).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n            const updated = Object.keys(modified).map((id)=>{\n                const entry = registry.droppable.getById(id);\n                const scroll = entry.callbacks.getScrollWhileDragging();\n                return {\n                    droppableId: id,\n                    scroll\n                };\n            });\n            const result = {\n                additions: added,\n                removals: Object.keys(removals),\n                modified: updated\n            };\n            staging = clean$1();\n            finish();\n            callbacks.publish(result);\n        });\n    };\n    const add = (entry)=>{\n        const id = entry.descriptor.id;\n        staging.additions[id] = entry;\n        staging.modified[entry.descriptor.droppableId] = true;\n        if (staging.removals[id]) {\n            delete staging.removals[id];\n        }\n        collect();\n    };\n    const remove = (entry)=>{\n        const descriptor = entry.descriptor;\n        staging.removals[descriptor.id] = true;\n        staging.modified[descriptor.droppableId] = true;\n        if (staging.additions[descriptor.id]) {\n            delete staging.additions[descriptor.id];\n        }\n        collect();\n    };\n    const stop = ()=>{\n        if (!frameId) {\n            return;\n        }\n        cancelAnimationFrame(frameId);\n        frameId = null;\n        staging = clean$1();\n    };\n    return {\n        add,\n        remove,\n        stop\n    };\n}\nvar getMaxScroll = ({ scrollHeight, scrollWidth, height, width })=>{\n    const maxScroll = subtract({\n        x: scrollWidth,\n        y: scrollHeight\n    }, {\n        x: width,\n        y: height\n    });\n    const adjustedMaxScroll = {\n        x: Math.max(0, maxScroll.x),\n        y: Math.max(0, maxScroll.y)\n    };\n    return adjustedMaxScroll;\n};\nvar getDocumentElement = ()=>{\n    const doc = document.documentElement;\n    !doc ?  true ? invariant(false, \"Cannot find document.documentElement\") : 0 : void 0;\n    return doc;\n};\nvar getMaxWindowScroll = ()=>{\n    const doc = getDocumentElement();\n    const maxScroll = getMaxScroll({\n        scrollHeight: doc.scrollHeight,\n        scrollWidth: doc.scrollWidth,\n        width: doc.clientWidth,\n        height: doc.clientHeight\n    });\n    return maxScroll;\n};\nvar getViewport = ()=>{\n    const scroll = getWindowScroll();\n    const maxScroll = getMaxWindowScroll();\n    const top = scroll.y;\n    const left = scroll.x;\n    const doc = getDocumentElement();\n    const width = doc.clientWidth;\n    const height = doc.clientHeight;\n    const right = left + width;\n    const bottom = top + height;\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n        top,\n        left,\n        right,\n        bottom\n    });\n    const viewport = {\n        frame,\n        scroll: {\n            initial: scroll,\n            current: scroll,\n            max: maxScroll,\n            diff: {\n                value: origin,\n                displacement: origin\n            }\n        }\n    };\n    return viewport;\n};\nvar getInitialPublish = ({ critical, scrollOptions, registry })=>{\n    start();\n    const viewport = getViewport();\n    const windowScroll = viewport.scroll.current;\n    const home = critical.droppable;\n    const droppables = registry.droppable.getAllByType(home.type).map((entry)=>entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));\n    const draggables = registry.draggable.getAllByType(critical.draggable.type).map((entry)=>entry.getDimension(windowScroll));\n    const dimensions = {\n        draggables: toDraggableMap(draggables),\n        droppables: toDroppableMap(droppables)\n    };\n    finish();\n    const result = {\n        dimensions,\n        critical,\n        viewport\n    };\n    return result;\n};\nfunction shouldPublishUpdate(registry, dragging, entry) {\n    if (entry.descriptor.id === dragging.id) {\n        return false;\n    }\n    if (entry.descriptor.type !== dragging.type) {\n        return false;\n    }\n    const home = registry.droppable.getById(entry.descriptor.droppableId);\n    if (home.descriptor.mode !== \"virtual\") {\n         true ? warning(`\n      You are attempting to add or remove a Draggable [id: ${entry.descriptor.id}]\n      while a drag is occurring. This is only supported for virtual lists.\n\n      See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md\n    `) : 0;\n        return false;\n    }\n    return true;\n}\nvar createDimensionMarshal = (registry, callbacks)=>{\n    let collection = null;\n    const publisher = createPublisher({\n        callbacks: {\n            publish: callbacks.publishWhileDragging,\n            collectionStarting: callbacks.collectionStarting\n        },\n        registry\n    });\n    const updateDroppableIsEnabled = (id, isEnabled)=>{\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        if (!collection) {\n            return;\n        }\n        callbacks.updateDroppableIsEnabled({\n            id,\n            isEnabled\n        });\n    };\n    const updateDroppableIsCombineEnabled = (id, isCombineEnabled)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update isCombineEnabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableIsCombineEnabled({\n            id,\n            isCombineEnabled\n        });\n    };\n    const updateDroppableScroll = (id, newScroll)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update the scroll on Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableScroll({\n            id,\n            newScroll\n        });\n    };\n    const scrollDroppable = (id, change)=>{\n        if (!collection) {\n            return;\n        }\n        registry.droppable.getById(id).callbacks.scroll(change);\n    };\n    const stopPublishing = ()=>{\n        if (!collection) {\n            return;\n        }\n        publisher.stop();\n        const home = collection.critical.droppable;\n        registry.droppable.getAllByType(home.type).forEach((entry)=>entry.callbacks.dragStopped());\n        collection.unsubscribe();\n        collection = null;\n    };\n    const subscriber = (event)=>{\n        !collection ?  true ? invariant(false, \"Should only be subscribed when a collection is occurring\") : 0 : void 0;\n        const dragging = collection.critical.draggable;\n        if (event.type === \"ADDITION\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.add(event.value);\n            }\n        }\n        if (event.type === \"REMOVAL\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.remove(event.value);\n            }\n        }\n    };\n    const startPublishing = (request)=>{\n        !!collection ?  true ? invariant(false, \"Cannot start capturing critical dimensions as there is already a collection\") : 0 : void 0;\n        const entry = registry.draggable.getById(request.draggableId);\n        const home = registry.droppable.getById(entry.descriptor.droppableId);\n        const critical = {\n            draggable: entry.descriptor,\n            droppable: home.descriptor\n        };\n        const unsubscribe = registry.subscribe(subscriber);\n        collection = {\n            critical,\n            unsubscribe\n        };\n        return getInitialPublish({\n            critical,\n            registry,\n            scrollOptions: request.scrollOptions\n        });\n    };\n    const marshal = {\n        updateDroppableIsEnabled,\n        updateDroppableIsCombineEnabled,\n        scrollDroppable,\n        updateDroppableScroll,\n        startPublishing,\n        stopPublishing\n    };\n    return marshal;\n};\nvar canStartDrag = (state, id)=>{\n    if (state.phase === \"IDLE\") {\n        return true;\n    }\n    if (state.phase !== \"DROP_ANIMATING\") {\n        return false;\n    }\n    if (state.completed.result.draggableId === id) {\n        return false;\n    }\n    return state.completed.result.reason === \"DROP\";\n};\nvar scrollWindow = (change)=>{\n    window.scrollBy(change.x, change.y);\n};\nconst getScrollableDroppables = memoizeOne((droppables)=>toDroppableList(droppables).filter((droppable)=>{\n        if (!droppable.isEnabled) {\n            return false;\n        }\n        if (!droppable.frame) {\n            return false;\n        }\n        return true;\n    }));\nconst getScrollableDroppableOver = (target, droppables)=>{\n    const maybe = getScrollableDroppables(droppables).find((droppable)=>{\n        !droppable.frame ?  true ? invariant(false, \"Invalid result\") : 0 : void 0;\n        return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n    }) || null;\n    return maybe;\n};\nvar getBestScrollableDroppable = ({ center, destination, droppables })=>{\n    if (destination) {\n        const dimension = droppables[destination];\n        if (!dimension.frame) {\n            return null;\n        }\n        return dimension;\n    }\n    const dimension = getScrollableDroppableOver(center, droppables);\n    return dimension;\n};\nconst defaultAutoScrollerOptions = {\n    startFromPercentage: 0.25,\n    maxScrollAtPercentage: 0.05,\n    maxPixelScroll: 28,\n    ease: (percentage)=>percentage ** 2,\n    durationDampening: {\n        stopDampeningAt: 1200,\n        accelerateAt: 360\n    },\n    disabled: false\n};\nvar getDistanceThresholds = (container, axis, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;\n    const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;\n    const thresholds = {\n        startScrollingFrom,\n        maxScrollValueAt\n    };\n    return thresholds;\n};\nvar getPercentage = ({ startOfRange, endOfRange, current })=>{\n    const range = endOfRange - startOfRange;\n    if (range === 0) {\n         true ? warning(`\n      Detected distance range of 0 in the fluid auto scroller\n      This is unexpected and would cause a divide by 0 issue.\n      Not allowing an auto scroll\n    `) : 0;\n        return 0;\n    }\n    const currentInRange = current - startOfRange;\n    const percentage = currentInRange / range;\n    return percentage;\n};\nvar minScroll = 1;\nvar getValueFromDistance = (distanceToEdge, thresholds, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    if (distanceToEdge > thresholds.startScrollingFrom) {\n        return 0;\n    }\n    if (distanceToEdge <= thresholds.maxScrollValueAt) {\n        return autoScrollerOptions.maxPixelScroll;\n    }\n    if (distanceToEdge === thresholds.startScrollingFrom) {\n        return minScroll;\n    }\n    const percentageFromMaxScrollValueAt = getPercentage({\n        startOfRange: thresholds.maxScrollValueAt,\n        endOfRange: thresholds.startScrollingFrom,\n        current: distanceToEdge\n    });\n    const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n    const scroll = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);\n    return Math.ceil(scroll);\n};\nvar dampenValueByTime = (proposedScroll, dragStartTime, getAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;\n    const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;\n    const startOfRange = dragStartTime;\n    const endOfRange = stopAt;\n    const now = Date.now();\n    const runTime = now - startOfRange;\n    if (runTime >= stopAt) {\n        return proposedScroll;\n    }\n    if (runTime < accelerateAt) {\n        return minScroll;\n    }\n    const betweenAccelerateAtAndStopAtPercentage = getPercentage({\n        startOfRange: accelerateAt,\n        endOfRange,\n        current: runTime\n    });\n    const scroll = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);\n    return Math.ceil(scroll);\n};\nvar getValue = ({ distanceToEdge, thresholds, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const scroll = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);\n    if (scroll === 0) {\n        return 0;\n    }\n    if (!shouldUseTimeDampening) {\n        return scroll;\n    }\n    return Math.max(dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions), minScroll);\n};\nvar getScrollOnAxis = ({ container, distanceToEdges, dragStartTime, axis, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);\n    const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n    if (isCloserToEnd) {\n        return getValue({\n            distanceToEdge: distanceToEdges[axis.end],\n            thresholds,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    }\n    return -1 * getValue({\n        distanceToEdge: distanceToEdges[axis.start],\n        thresholds,\n        dragStartTime,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n};\nvar adjustForSizeLimits = ({ container, subject, proposedScroll })=>{\n    const isTooBigVertically = subject.height > container.height;\n    const isTooBigHorizontally = subject.width > container.width;\n    if (!isTooBigHorizontally && !isTooBigVertically) {\n        return proposedScroll;\n    }\n    if (isTooBigHorizontally && isTooBigVertically) {\n        return null;\n    }\n    return {\n        x: isTooBigHorizontally ? 0 : proposedScroll.x,\n        y: isTooBigVertically ? 0 : proposedScroll.y\n    };\n};\nconst clean = apply((value)=>value === 0 ? 0 : value);\nvar getScroll$1 = ({ dragStartTime, container, subject, center, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const distanceToEdges = {\n        top: center.y - container.top,\n        right: container.right - center.x,\n        bottom: container.bottom - center.y,\n        left: center.x - container.left\n    };\n    const y = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: vertical,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const x = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: horizontal,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const required = clean({\n        x,\n        y\n    });\n    if (isEqual$1(required, origin)) {\n        return null;\n    }\n    const limited = adjustForSizeLimits({\n        container,\n        subject,\n        proposedScroll: required\n    });\n    if (!limited) {\n        return null;\n    }\n    return isEqual$1(limited, origin) ? null : limited;\n};\nconst smallestSigned = apply((value)=>{\n    if (value === 0) {\n        return 0;\n    }\n    return value > 0 ? 1 : -1;\n});\nconst getOverlap = (()=>{\n    const getRemainder = (target, max)=>{\n        if (target < 0) {\n            return target;\n        }\n        if (target > max) {\n            return target - max;\n        }\n        return 0;\n    };\n    return ({ current, max, change })=>{\n        const targetScroll = add(current, change);\n        const overlap = {\n            x: getRemainder(targetScroll.x, max.x),\n            y: getRemainder(targetScroll.y, max.y)\n        };\n        if (isEqual$1(overlap, origin)) {\n            return null;\n        }\n        return overlap;\n    };\n})();\nconst canPartiallyScroll = ({ max: rawMax, current, change })=>{\n    const max = {\n        x: Math.max(current.x, rawMax.x),\n        y: Math.max(current.y, rawMax.y)\n    };\n    const smallestChange = smallestSigned(change);\n    const overlap = getOverlap({\n        max,\n        current,\n        change: smallestChange\n    });\n    if (!overlap) {\n        return true;\n    }\n    if (smallestChange.x !== 0 && overlap.x === 0) {\n        return true;\n    }\n    if (smallestChange.y !== 0 && overlap.y === 0) {\n        return true;\n    }\n    return false;\n};\nconst canScrollWindow = (viewport, change)=>canPartiallyScroll({\n        current: viewport.scroll.current,\n        max: viewport.scroll.max,\n        change\n    });\nconst getWindowOverlap = (viewport, change)=>{\n    if (!canScrollWindow(viewport, change)) {\n        return null;\n    }\n    const max = viewport.scroll.max;\n    const current = viewport.scroll.current;\n    return getOverlap({\n        current,\n        max,\n        change\n    });\n};\nconst canScrollDroppable = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return false;\n    }\n    return canPartiallyScroll({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nconst getDroppableOverlap = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    if (!canScrollDroppable(droppable, change)) {\n        return null;\n    }\n    return getOverlap({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nvar getWindowScrollChange = ({ viewport, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: viewport.frame,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n};\nvar getDroppableScrollChange = ({ droppable, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: frame.pageMarginBox,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n};\nvar scroll = ({ state, dragStartTime, shouldUseTimeDampening, scrollWindow, scrollDroppable, getAutoScrollerOptions })=>{\n    const center = state.current.page.borderBoxCenter;\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const subject = draggable.page.marginBox;\n    if (state.isWindowScrollAllowed) {\n        const viewport = state.viewport;\n        const change = getWindowScrollChange({\n            dragStartTime,\n            viewport,\n            subject,\n            center,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n        if (change) {\n            scrollWindow(change);\n            return;\n        }\n    }\n    const droppable = getBestScrollableDroppable({\n        center,\n        destination: whatIsDraggedOver(state.impact),\n        droppables: state.dimensions.droppables\n    });\n    if (!droppable) {\n        return;\n    }\n    const change = getDroppableScrollChange({\n        dragStartTime,\n        droppable,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    if (change) {\n        scrollDroppable(droppable.descriptor.id, change);\n    }\n};\nvar createFluidScroller = ({ scrollWindow, scrollDroppable, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions })=>{\n    const scheduleWindowScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(scrollWindow);\n    const scheduleDroppableScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(scrollDroppable);\n    let dragging = null;\n    const tryScroll = (state)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fluid scroll if not dragging\") : 0 : void 0;\n        const { shouldUseTimeDampening, dragStartTime } = dragging;\n        scroll({\n            state,\n            scrollWindow: scheduleWindowScroll,\n            scrollDroppable: scheduleDroppableScroll,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    };\n    const start$1 = (state)=>{\n        start();\n        !!dragging ?  true ? invariant(false, \"Cannot start auto scrolling when already started\") : 0 : void 0;\n        const dragStartTime = Date.now();\n        let wasScrollNeeded = false;\n        const fakeScrollCallback = ()=>{\n            wasScrollNeeded = true;\n        };\n        scroll({\n            state,\n            dragStartTime: 0,\n            shouldUseTimeDampening: false,\n            scrollWindow: fakeScrollCallback,\n            scrollDroppable: fakeScrollCallback,\n            getAutoScrollerOptions\n        });\n        dragging = {\n            dragStartTime,\n            shouldUseTimeDampening: wasScrollNeeded\n        };\n        finish();\n        if (wasScrollNeeded) {\n            tryScroll(state);\n        }\n    };\n    const stop = ()=>{\n        if (!dragging) {\n            return;\n        }\n        scheduleWindowScroll.cancel();\n        scheduleDroppableScroll.cancel();\n        dragging = null;\n    };\n    return {\n        start: start$1,\n        stop,\n        scroll: tryScroll\n    };\n};\nvar createJumpScroller = ({ move, scrollDroppable, scrollWindow })=>{\n    const moveByOffset = (state, offset)=>{\n        const client = add(state.current.client.selection, offset);\n        move({\n            client\n        });\n    };\n    const scrollDroppableAsMuchAsItCan = (droppable, change)=>{\n        if (!canScrollDroppable(droppable, change)) {\n            return change;\n        }\n        const overlap = getDroppableOverlap(droppable, change);\n        if (!overlap) {\n            scrollDroppable(droppable.descriptor.id, change);\n            return null;\n        }\n        const whatTheDroppableCanScroll = subtract(change, overlap);\n        scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n        const remainder = subtract(change, whatTheDroppableCanScroll);\n        return remainder;\n    };\n    const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport, change)=>{\n        if (!isWindowScrollAllowed) {\n            return change;\n        }\n        if (!canScrollWindow(viewport, change)) {\n            return change;\n        }\n        const overlap = getWindowOverlap(viewport, change);\n        if (!overlap) {\n            scrollWindow(change);\n            return null;\n        }\n        const whatTheWindowCanScroll = subtract(change, overlap);\n        scrollWindow(whatTheWindowCanScroll);\n        const remainder = subtract(change, whatTheWindowCanScroll);\n        return remainder;\n    };\n    const jumpScroller = (state)=>{\n        const request = state.scrollJumpRequest;\n        if (!request) {\n            return;\n        }\n        const destination = whatIsDraggedOver(state.impact);\n        !destination ?  true ? invariant(false, \"Cannot perform a jump scroll when there is no destination\") : 0 : void 0;\n        const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n        if (!droppableRemainder) {\n            return;\n        }\n        const viewport = state.viewport;\n        const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n        if (!windowRemainder) {\n            return;\n        }\n        moveByOffset(state, windowRemainder);\n    };\n    return jumpScroller;\n};\nvar createAutoScroller = ({ scrollDroppable, scrollWindow, move, getAutoScrollerOptions })=>{\n    const fluidScroller = createFluidScroller({\n        scrollWindow,\n        scrollDroppable,\n        getAutoScrollerOptions\n    });\n    const jumpScroll = createJumpScroller({\n        move,\n        scrollWindow,\n        scrollDroppable\n    });\n    const scroll = (state)=>{\n        const autoScrollerOptions = getAutoScrollerOptions();\n        if (autoScrollerOptions.disabled || state.phase !== \"DRAGGING\") {\n            return;\n        }\n        if (state.movementMode === \"FLUID\") {\n            fluidScroller.scroll(state);\n            return;\n        }\n        if (!state.scrollJumpRequest) {\n            return;\n        }\n        jumpScroll(state);\n    };\n    const scroller = {\n        scroll,\n        start: fluidScroller.start,\n        stop: fluidScroller.stop\n    };\n    return scroller;\n};\nconst prefix = \"data-rfd\";\nconst dragHandle = (()=>{\n    const base = `${prefix}-drag-handle`;\n    return {\n        base,\n        draggableId: `${base}-draggable-id`,\n        contextId: `${base}-context-id`\n    };\n})();\nconst draggable = (()=>{\n    const base = `${prefix}-draggable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst droppable = (()=>{\n    const base = `${prefix}-droppable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst scrollContainer = {\n    contextId: `${prefix}-scroll-container-context-id`\n};\nconst makeGetSelector = (context)=>(attribute)=>`[${attribute}=\"${context}\"]`;\nconst getStyles = (rules, property)=>rules.map((rule)=>{\n        const value = rule.styles[property];\n        if (!value) {\n            return \"\";\n        }\n        return `${rule.selector} { ${value} }`;\n    }).join(\" \");\nconst noPointerEvents = \"pointer-events: none;\";\nvar getStyles$1 = (contextId)=>{\n    const getSelector = makeGetSelector(contextId);\n    const dragHandle$1 = (()=>{\n        const grabCursor = `\n      cursor: -webkit-grab;\n      cursor: grab;\n    `;\n        return {\n            selector: getSelector(dragHandle.contextId),\n            styles: {\n                always: `\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        `,\n                resting: grabCursor,\n                dragging: noPointerEvents,\n                dropAnimating: grabCursor\n            }\n        };\n    })();\n    const draggable$1 = (()=>{\n        const transition = `\n      transition: ${transitions.outOfTheWay};\n    `;\n        return {\n            selector: getSelector(draggable.contextId),\n            styles: {\n                dragging: transition,\n                dropAnimating: transition,\n                userCancel: transition\n            }\n        };\n    })();\n    const droppable$1 = {\n        selector: getSelector(droppable.contextId),\n        styles: {\n            always: `overflow-anchor: none;`\n        }\n    };\n    const body = {\n        selector: \"body\",\n        styles: {\n            dragging: `\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      `\n        }\n    };\n    const rules = [\n        draggable$1,\n        dragHandle$1,\n        droppable$1,\n        body\n    ];\n    return {\n        always: getStyles(rules, \"always\"),\n        resting: getStyles(rules, \"resting\"),\n        dragging: getStyles(rules, \"dragging\"),\n        dropAnimating: getStyles(rules, \"dropAnimating\"),\n        userCancel: getStyles(rules, \"userCancel\")\n    };\n};\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nconst getHead = ()=>{\n    const head = document.querySelector(\"head\");\n    !head ?  true ? invariant(false, \"Cannot find the head to append a style to\") : 0 : void 0;\n    return head;\n};\nconst createStyleEl = (nonce)=>{\n    const el = document.createElement(\"style\");\n    if (nonce) {\n        el.setAttribute(\"nonce\", nonce);\n    }\n    el.type = \"text/css\";\n    return el;\n};\nfunction useStyleMarshal(contextId, nonce) {\n    const styles = useMemo(()=>getStyles$1(contextId), [\n        contextId\n    ]);\n    const alwaysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const dynamicRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setDynamicStyle = useCallback(memoizeOne((proposed)=>{\n        const el = dynamicRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }), []);\n    const setAlwaysStyle = useCallback((proposed)=>{\n        const el = alwaysRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        !(!alwaysRef.current && !dynamicRef.current) ?  true ? invariant(false, \"style elements already mounted\") : 0 : void 0;\n        const always = createStyleEl(nonce);\n        const dynamic = createStyleEl(nonce);\n        alwaysRef.current = always;\n        dynamicRef.current = dynamic;\n        always.setAttribute(`${prefix}-always`, contextId);\n        dynamic.setAttribute(`${prefix}-dynamic`, contextId);\n        getHead().appendChild(always);\n        getHead().appendChild(dynamic);\n        setAlwaysStyle(styles.always);\n        setDynamicStyle(styles.resting);\n        return ()=>{\n            const remove = (ref)=>{\n                const current = ref.current;\n                !current ?  true ? invariant(false, \"Cannot unmount ref as it is not set\") : 0 : void 0;\n                getHead().removeChild(current);\n                ref.current = null;\n            };\n            remove(alwaysRef);\n            remove(dynamicRef);\n        };\n    }, [\n        nonce,\n        setAlwaysStyle,\n        setDynamicStyle,\n        styles.always,\n        styles.resting,\n        contextId\n    ]);\n    const dragging = useCallback(()=>setDynamicStyle(styles.dragging), [\n        setDynamicStyle,\n        styles.dragging\n    ]);\n    const dropping = useCallback((reason)=>{\n        if (reason === \"DROP\") {\n            setDynamicStyle(styles.dropAnimating);\n            return;\n        }\n        setDynamicStyle(styles.userCancel);\n    }, [\n        setDynamicStyle,\n        styles.dropAnimating,\n        styles.userCancel\n    ]);\n    const resting = useCallback(()=>{\n        if (!dynamicRef.current) {\n            return;\n        }\n        setDynamicStyle(styles.resting);\n    }, [\n        setDynamicStyle,\n        styles.resting\n    ]);\n    const marshal = useMemo(()=>({\n            dragging,\n            dropping,\n            resting\n        }), [\n        dragging,\n        dropping,\n        resting\n    ]);\n    return marshal;\n}\nfunction querySelectorAll(parentNode, selector) {\n    return Array.from(parentNode.querySelectorAll(selector));\n}\nvar getWindowFromEl = (el)=>{\n    if (el && el.ownerDocument && el.ownerDocument.defaultView) {\n        return el.ownerDocument.defaultView;\n    }\n    return window;\n};\nfunction isHtmlElement(el) {\n    return el instanceof getWindowFromEl(el).HTMLElement;\n}\nfunction findDragHandle(contextId, draggableId) {\n    const selector = `[${dragHandle.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    if (!possible.length) {\n         true ? warning(`Unable to find any drag handles in the context \"${contextId}\"`) : 0;\n        return null;\n    }\n    const handle = possible.find((el)=>{\n        return el.getAttribute(dragHandle.draggableId) === draggableId;\n    });\n    if (!handle) {\n         true ? warning(`Unable to find drag handle with id \"${draggableId}\" as no handle with a matching id was found`) : 0;\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle needs to be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction useFocusMarshal(contextId) {\n    const entriesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const recordRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const restoreFocusFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const register = useCallback(function register(id, focus) {\n        const entry = {\n            id,\n            focus\n        };\n        entriesRef.current[id] = entry;\n        return function unregister() {\n            const entries = entriesRef.current;\n            const current = entries[id];\n            if (current !== entry) {\n                delete entries[id];\n            }\n        };\n    }, []);\n    const tryGiveFocus = useCallback(function tryGiveFocus(tryGiveFocusTo) {\n        const handle = findDragHandle(contextId, tryGiveFocusTo);\n        if (handle && handle !== document.activeElement) {\n            handle.focus();\n        }\n    }, [\n        contextId\n    ]);\n    const tryShiftRecord = useCallback(function tryShiftRecord(previous, redirectTo) {\n        if (recordRef.current === previous) {\n            recordRef.current = redirectTo;\n        }\n    }, []);\n    const tryRestoreFocusRecorded = useCallback(function tryRestoreFocusRecorded() {\n        if (restoreFocusFrameRef.current) {\n            return;\n        }\n        if (!isMountedRef.current) {\n            return;\n        }\n        restoreFocusFrameRef.current = requestAnimationFrame(()=>{\n            restoreFocusFrameRef.current = null;\n            const record = recordRef.current;\n            if (record) {\n                tryGiveFocus(record);\n            }\n        });\n    }, [\n        tryGiveFocus\n    ]);\n    const tryRecordFocus = useCallback(function tryRecordFocus(id) {\n        recordRef.current = null;\n        const focused = document.activeElement;\n        if (!focused) {\n            return;\n        }\n        if (focused.getAttribute(dragHandle.draggableId) !== id) {\n            return;\n        }\n        recordRef.current = id;\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        isMountedRef.current = true;\n        return function clearFrameOnUnmount() {\n            isMountedRef.current = false;\n            const frameId = restoreFocusFrameRef.current;\n            if (frameId) {\n                cancelAnimationFrame(frameId);\n            }\n        };\n    }, []);\n    const marshal = useMemo(()=>({\n            register,\n            tryRecordFocus,\n            tryRestoreFocusRecorded,\n            tryShiftRecord\n        }), [\n        register,\n        tryRecordFocus,\n        tryRestoreFocusRecorded,\n        tryShiftRecord\n    ]);\n    return marshal;\n}\nfunction createRegistry() {\n    const entries = {\n        draggables: {},\n        droppables: {}\n    };\n    const subscribers = [];\n    function subscribe(cb) {\n        subscribers.push(cb);\n        return function unsubscribe() {\n            const index = subscribers.indexOf(cb);\n            if (index === -1) {\n                return;\n            }\n            subscribers.splice(index, 1);\n        };\n    }\n    function notify(event) {\n        if (subscribers.length) {\n            subscribers.forEach((cb)=>cb(event));\n        }\n    }\n    function findDraggableById(id) {\n        return entries.draggables[id] || null;\n    }\n    function getDraggableById(id) {\n        const entry = findDraggableById(id);\n        !entry ?  true ? invariant(false, `Cannot find draggable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const draggableAPI = {\n        register: (entry)=>{\n            entries.draggables[entry.descriptor.id] = entry;\n            notify({\n                type: \"ADDITION\",\n                value: entry\n            });\n        },\n        update: (entry, last)=>{\n            const current = entries.draggables[last.descriptor.id];\n            if (!current) {\n                return;\n            }\n            if (current.uniqueId !== entry.uniqueId) {\n                return;\n            }\n            delete entries.draggables[last.descriptor.id];\n            entries.draggables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const draggableId = entry.descriptor.id;\n            const current = findDraggableById(draggableId);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.draggables[draggableId];\n            if (entries.droppables[entry.descriptor.droppableId]) {\n                notify({\n                    type: \"REMOVAL\",\n                    value: entry\n                });\n            }\n        },\n        getById: getDraggableById,\n        findById: findDraggableById,\n        exists: (id)=>Boolean(findDraggableById(id)),\n        getAllByType: (type)=>Object.values(entries.draggables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function findDroppableById(id) {\n        return entries.droppables[id] || null;\n    }\n    function getDroppableById(id) {\n        const entry = findDroppableById(id);\n        !entry ?  true ? invariant(false, `Cannot find droppable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const droppableAPI = {\n        register: (entry)=>{\n            entries.droppables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const current = findDroppableById(entry.descriptor.id);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.droppables[entry.descriptor.id];\n        },\n        getById: getDroppableById,\n        findById: findDroppableById,\n        exists: (id)=>Boolean(findDroppableById(id)),\n        getAllByType: (type)=>Object.values(entries.droppables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function clean() {\n        entries.draggables = {};\n        entries.droppables = {};\n        subscribers.length = 0;\n    }\n    return {\n        draggable: draggableAPI,\n        droppable: droppableAPI,\n        subscribe,\n        clean\n    };\n}\nfunction useRegistry() {\n    const registry = useMemo(createRegistry, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return function unmount() {\n            registry.clean();\n        };\n    }, [\n        registry\n    ]);\n    return registry;\n}\nvar StoreContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar getBodyElement = ()=>{\n    const body = document.body;\n    !body ?  true ? invariant(false, \"Cannot find document.body\") : 0 : void 0;\n    return body;\n};\nconst visuallyHidden = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    margin: \"-1px\",\n    border: \"0\",\n    padding: \"0\",\n    overflow: \"hidden\",\n    clip: \"rect(0 0 0 0)\",\n    \"clip-path\": \"inset(100%)\"\n};\nconst getId = (contextId)=>`rfd-announcement-${contextId}`;\nfunction useAnnouncer(contextId) {\n    const id = useMemo(()=>getId(contextId), [\n        contextId\n    ]);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function setup() {\n        const el = document.createElement(\"div\");\n        ref.current = el;\n        el.id = id;\n        el.setAttribute(\"aria-live\", \"assertive\");\n        el.setAttribute(\"aria-atomic\", \"true\");\n        (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(el.style, visuallyHidden);\n        getBodyElement().appendChild(el);\n        return function cleanup() {\n            setTimeout(function remove() {\n                const body = getBodyElement();\n                if (body.contains(el)) {\n                    body.removeChild(el);\n                }\n                if (el === ref.current) {\n                    ref.current = null;\n                }\n            });\n        };\n    }, [\n        id\n    ]);\n    const announce = useCallback((message)=>{\n        const el = ref.current;\n        if (el) {\n            el.textContent = message;\n            return;\n        }\n         true ? warning(`\n      A screen reader message was trying to be announced but it was unable to do so.\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\n      Consider calling provided.announce() before the unmount so that the instruction will\n      not be lost for users relying on a screen reader.\n\n      Message not passed to screen reader:\n\n      \"${message}\"\n    `) : 0;\n    }, []);\n    return announce;\n}\nconst defaults = {\n    separator: \"::\"\n};\nfunction useUniqueId(prefix, options = defaults) {\n    const id = react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n    return useMemo(()=>`${prefix}${options.separator}${id}`, [\n        options.separator,\n        prefix,\n        id\n    ]);\n}\nfunction getElementId({ contextId, uniqueId }) {\n    return `rfd-hidden-text-${contextId}-${uniqueId}`;\n}\nfunction useHiddenTextElement({ contextId, text }) {\n    const uniqueId = useUniqueId(\"hidden-text\", {\n        separator: \"-\"\n    });\n    const id = useMemo(()=>getElementId({\n            contextId,\n            uniqueId\n        }), [\n        uniqueId,\n        contextId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function mount() {\n        const el = document.createElement(\"div\");\n        el.id = id;\n        el.textContent = text;\n        el.style.display = \"none\";\n        getBodyElement().appendChild(el);\n        return function unmount() {\n            const body = getBodyElement();\n            if (body.contains(el)) {\n                body.removeChild(el);\n            }\n        };\n    }, [\n        id,\n        text\n    ]);\n    return id;\n}\nvar AppContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar peerDependencies = {\n    react: \"^18.0.0 || ^19.0.0\"\n};\nconst semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\nconst getVersion = (value)=>{\n    const result = semver.exec(value);\n    !(result != null) ?  true ? invariant(false, `Unable to parse React version ${value}`) : 0 : void 0;\n    const major = Number(result[1]);\n    const minor = Number(result[2]);\n    const patch = Number(result[3]);\n    return {\n        major,\n        minor,\n        patch,\n        raw: value\n    };\n};\nconst isSatisfied = (expected, actual)=>{\n    if (actual.major > expected.major) {\n        return true;\n    }\n    if (actual.major < expected.major) {\n        return false;\n    }\n    if (actual.minor > expected.minor) {\n        return true;\n    }\n    if (actual.minor < expected.minor) {\n        return false;\n    }\n    return actual.patch >= expected.patch;\n};\nvar checkReactVersion = (peerDepValue, actualValue)=>{\n    const peerDep = getVersion(peerDepValue);\n    const actual = getVersion(actualValue);\n    if (isSatisfied(peerDep, actual)) {\n        return;\n    }\n     true ? warning(`\n    React version: [${actual.raw}]\n    does not satisfy expected peer dependency version: [${peerDep.raw}]\n\n    This can result in run time bugs, and even fatal crashes\n  `) : 0;\n};\nconst suffix = `\n  We expect a html5 doctype: <!doctype html>\n  This is to ensure consistent browser layout and measurement\n\n  More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md\n`;\nvar checkDoctype = (doc)=>{\n    const doctype = doc.doctype;\n    if (!doctype) {\n         true ? warning(`\n      No <!doctype html> found.\n\n      ${suffix}\n    `) : 0;\n        return;\n    }\n    if (doctype.name.toLowerCase() !== \"html\") {\n         true ? warning(`\n      Unexpected <!doctype> found: (${doctype.name})\n\n      ${suffix}\n    `) : 0;\n    }\n    if (doctype.publicId !== \"\") {\n         true ? warning(`\n      Unexpected <!doctype> publicId found: (${doctype.publicId})\n      A html5 doctype does not have a publicId\n\n      ${suffix}\n    `) : 0;\n    }\n};\nfunction useDev(useHook) {\n    if (true) {\n        useHook();\n    }\n}\nfunction useDevSetupWarning(fn, inputs) {\n    useDev(()=>{\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            try {\n                fn();\n            } catch (e) {\n                error(`\n          A setup problem was encountered.\n\n          > ${e.message}\n        `);\n            }\n        }, inputs);\n    });\n}\nfunction useStartupValidation() {\n    useDevSetupWarning(()=>{\n        checkReactVersion(peerDependencies.react, (react__WEBPACK_IMPORTED_MODULE_0___default().version));\n        checkDoctype(document);\n    }, []);\n}\nfunction usePrevious(current) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = current;\n    });\n    return ref;\n}\nfunction create() {\n    let lock = null;\n    function isClaimed() {\n        return Boolean(lock);\n    }\n    function isActive(value) {\n        return value === lock;\n    }\n    function claim(abandon) {\n        !!lock ?  true ? invariant(false, \"Cannot claim lock as it is already claimed\") : 0 : void 0;\n        const newLock = {\n            abandon\n        };\n        lock = newLock;\n        return newLock;\n    }\n    function release() {\n        !lock ?  true ? invariant(false, \"Cannot release lock when there is no lock\") : 0 : void 0;\n        lock = null;\n    }\n    function tryAbandon() {\n        if (lock) {\n            lock.abandon();\n            release();\n        }\n    }\n    return {\n        isClaimed,\n        isActive,\n        claim,\n        release,\n        tryAbandon\n    };\n}\nfunction isDragging(state) {\n    if (state.phase === \"IDLE\" || state.phase === \"DROP_ANIMATING\") {\n        return false;\n    }\n    return state.isDragging;\n}\nconst tab = 9;\nconst enter = 13;\nconst escape = 27;\nconst space = 32;\nconst pageUp = 33;\nconst pageDown = 34;\nconst end = 35;\nconst home = 36;\nconst arrowLeft = 37;\nconst arrowUp = 38;\nconst arrowRight = 39;\nconst arrowDown = 40;\nconst preventedKeys = {\n    [enter]: true,\n    [tab]: true\n};\nvar preventStandardKeyEvents = (event)=>{\n    if (preventedKeys[event.keyCode]) {\n        event.preventDefault();\n    }\n};\nconst supportedEventName = (()=>{\n    const base = \"visibilitychange\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        `ms${base}`,\n        `webkit${base}`,\n        `moz${base}`,\n        `o${base}`\n    ];\n    const supported = candidates.find((eventName)=>`on${eventName}` in document);\n    return supported || base;\n})();\nconst primaryButton = 0;\nconst sloppyClickThreshold = 5;\nfunction isSloppyClickThresholdExceeded(original, current) {\n    return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\nconst idle$1 = {\n    type: \"IDLE\"\n};\nfunction getCaptureBindings({ cancel, completed, getPhase, setPhase }) {\n    return [\n        {\n            eventName: \"mousemove\",\n            fn: (event)=>{\n                const { button, clientX, clientY } = event;\n                if (button !== primaryButton) {\n                    return;\n                }\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                const phase = getPhase();\n                if (phase.type === \"DRAGGING\") {\n                    event.preventDefault();\n                    phase.actions.move(point);\n                    return;\n                }\n                !(phase.type === \"PENDING\") ?  true ? invariant(false, \"Cannot be IDLE\") : 0 : void 0;\n                const pending = phase.point;\n                if (!isSloppyClickThresholdExceeded(pending, point)) {\n                    return;\n                }\n                event.preventDefault();\n                const actions = phase.actions.fluidLift(point);\n                setPhase({\n                    type: \"DRAGGING\",\n                    actions\n                });\n            }\n        },\n        {\n            eventName: \"mouseup\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: (event)=>{\n                if (getPhase().type === \"DRAGGING\") {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type === \"PENDING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"scroll\",\n            options: {\n                passive: true,\n                capture: false\n            },\n            fn: ()=>{\n                if (getPhase().type === \"PENDING\") {\n                    cancel();\n                }\n            }\n        },\n        {\n            eventName: \"webkitmouseforcedown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false, \"Unexpected phase\") : 0 : void 0;\n                if (phase.actions.shouldRespectForcePress()) {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useMouseSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$1);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const startCaptureBinding = useMemo(()=>({\n            eventName: \"mousedown\",\n            fn: function onMouseDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.button !== primaryButton) {\n                    return;\n                }\n                if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                event.preventDefault();\n                const point = {\n                    x: event.clientX,\n                    y: event.clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const preventForcePressBinding = useMemo(()=>({\n            eventName: \"webkitmouseforcewillbegin\",\n            fn: (event)=>{\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const id = api.findClosestDraggableId(event);\n                if (!id) {\n                    return;\n                }\n                const options = api.findOptionsForDraggable(id);\n                if (!options) {\n                    return;\n                }\n                if (options.shouldRespectForcePress) {\n                    return;\n                }\n                if (!api.canGetLock(id)) {\n                    return;\n                }\n                event.preventDefault();\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = useCallback(function listenForCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            preventForcePressBinding,\n            startCaptureBinding\n        ], options);\n    }, [\n        preventForcePressBinding,\n        startCaptureBinding\n    ]);\n    const stop = useCallback(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        phaseRef.current = idle$1;\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture\n    ]);\n    const cancel = useCallback(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = useCallback(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const bindings = getCaptureBindings({\n            cancel,\n            completed: stop,\n            getPhase: ()=>phaseRef.current,\n            setPhase: (phase)=>{\n                phaseRef.current = phase;\n            }\n        });\n        unbindEventsRef.current = bindEvents(window, bindings, options);\n    }, [\n        cancel,\n        stop\n    ]);\n    const startPendingDrag = useCallback(function startPendingDrag(actions, point) {\n        !(phaseRef.current.type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        phaseRef.current = {\n            type: \"PENDING\",\n            point,\n            actions\n        };\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nfunction noop$1() {}\nconst scrollJumpKeys = {\n    [pageDown]: true,\n    [pageUp]: true,\n    [home]: true,\n    [end]: true\n};\nfunction getDraggingBindings(actions, stop) {\n    function cancel() {\n        stop();\n        actions.cancel();\n    }\n    function drop() {\n        stop();\n        actions.drop();\n    }\n    return [\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === space) {\n                    event.preventDefault();\n                    drop();\n                    return;\n                }\n                if (event.keyCode === arrowDown) {\n                    event.preventDefault();\n                    actions.moveDown();\n                    return;\n                }\n                if (event.keyCode === arrowUp) {\n                    event.preventDefault();\n                    actions.moveUp();\n                    return;\n                }\n                if (event.keyCode === arrowRight) {\n                    event.preventDefault();\n                    actions.moveRight();\n                    return;\n                }\n                if (event.keyCode === arrowLeft) {\n                    event.preventDefault();\n                    actions.moveLeft();\n                    return;\n                }\n                if (scrollJumpKeys[event.keyCode]) {\n                    event.preventDefault();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: cancel\n        },\n        {\n            eventName: \"mouseup\",\n            fn: cancel\n        },\n        {\n            eventName: \"click\",\n            fn: cancel\n        },\n        {\n            eventName: \"touchstart\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"wheel\",\n            fn: cancel,\n            options: {\n                passive: true\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useKeyboardSensor(api) {\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$1);\n    const startCaptureBinding = useMemo(()=>({\n            eventName: \"keydown\",\n            fn: function onKeyDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.keyCode !== space) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const preDrag = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!preDrag) {\n                    return;\n                }\n                event.preventDefault();\n                let isCapturing = true;\n                const actions = preDrag.snapLift();\n                unbindEventsRef.current();\n                function stop() {\n                    !isCapturing ?  true ? invariant(false, \"Cannot stop capturing a keyboard drag when not capturing\") : 0 : void 0;\n                    isCapturing = false;\n                    unbindEventsRef.current();\n                    listenForCapture();\n                }\n                unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n                    capture: true,\n                    passive: false\n                });\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = useCallback(function tryStartCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nconst idle = {\n    type: \"IDLE\"\n};\nconst timeForLongPress = 120;\nconst forcePressThreshold = 0.15;\nfunction getWindowBindings({ cancel, getPhase }) {\n    return [\n        {\n            eventName: \"orientationchange\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"contextmenu\",\n            fn: (event)=>{\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction getHandleBindings({ cancel, completed, getPhase }) {\n    return [\n        {\n            eventName: \"touchmove\",\n            options: {\n                capture: false\n            },\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                phase.hasMoved = true;\n                const { clientX, clientY } = event.touches[0];\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                event.preventDefault();\n                phase.actions.move(point);\n            }\n        },\n        {\n            eventName: \"touchend\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"touchcancel\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                cancel();\n            }\n        },\n        {\n            eventName: \"touchforcechange\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant() : 0 : void 0;\n                const touch = event.touches[0];\n                if (!touch) {\n                    return;\n                }\n                const isForcePress = touch.force >= forcePressThreshold;\n                if (!isForcePress) {\n                    return;\n                }\n                const shouldRespect = phase.actions.shouldRespectForcePress();\n                if (phase.type === \"PENDING\") {\n                    if (shouldRespect) {\n                        cancel();\n                    }\n                    return;\n                }\n                if (shouldRespect) {\n                    if (phase.hasMoved) {\n                        event.preventDefault();\n                        return;\n                    }\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useTouchSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const getPhase = useCallback(function getPhase() {\n        return phaseRef.current;\n    }, []);\n    const setPhase = useCallback(function setPhase(phase) {\n        phaseRef.current = phase;\n    }, []);\n    const startCaptureBinding = useMemo(()=>({\n            eventName: \"touchstart\",\n            fn: function onTouchStart(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                const touch = event.touches[0];\n                const { clientX, clientY } = touch;\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = useCallback(function listenForCapture() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    const stop = useCallback(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        if (current.type === \"PENDING\") {\n            clearTimeout(current.longPressTimerId);\n        }\n        setPhase(idle);\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture,\n        setPhase\n    ]);\n    const cancel = useCallback(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = useCallback(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const args = {\n            cancel,\n            completed: stop,\n            getPhase\n        };\n        const unbindTarget = bindEvents(window, getHandleBindings(args), options);\n        const unbindWindow = bindEvents(window, getWindowBindings(args), options);\n        unbindEventsRef.current = function unbindAll() {\n            unbindTarget();\n            unbindWindow();\n        };\n    }, [\n        cancel,\n        getPhase,\n        stop\n    ]);\n    const startDragging = useCallback(function startDragging() {\n        const phase = getPhase();\n        !(phase.type === \"PENDING\") ?  true ? invariant(false, `Cannot start dragging from phase ${phase.type}`) : 0 : void 0;\n        const actions = phase.actions.fluidLift(phase.point);\n        setPhase({\n            type: \"DRAGGING\",\n            actions,\n            hasMoved: false\n        });\n    }, [\n        getPhase,\n        setPhase\n    ]);\n    const startPendingDrag = useCallback(function startPendingDrag(actions, point) {\n        !(getPhase().type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        const longPressTimerId = setTimeout(startDragging, timeForLongPress);\n        setPhase({\n            type: \"PENDING\",\n            point,\n            actions,\n            longPressTimerId\n        });\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents,\n        getPhase,\n        setPhase,\n        startDragging\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n            const phase = getPhase();\n            if (phase.type === \"PENDING\") {\n                clearTimeout(phase.longPressTimerId);\n                setPhase(idle);\n            }\n        };\n    }, [\n        getPhase,\n        listenForCapture,\n        setPhase\n    ]);\n    useIsomorphicLayoutEffect(function webkitHack() {\n        const unbind = bindEvents(window, [\n            {\n                eventName: \"touchmove\",\n                fn: ()=>{},\n                options: {\n                    capture: false,\n                    passive: false\n                }\n            }\n        ]);\n        return unbind;\n    }, []);\n}\nfunction useValidateSensorHooks(sensorHooks) {\n    useDev(()=>{\n        const previousRef = usePrevious(sensorHooks);\n        useDevSetupWarning(()=>{\n            !(previousRef.current.length === sensorHooks.length) ?  true ? invariant(false, \"Cannot change the amount of sensor hooks after mounting\") : 0 : void 0;\n        });\n    });\n}\nconst interactiveTagNames = [\n    \"input\",\n    \"button\",\n    \"textarea\",\n    \"select\",\n    \"option\",\n    \"optgroup\",\n    \"video\",\n    \"audio\"\n];\nfunction isAnInteractiveElement(parent, current) {\n    if (current == null) {\n        return false;\n    }\n    const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());\n    if (hasAnInteractiveTag) {\n        return true;\n    }\n    const attribute = current.getAttribute(\"contenteditable\");\n    if (attribute === \"true\" || attribute === \"\") {\n        return true;\n    }\n    if (current === parent) {\n        return false;\n    }\n    return isAnInteractiveElement(parent, current.parentElement);\n}\nfunction isEventInInteractiveElement(draggable, event) {\n    const target = event.target;\n    if (!isHtmlElement(target)) {\n        return false;\n    }\n    return isAnInteractiveElement(draggable, target);\n}\nvar getBorderBoxCenterPosition = (el)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(el.getBoundingClientRect()).center;\nfunction isElement(el) {\n    return el instanceof getWindowFromEl(el).Element;\n}\nconst supportedMatchesName = (()=>{\n    const base = \"matches\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        \"msMatchesSelector\",\n        \"webkitMatchesSelector\"\n    ];\n    const value = candidates.find((name)=>name in Element.prototype);\n    return value || base;\n})();\nfunction closestPonyfill(el, selector) {\n    if (el == null) {\n        return null;\n    }\n    if (el[supportedMatchesName](selector)) {\n        return el;\n    }\n    return closestPonyfill(el.parentElement, selector);\n}\nfunction closest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    }\n    return closestPonyfill(el, selector);\n}\nfunction getSelector(contextId) {\n    return `[${dragHandle.contextId}=\"${contextId}\"]`;\n}\nfunction findClosestDragHandleFromEvent(contextId, event) {\n    const target = event.target;\n    if (!isElement(target)) {\n         true ? warning(\"event.target must be a Element\") : 0;\n        return null;\n    }\n    const selector = getSelector(contextId);\n    const handle = closest(target, selector);\n    if (!handle) {\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle must be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n    const handle = findClosestDragHandleFromEvent(contextId, event);\n    if (!handle) {\n        return null;\n    }\n    return handle.getAttribute(dragHandle.draggableId);\n}\nfunction findDraggable(contextId, draggableId) {\n    const selector = `[${draggable.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    const draggable$1 = possible.find((el)=>{\n        return el.getAttribute(draggable.id) === draggableId;\n    });\n    if (!draggable$1) {\n        return null;\n    }\n    if (!isHtmlElement(draggable$1)) {\n         true ? warning(\"Draggable element is not a HTMLElement\") : 0;\n        return null;\n    }\n    return draggable$1;\n}\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction isActive({ expected, phase, isLockActive, shouldWarn }) {\n    if (!isLockActive()) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The sensor no longer has an action lock.\n\n        Tips:\n\n        - Throw away your action handlers when forceStop() is called\n        - Check actions.isActive() if you really need to\n      `) : 0;\n        }\n        return false;\n    }\n    if (expected !== phase) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The actions you used belong to an outdated phase\n\n        Current phase: ${expected}\n        You called an action from outdated phase: ${phase}\n\n        Tips:\n\n        - Do not use preDragActions actions after calling preDragActions.lift()\n      `) : 0;\n        }\n        return false;\n    }\n    return true;\n}\nfunction canStart({ lockAPI, store, registry, draggableId }) {\n    if (lockAPI.isClaimed()) {\n        return false;\n    }\n    const entry = registry.draggable.findById(draggableId);\n    if (!entry) {\n         true ? warning(`Unable to find draggable with id: ${draggableId}`) : 0;\n        return false;\n    }\n    if (!entry.options.isEnabled) {\n        return false;\n    }\n    if (!canStartDrag(store.getState(), draggableId)) {\n        return false;\n    }\n    return true;\n}\nfunction tryStart({ lockAPI, contextId, store, registry, draggableId, forceSensorStop, sourceEvent }) {\n    const shouldStart = canStart({\n        lockAPI,\n        store,\n        registry,\n        draggableId\n    });\n    if (!shouldStart) {\n        return null;\n    }\n    const entry = registry.draggable.getById(draggableId);\n    const el = findDraggable(contextId, entry.descriptor.id);\n    if (!el) {\n         true ? warning(`Unable to find draggable element with id: ${draggableId}`) : 0;\n        return null;\n    }\n    if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n        return null;\n    }\n    const lock = lockAPI.claim(forceSensorStop || noop$2);\n    let phase = \"PRE_DRAG\";\n    function getShouldRespectForcePress() {\n        return entry.options.shouldRespectForcePress;\n    }\n    function isLockActive() {\n        return lockAPI.isActive(lock);\n    }\n    function tryDispatch(expected, getAction) {\n        if (isActive({\n            expected,\n            phase,\n            isLockActive,\n            shouldWarn: true\n        })) {\n            store.dispatch(getAction());\n        }\n    }\n    const tryDispatchWhenDragging = tryDispatch.bind(null, \"DRAGGING\");\n    function lift(args) {\n        function completed() {\n            lockAPI.release();\n            phase = \"COMPLETED\";\n        }\n        if (phase !== \"PRE_DRAG\") {\n            completed();\n             true ? invariant(false, `Cannot lift in phase ${phase}`) : 0;\n        }\n        store.dispatch(lift$1(args.liftActionArgs));\n        phase = \"DRAGGING\";\n        function finish(reason, options = {\n            shouldBlockNextClick: false\n        }) {\n            args.cleanup();\n            if (options.shouldBlockNextClick) {\n                const unbind = bindEvents(window, [\n                    {\n                        eventName: \"click\",\n                        fn: preventDefault,\n                        options: {\n                            once: true,\n                            passive: false,\n                            capture: true\n                        }\n                    }\n                ]);\n                setTimeout(unbind);\n            }\n            completed();\n            store.dispatch(drop({\n                reason\n            }));\n        }\n        return {\n            isActive: ()=>isActive({\n                    expected: \"DRAGGING\",\n                    phase,\n                    isLockActive,\n                    shouldWarn: false\n                }),\n            shouldRespectForcePress: getShouldRespectForcePress,\n            drop: (options)=>finish(\"DROP\", options),\n            cancel: (options)=>finish(\"CANCEL\", options),\n            ...args.actions\n        };\n    }\n    function fluidLift(clientSelection) {\n        const move$1 = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((client)=>{\n            tryDispatchWhenDragging(()=>move({\n                    client\n                }));\n        });\n        const api = lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection,\n                movementMode: \"FLUID\"\n            },\n            cleanup: ()=>move$1.cancel(),\n            actions: {\n                move: move$1\n            }\n        });\n        return {\n            ...api,\n            move: move$1\n        };\n    }\n    function snapLift() {\n        const actions = {\n            moveUp: ()=>tryDispatchWhenDragging(moveUp),\n            moveRight: ()=>tryDispatchWhenDragging(moveRight),\n            moveDown: ()=>tryDispatchWhenDragging(moveDown),\n            moveLeft: ()=>tryDispatchWhenDragging(moveLeft)\n        };\n        return lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection: getBorderBoxCenterPosition(el),\n                movementMode: \"SNAP\"\n            },\n            cleanup: noop$2,\n            actions\n        });\n    }\n    function abortPreDrag() {\n        const shouldRelease = isActive({\n            expected: \"PRE_DRAG\",\n            phase,\n            isLockActive,\n            shouldWarn: true\n        });\n        if (shouldRelease) {\n            lockAPI.release();\n        }\n    }\n    const preDrag = {\n        isActive: ()=>isActive({\n                expected: \"PRE_DRAG\",\n                phase,\n                isLockActive,\n                shouldWarn: false\n            }),\n        shouldRespectForcePress: getShouldRespectForcePress,\n        fluidLift,\n        snapLift,\n        abort: abortPreDrag\n    };\n    return preDrag;\n}\nconst defaultSensors = [\n    useMouseSensor,\n    useKeyboardSensor,\n    useTouchSensor\n];\nfunction useSensorMarshal({ contextId, store, registry, customSensors, enableDefaultSensors }) {\n    const useSensors = [\n        ...enableDefaultSensors ? defaultSensors : [],\n        ...customSensors || []\n    ];\n    const lockAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>create())[0];\n    const tryAbandonLock = useCallback(function tryAbandonLock(previous, current) {\n        if (isDragging(previous) && !isDragging(current)) {\n            lockAPI.tryAbandon();\n        }\n    }, [\n        lockAPI\n    ]);\n    useIsomorphicLayoutEffect(function listenToStore() {\n        let previous = store.getState();\n        const unsubscribe = store.subscribe(()=>{\n            const current = store.getState();\n            tryAbandonLock(previous, current);\n            previous = current;\n        });\n        return unsubscribe;\n    }, [\n        lockAPI,\n        store,\n        tryAbandonLock\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        return lockAPI.tryAbandon;\n    }, [\n        lockAPI.tryAbandon\n    ]);\n    const canGetLock = useCallback((draggableId)=>{\n        return canStart({\n            lockAPI,\n            registry,\n            store,\n            draggableId\n        });\n    }, [\n        lockAPI,\n        registry,\n        store\n    ]);\n    const tryGetLock = useCallback((draggableId, forceStop, options)=>tryStart({\n            lockAPI,\n            registry,\n            contextId,\n            store,\n            draggableId,\n            forceSensorStop: forceStop || null,\n            sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n        }), [\n        contextId,\n        lockAPI,\n        registry,\n        store\n    ]);\n    const findClosestDraggableId = useCallback((event)=>tryGetClosestDraggableIdFromEvent(contextId, event), [\n        contextId\n    ]);\n    const findOptionsForDraggable = useCallback((id)=>{\n        const entry = registry.draggable.findById(id);\n        return entry ? entry.options : null;\n    }, [\n        registry.draggable\n    ]);\n    const tryReleaseLock = useCallback(function tryReleaseLock() {\n        if (!lockAPI.isClaimed()) {\n            return;\n        }\n        lockAPI.tryAbandon();\n        if (store.getState().phase !== \"IDLE\") {\n            store.dispatch(flush());\n        }\n    }, [\n        lockAPI,\n        store\n    ]);\n    const isLockClaimed = useCallback(()=>lockAPI.isClaimed(), [\n        lockAPI\n    ]);\n    const api = useMemo(()=>({\n            canGetLock,\n            tryGetLock,\n            findClosestDraggableId,\n            findOptionsForDraggable,\n            tryReleaseLock,\n            isLockClaimed\n        }), [\n        canGetLock,\n        tryGetLock,\n        findClosestDraggableId,\n        findOptionsForDraggable,\n        tryReleaseLock,\n        isLockClaimed\n    ]);\n    useValidateSensorHooks(useSensors);\n    for(let i = 0; i < useSensors.length; i++){\n        useSensors[i](api);\n    }\n}\nconst createResponders = (props)=>({\n        onBeforeCapture: (t)=>{\n            const onBeforeCapureCallback = ()=>{\n                if (props.onBeforeCapture) {\n                    props.onBeforeCapture(t);\n                }\n            };\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(onBeforeCapureCallback);\n        },\n        onBeforeDragStart: props.onBeforeDragStart,\n        onDragStart: props.onDragStart,\n        onDragEnd: props.onDragEnd,\n        onDragUpdate: props.onDragUpdate\n    });\nconst createAutoScrollerOptions = (props)=>({\n        ...defaultAutoScrollerOptions,\n        ...props.autoScrollerOptions,\n        durationDampening: {\n            ...defaultAutoScrollerOptions.durationDampening,\n            ...props.autoScrollerOptions\n        }\n    });\nfunction getStore(lazyRef) {\n    !lazyRef.current ?  true ? invariant(false, \"Could not find store from lazy ref\") : 0 : void 0;\n    return lazyRef.current;\n}\nfunction App(props) {\n    const { contextId, setCallbacks, sensors, nonce, dragHandleUsageInstructions } = props;\n    const lazyStoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    useStartupValidation();\n    const lastPropsRef = usePrevious(props);\n    const getResponders = useCallback(()=>{\n        return createResponders(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const getAutoScrollerOptions = useCallback(()=>{\n        return createAutoScrollerOptions(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const announce = useAnnouncer(contextId);\n    const dragHandleUsageInstructionsId = useHiddenTextElement({\n        contextId,\n        text: dragHandleUsageInstructions\n    });\n    const styleMarshal = useStyleMarshal(contextId, nonce);\n    const lazyDispatch = useCallback((action)=>{\n        getStore(lazyStoreRef).dispatch(action);\n    }, []);\n    const marshalCallbacks = useMemo(()=>(0,redux__WEBPACK_IMPORTED_MODULE_5__.bindActionCreators)({\n            publishWhileDragging,\n            updateDroppableScroll,\n            updateDroppableIsEnabled,\n            updateDroppableIsCombineEnabled,\n            collectionStarting\n        }, lazyDispatch), [\n        lazyDispatch\n    ]);\n    const registry = useRegistry();\n    const dimensionMarshal = useMemo(()=>{\n        return createDimensionMarshal(registry, marshalCallbacks);\n    }, [\n        registry,\n        marshalCallbacks\n    ]);\n    const autoScroller = useMemo(()=>createAutoScroller({\n            scrollWindow,\n            scrollDroppable: dimensionMarshal.scrollDroppable,\n            getAutoScrollerOptions,\n            ...(0,redux__WEBPACK_IMPORTED_MODULE_5__.bindActionCreators)({\n                move\n            }, lazyDispatch)\n        }), [\n        dimensionMarshal.scrollDroppable,\n        lazyDispatch,\n        getAutoScrollerOptions\n    ]);\n    const focusMarshal = useFocusMarshal(contextId);\n    const store = useMemo(()=>createStore({\n            announce,\n            autoScroller,\n            dimensionMarshal,\n            focusMarshal,\n            getResponders,\n            styleMarshal\n        }), [\n        announce,\n        autoScroller,\n        dimensionMarshal,\n        focusMarshal,\n        getResponders,\n        styleMarshal\n    ]);\n    if (true) {\n        if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n             true ? warning(\"unexpected store change\") : 0;\n        }\n    }\n    lazyStoreRef.current = store;\n    const tryResetStore = useCallback(()=>{\n        const current = getStore(lazyStoreRef);\n        const state = current.getState();\n        if (state.phase !== \"IDLE\") {\n            current.dispatch(flush());\n        }\n    }, []);\n    const isDragging = useCallback(()=>{\n        const state = getStore(lazyStoreRef).getState();\n        if (state.phase === \"DROP_ANIMATING\") {\n            return true;\n        }\n        if (state.phase === \"IDLE\") {\n            return false;\n        }\n        return state.isDragging;\n    }, []);\n    const appCallbacks = useMemo(()=>({\n            isDragging,\n            tryAbort: tryResetStore\n        }), [\n        isDragging,\n        tryResetStore\n    ]);\n    setCallbacks(appCallbacks);\n    const getCanLift = useCallback((id)=>canStartDrag(getStore(lazyStoreRef).getState(), id), []);\n    const getIsMovementAllowed = useCallback(()=>isMovementAllowed(getStore(lazyStoreRef).getState()), []);\n    const appContext = useMemo(()=>({\n            marshal: dimensionMarshal,\n            focus: focusMarshal,\n            contextId,\n            canLift: getCanLift,\n            isMovementAllowed: getIsMovementAllowed,\n            dragHandleUsageInstructionsId,\n            registry\n        }), [\n        contextId,\n        dimensionMarshal,\n        dragHandleUsageInstructionsId,\n        focusMarshal,\n        getCanLift,\n        getIsMovementAllowed,\n        registry\n    ]);\n    useSensorMarshal({\n        contextId,\n        store,\n        registry,\n        customSensors: sensors || null,\n        enableDefaultSensors: props.enableDefaultSensors !== false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return tryResetStore;\n    }, [\n        tryResetStore\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n        value: appContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_redux__WEBPACK_IMPORTED_MODULE_6__.Provider, {\n        context: StoreContext,\n        store: store\n    }, props.children));\n}\nfunction useUniqueContextId() {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n}\nfunction DragDropContext(props) {\n    const contextId = useUniqueContextId();\n    const dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorBoundary, null, (setCallbacks)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, {\n            nonce: props.nonce,\n            contextId: contextId,\n            setCallbacks: setCallbacks,\n            dragHandleUsageInstructions: dragHandleUsageInstructions,\n            enableDefaultSensors: props.enableDefaultSensors,\n            sensors: props.sensors,\n            onBeforeCapture: props.onBeforeCapture,\n            onBeforeDragStart: props.onBeforeDragStart,\n            onDragStart: props.onDragStart,\n            onDragUpdate: props.onDragUpdate,\n            onDragEnd: props.onDragEnd,\n            autoScrollerOptions: props.autoScrollerOptions\n        }, props.children));\n}\nconst zIndexOptions = {\n    dragging: 5000,\n    dropAnimating: 4500\n};\nconst getDraggingTransition = (shouldAnimateDragMovement, dropping)=>{\n    if (dropping) {\n        return transitions.drop(dropping.duration);\n    }\n    if (shouldAnimateDragMovement) {\n        return transitions.snap;\n    }\n    return transitions.fluid;\n};\nconst getDraggingOpacity = (isCombining, isDropAnimating)=>{\n    if (!isCombining) {\n        return undefined;\n    }\n    return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\nconst getShouldDraggingAnimate = (dragging)=>{\n    if (dragging.forceShouldAnimate != null) {\n        return dragging.forceShouldAnimate;\n    }\n    return dragging.mode === \"SNAP\";\n};\nfunction getDraggingStyle(dragging) {\n    const dimension = dragging.dimension;\n    const box = dimension.client;\n    const { offset, combineWith, dropping } = dragging;\n    const isCombining = Boolean(combineWith);\n    const shouldAnimate = getShouldDraggingAnimate(dragging);\n    const isDropAnimating = Boolean(dropping);\n    const transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n    const style = {\n        position: \"fixed\",\n        top: box.marginBox.top,\n        left: box.marginBox.left,\n        boxSizing: \"border-box\",\n        width: box.borderBox.width,\n        height: box.borderBox.height,\n        transition: getDraggingTransition(shouldAnimate, dropping),\n        transform,\n        opacity: getDraggingOpacity(isCombining, isDropAnimating),\n        zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n        pointerEvents: \"none\"\n    };\n    return style;\n}\nfunction getSecondaryStyle(secondary) {\n    return {\n        transform: transforms.moveTo(secondary.offset),\n        transition: secondary.shouldAnimateDisplacement ? undefined : \"none\"\n    };\n}\nfunction getStyle$1(mapped) {\n    return mapped.type === \"DRAGGING\" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\nfunction getDimension$1(descriptor, el, windowScroll = origin) {\n    const computedStyles = window.getComputedStyle(el);\n    const borderBox = el.getBoundingClientRect();\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.calculateBox)(borderBox, computedStyles);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, windowScroll);\n    const placeholder = {\n        client,\n        tagName: el.tagName.toLowerCase(),\n        display: computedStyles.display\n    };\n    const displaceBy = {\n        x: client.marginBox.width,\n        y: client.marginBox.height\n    };\n    const dimension = {\n        descriptor,\n        placeholder,\n        displaceBy,\n        client,\n        page\n    };\n    return dimension;\n}\nfunction useDraggablePublisher(args) {\n    const uniqueId = useUniqueId(\"draggable\");\n    const { descriptor, registry, getDraggableRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled } = args;\n    const options = useMemo(()=>({\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        }), [\n        canDragInteractiveElements,\n        isEnabled,\n        shouldRespectForcePress\n    ]);\n    const getDimension = useCallback((windowScroll)=>{\n        const el = getDraggableRef();\n        !el ?  true ? invariant(false, \"Cannot get dimension when no ref is set\") : 0 : void 0;\n        return getDimension$1(descriptor, el, windowScroll);\n    }, [\n        descriptor,\n        getDraggableRef\n    ]);\n    const entry = useMemo(()=>({\n            uniqueId,\n            descriptor,\n            options,\n            getDimension\n        }), [\n        descriptor,\n        getDimension,\n        options,\n        uniqueId\n    ]);\n    const publishedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(entry);\n    const isFirstPublishRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    useIsomorphicLayoutEffect(()=>{\n        registry.draggable.register(publishedRef.current);\n        return ()=>registry.draggable.unregister(publishedRef.current);\n    }, [\n        registry.draggable\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (isFirstPublishRef.current) {\n            isFirstPublishRef.current = false;\n            return;\n        }\n        const last = publishedRef.current;\n        publishedRef.current = entry;\n        registry.draggable.update(entry, last);\n    }, [\n        entry,\n        registry.draggable\n    ]);\n}\nvar DroppableContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nfunction checkIsValidInnerRef(el) {\n    !(el && isHtmlElement(el)) ?  true ? invariant(false, `\n    provided.innerRef has not been provided with a HTMLElement.\n\n    You can find a guide on using the innerRef callback functions at:\n    https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md\n  `) : 0 : void 0;\n}\nfunction useValidation$1(props, contextId, getRef) {\n    useDevSetupWarning(()=>{\n        function prefix(id) {\n            return `Draggable[id: ${id}]: `;\n        }\n        const id = props.draggableId;\n        !id ?  true ? invariant(false, \"Draggable requires a draggableId\") : 0 : void 0;\n        !(typeof id === \"string\") ?  true ? invariant(false, `Draggable requires a [string] draggableId.\n      Provided: [type: ${typeof id}] (value: ${id})`) : 0 : void 0;\n        !Number.isInteger(props.index) ?  true ? invariant(false, `${prefix(id)} requires an integer index prop`) : 0 : void 0;\n        if (props.mapped.type === \"DRAGGING\") {\n            return;\n        }\n        checkIsValidInnerRef(getRef());\n        if (props.isEnabled) {\n            !findDragHandle(contextId, id) ?  true ? invariant(false, `${prefix(id)} Unable to find drag handle`) : 0 : void 0;\n        }\n    });\n}\nfunction useClonePropValidation(isClone) {\n    useDev(()=>{\n        const initialRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isClone);\n        useDevSetupWarning(()=>{\n            !(isClone === initialRef.current) ?  true ? invariant(false, \"Draggable isClone prop value changed during component life\") : 0 : void 0;\n        }, [\n            isClone\n        ]);\n    });\n}\nfunction useRequiredContext(Context) {\n    const result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    !result ?  true ? invariant(false, \"Could not find required context\") : 0 : void 0;\n    return result;\n}\nfunction preventHtml5Dnd(event) {\n    event.preventDefault();\n}\nconst Draggable = (props)=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setRef = useCallback((el = null)=>{\n        ref.current = el;\n    }, []);\n    const getRef = useCallback(()=>ref.current, []);\n    const { contextId, dragHandleUsageInstructionsId, registry } = useRequiredContext(AppContext);\n    const { type, droppableId } = useRequiredContext(DroppableContext);\n    const descriptor = useMemo(()=>({\n            id: props.draggableId,\n            index: props.index,\n            type,\n            droppableId\n        }), [\n        props.draggableId,\n        props.index,\n        type,\n        droppableId\n    ]);\n    const { children, draggableId, isEnabled, shouldRespectForcePress, canDragInteractiveElements, isClone, mapped, dropAnimationFinished: dropAnimationFinishedAction } = props;\n    useValidation$1(props, contextId, getRef);\n    useClonePropValidation(isClone);\n    if (!isClone) {\n        const forPublisher = useMemo(()=>({\n                descriptor,\n                registry,\n                getDraggableRef: getRef,\n                canDragInteractiveElements,\n                shouldRespectForcePress,\n                isEnabled\n            }), [\n            descriptor,\n            registry,\n            getRef,\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        ]);\n        useDraggablePublisher(forPublisher);\n    }\n    const dragHandleProps = useMemo(()=>isEnabled ? {\n            tabIndex: 0,\n            role: \"button\",\n            \"aria-describedby\": dragHandleUsageInstructionsId,\n            \"data-rfd-drag-handle-draggable-id\": draggableId,\n            \"data-rfd-drag-handle-context-id\": contextId,\n            draggable: false,\n            onDragStart: preventHtml5Dnd\n        } : null, [\n        contextId,\n        dragHandleUsageInstructionsId,\n        draggableId,\n        isEnabled\n    ]);\n    const onMoveEnd = useCallback((event)=>{\n        if (mapped.type !== \"DRAGGING\") {\n            return;\n        }\n        if (!mapped.dropping) {\n            return;\n        }\n        if (event.propertyName !== \"transform\") {\n            return;\n        }\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(dropAnimationFinishedAction);\n    }, [\n        dropAnimationFinishedAction,\n        mapped\n    ]);\n    const provided = useMemo(()=>{\n        const style = getStyle$1(mapped);\n        const onTransitionEnd = mapped.type === \"DRAGGING\" && mapped.dropping ? onMoveEnd : undefined;\n        const result = {\n            innerRef: setRef,\n            draggableProps: {\n                \"data-rfd-draggable-context-id\": contextId,\n                \"data-rfd-draggable-id\": draggableId,\n                style,\n                onTransitionEnd\n            },\n            dragHandleProps\n        };\n        return result;\n    }, [\n        contextId,\n        dragHandleProps,\n        draggableId,\n        mapped,\n        onMoveEnd,\n        setRef\n    ]);\n    const rubric = useMemo(()=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }), [\n        descriptor.droppableId,\n        descriptor.id,\n        descriptor.index,\n        descriptor.type\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children(provided, mapped.snapshot, rubric));\n};\nvar isStrictEqual = (a, b)=>a === b;\nvar whatIsDraggedOverFromResult = (result)=>{\n    const { combine, destination } = result;\n    if (destination) {\n        return destination.droppableId;\n    }\n    if (combine) {\n        return combine.droppableId;\n    }\n    return null;\n};\nconst getCombineWithFromResult = (result)=>{\n    return result.combine ? result.combine.draggableId : null;\n};\nconst getCombineWithFromImpact = (impact)=>{\n    return impact.at && impact.at.type === \"COMBINE\" ? impact.at.combine.draggableId : null;\n};\nfunction getDraggableSelector() {\n    const memoizedOffset = memoizeOne((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = memoizeOne((mode, isClone, draggingOver = null, combineWith = null, dropping = null)=>({\n            isDragging: true,\n            isClone,\n            isDropAnimating: Boolean(dropping),\n            dropAnimation: dropping,\n            mode,\n            draggingOver,\n            combineWith,\n            combineTargetFor: null\n        }));\n    const getMemoizedProps = memoizeOne((offset, mode, dimension, isClone, draggingOver = null, combineWith = null, forceShouldAnimate = null)=>({\n            mapped: {\n                type: \"DRAGGING\",\n                dropping: null,\n                draggingOver,\n                combineWith,\n                mode,\n                offset,\n                dimension,\n                forceShouldAnimate,\n                snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n            }\n        }));\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id !== ownProps.draggableId) {\n                return null;\n            }\n            const offset = state.current.client.offset;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const draggingOver = whatIsDraggedOver(state.impact);\n            const combineWith = getCombineWithFromImpact(state.impact);\n            const forceShouldAnimate = state.forceShouldAnimate;\n            return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId !== ownProps.draggableId) {\n                return null;\n            }\n            const isClone = ownProps.isClone;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const result = completed.result;\n            const mode = result.mode;\n            const draggingOver = whatIsDraggedOverFromResult(result);\n            const combineWith = getCombineWithFromResult(result);\n            const duration = state.dropDuration;\n            const dropping = {\n                duration,\n                curve: curves.drop,\n                moveTo: state.newHomeClientOffset,\n                opacity: combineWith ? combine.opacity.drop : null,\n                scale: combineWith ? combine.scale.drop : null\n            };\n            return {\n                mapped: {\n                    type: \"DRAGGING\",\n                    offset: state.newHomeClientOffset,\n                    dimension,\n                    dropping,\n                    draggingOver,\n                    combineWith,\n                    mode,\n                    forceShouldAnimate: null,\n                    snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)\n                }\n            };\n        }\n        return null;\n    };\n    return selector;\n}\nfunction getSecondarySnapshot(combineTargetFor = null) {\n    return {\n        isDragging: false,\n        isDropAnimating: false,\n        isClone: false,\n        dropAnimation: null,\n        mode: null,\n        draggingOver: null,\n        combineTargetFor,\n        combineWith: null\n    };\n}\nconst atRest = {\n    mapped: {\n        type: \"SECONDARY\",\n        offset: origin,\n        combineTargetFor: null,\n        shouldAnimateDisplacement: true,\n        snapshot: getSecondarySnapshot(null)\n    }\n};\nfunction getSecondarySelector() {\n    const memoizedOffset = memoizeOne((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);\n    const getMemoizedProps = memoizeOne((offset, combineTargetFor = null, shouldAnimateDisplacement)=>({\n            mapped: {\n                type: \"SECONDARY\",\n                offset,\n                combineTargetFor,\n                shouldAnimateDisplacement,\n                snapshot: getMemoizedSnapshot(combineTargetFor)\n            }\n        }));\n    const getFallback = (combineTargetFor)=>{\n        return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n    };\n    const getProps = (ownId, draggingId, impact, afterCritical)=>{\n        const visualDisplacement = impact.displaced.visible[ownId];\n        const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n        const combine = tryGetCombine(impact);\n        const combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n        if (!visualDisplacement) {\n            if (!isAfterCriticalInVirtualList) {\n                return getFallback(combineTargetFor);\n            }\n            if (impact.displaced.invisible[ownId]) {\n                return null;\n            }\n            const change = negate(afterCritical.displacedBy.point);\n            const offset = memoizedOffset(change.x, change.y);\n            return getMemoizedProps(offset, combineTargetFor, true);\n        }\n        if (isAfterCriticalInVirtualList) {\n            return getFallback(combineTargetFor);\n        }\n        const displaceBy = impact.displacedBy.point;\n        const offset = memoizedOffset(displaceBy.x, displaceBy.y);\n        return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n    };\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n        }\n        return null;\n    };\n    return selector;\n}\nconst makeMapStateToProps$1 = ()=>{\n    const draggingSelector = getDraggableSelector();\n    const secondarySelector = getSecondarySelector();\n    const selector = (state, ownProps)=>draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n    return selector;\n};\nconst mapDispatchToProps$1 = {\n    dropAnimationFinished: dropAnimationFinished\n};\nconst ConnectedDraggable = (0,react_redux__WEBPACK_IMPORTED_MODULE_6__.connect)(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Draggable);\nfunction PrivateDraggable(props) {\n    const droppableContext = useRequiredContext(DroppableContext);\n    const isUsingCloneFor = droppableContext.isUsingCloneFor;\n    if (isUsingCloneFor === props.draggableId && !props.isClone) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ConnectedDraggable, props);\n}\nfunction PublicDraggable(props) {\n    const isEnabled = typeof props.isDragDisabled === \"boolean\" ? !props.isDragDisabled : true;\n    const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n    const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, props, {\n        isClone: false,\n        isEnabled: isEnabled,\n        canDragInteractiveElements: canDragInteractiveElements,\n        shouldRespectForcePress: shouldRespectForcePress\n    }));\n}\nconst isEqual = (base)=>(value)=>base === value;\nconst isScroll = isEqual(\"scroll\");\nconst isAuto = isEqual(\"auto\");\nconst isVisible = isEqual(\"visible\");\nconst isEither = (overflow, fn)=>fn(overflow.overflowX) || fn(overflow.overflowY);\nconst isBoth = (overflow, fn)=>fn(overflow.overflowX) && fn(overflow.overflowY);\nconst isElementScrollable = (el)=>{\n    const style = window.getComputedStyle(el);\n    const overflow = {\n        overflowX: style.overflowX,\n        overflowY: style.overflowY\n    };\n    return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\nconst isBodyScrollable = ()=>{\n    if (false) {}\n    const body = getBodyElement();\n    const html = document.documentElement;\n    !html ?  true ? invariant() : 0 : void 0;\n    if (!isElementScrollable(body)) {\n        return false;\n    }\n    const htmlStyle = window.getComputedStyle(html);\n    const htmlOverflow = {\n        overflowX: htmlStyle.overflowX,\n        overflowY: htmlStyle.overflowY\n    };\n    if (isBoth(htmlOverflow, isVisible)) {\n        return false;\n    }\n     true ? warning(`\n    We have detected that your <body> element might be a scroll container.\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\n\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\n    we will be treating the <body> as *not* a scroll container\n\n    More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md\n  `) : 0;\n    return false;\n};\nconst getClosestScrollable = (el)=>{\n    if (el == null) {\n        return null;\n    }\n    if (el === document.body) {\n        return isBodyScrollable() ? el : null;\n    }\n    if (el === document.documentElement) {\n        return null;\n    }\n    if (!isElementScrollable(el)) {\n        return getClosestScrollable(el.parentElement);\n    }\n    return el;\n};\nvar checkForNestedScrollContainers = (scrollable)=>{\n    if (!scrollable) {\n        return;\n    }\n    const anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n    if (!anotherScrollParent) {\n        return;\n    }\n     true ? warning(`\n    Droppable: unsupported nested scroll container detected.\n    A Droppable can only have one scroll parent (which can be itself)\n    Nested scroll containers are currently not supported.\n\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\n  `) : 0;\n};\nvar getScroll = (el)=>({\n        x: el.scrollLeft,\n        y: el.scrollTop\n    });\nconst getIsFixed = (el)=>{\n    if (!el) {\n        return false;\n    }\n    const style = window.getComputedStyle(el);\n    if (style.position === \"fixed\") {\n        return true;\n    }\n    return getIsFixed(el.parentElement);\n};\nvar getEnv = (start)=>{\n    const closestScrollable = getClosestScrollable(start);\n    const isFixedOnPage = getIsFixed(start);\n    return {\n        closestScrollable,\n        isFixedOnPage\n    };\n};\nvar getDroppableDimension = ({ descriptor, isEnabled, isCombineEnabled, isFixedOnPage, direction, client, page, closest })=>{\n    const frame = (()=>{\n        if (!closest) {\n            return null;\n        }\n        const { scrollSize, client: frameClient } = closest;\n        const maxScroll = getMaxScroll({\n            scrollHeight: scrollSize.scrollHeight,\n            scrollWidth: scrollSize.scrollWidth,\n            height: frameClient.paddingBox.height,\n            width: frameClient.paddingBox.width\n        });\n        return {\n            pageMarginBox: closest.page.marginBox,\n            frameClient,\n            scrollSize,\n            shouldClipSubject: closest.shouldClipSubject,\n            scroll: {\n                initial: closest.scroll,\n                current: closest.scroll,\n                max: maxScroll,\n                diff: {\n                    value: origin,\n                    displacement: origin\n                }\n            }\n        };\n    })();\n    const axis = direction === \"vertical\" ? vertical : horizontal;\n    const subject = getSubject({\n        page,\n        withPlaceholder: null,\n        axis,\n        frame\n    });\n    const dimension = {\n        descriptor,\n        isCombineEnabled,\n        isFixedOnPage,\n        axis,\n        isEnabled,\n        client,\n        page,\n        frame,\n        subject\n    };\n    return dimension;\n};\nconst getClient = (targetRef, closestScrollable)=>{\n    const base = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getBox)(targetRef);\n    if (!closestScrollable) {\n        return base;\n    }\n    if (targetRef !== closestScrollable) {\n        return base;\n    }\n    const top = base.paddingBox.top - closestScrollable.scrollTop;\n    const left = base.paddingBox.left - closestScrollable.scrollLeft;\n    const bottom = top + closestScrollable.scrollHeight;\n    const right = left + closestScrollable.scrollWidth;\n    const paddingBox = {\n        top,\n        right,\n        bottom,\n        left\n    };\n    const borderBox = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.expand)(paddingBox, base.border);\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.createBox)({\n        borderBox,\n        margin: base.margin,\n        border: base.border,\n        padding: base.padding\n    });\n    return client;\n};\nvar getDimension = ({ ref, descriptor, env, windowScroll, direction, isDropDisabled, isCombineEnabled, shouldClipSubject })=>{\n    const closestScrollable = env.closestScrollable;\n    const client = getClient(ref, closestScrollable);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, windowScroll);\n    const closest = (()=>{\n        if (!closestScrollable) {\n            return null;\n        }\n        const frameClient = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getBox)(closestScrollable);\n        const scrollSize = {\n            scrollHeight: closestScrollable.scrollHeight,\n            scrollWidth: closestScrollable.scrollWidth\n        };\n        return {\n            client: frameClient,\n            page: (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(frameClient, windowScroll),\n            scroll: getScroll(closestScrollable),\n            scrollSize,\n            shouldClipSubject\n        };\n    })();\n    const dimension = getDroppableDimension({\n        descriptor,\n        isEnabled: !isDropDisabled,\n        isCombineEnabled,\n        isFixedOnPage: env.isFixedOnPage,\n        direction,\n        client,\n        page,\n        closest\n    });\n    return dimension;\n};\nconst immediate = {\n    passive: false\n};\nconst delayed = {\n    passive: true\n};\nvar getListenerOptions = (options)=>options.shouldPublishImmediately ? immediate : delayed;\nconst getClosestScrollableFromDrag = (dragging)=>dragging && dragging.env.closestScrollable || null;\nfunction useDroppablePublisher(args) {\n    const whileDraggingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const appContext = useRequiredContext(AppContext);\n    const uniqueId = useUniqueId(\"droppable\");\n    const { registry, marshal } = appContext;\n    const previousRef = usePrevious(args);\n    const descriptor = useMemo(()=>({\n            id: args.droppableId,\n            type: args.type,\n            mode: args.mode\n        }), [\n        args.droppableId,\n        args.mode,\n        args.type\n    ]);\n    const publishedDescriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(descriptor);\n    const memoizedUpdateScroll = useMemo(()=>memoizeOne((x, y)=>{\n            !whileDraggingRef.current ?  true ? invariant(false, \"Can only update scroll when dragging\") : 0 : void 0;\n            const scroll = {\n                x,\n                y\n            };\n            marshal.updateDroppableScroll(descriptor.id, scroll);\n        }), [\n        descriptor.id,\n        marshal\n    ]);\n    const getClosestScroll = useCallback(()=>{\n        const dragging = whileDraggingRef.current;\n        if (!dragging || !dragging.env.closestScrollable) {\n            return origin;\n        }\n        return getScroll(dragging.env.closestScrollable);\n    }, []);\n    const updateScroll = useCallback(()=>{\n        const scroll = getClosestScroll();\n        memoizedUpdateScroll(scroll.x, scroll.y);\n    }, [\n        getClosestScroll,\n        memoizedUpdateScroll\n    ]);\n    const scheduleScrollUpdate = useMemo(()=>(0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(updateScroll), [\n        updateScroll\n    ]);\n    const onClosestScroll = useCallback(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Could not find scroll options while scrolling\") : 0 : void 0;\n        const options = dragging.scrollOptions;\n        if (options.shouldPublishImmediately) {\n            updateScroll();\n            return;\n        }\n        scheduleScrollUpdate();\n    }, [\n        scheduleScrollUpdate,\n        updateScroll\n    ]);\n    const getDimensionAndWatchScroll = useCallback((windowScroll, options)=>{\n        !!whileDraggingRef.current ?  true ? invariant(false, \"Cannot collect a droppable while a drag is occurring\") : 0 : void 0;\n        const previous = previousRef.current;\n        const ref = previous.getDroppableRef();\n        !ref ?  true ? invariant(false, \"Cannot collect without a droppable ref\") : 0 : void 0;\n        const env = getEnv(ref);\n        const dragging = {\n            ref,\n            descriptor,\n            env,\n            scrollOptions: options\n        };\n        whileDraggingRef.current = dragging;\n        const dimension = getDimension({\n            ref,\n            descriptor,\n            env,\n            windowScroll,\n            direction: previous.direction,\n            isDropDisabled: previous.isDropDisabled,\n            isCombineEnabled: previous.isCombineEnabled,\n            shouldClipSubject: !previous.ignoreContainerClipping\n        });\n        const scrollable = env.closestScrollable;\n        if (scrollable) {\n            scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n            scrollable.addEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n            if (true) {\n                checkForNestedScrollContainers(scrollable);\n            }\n        }\n        return dimension;\n    }, [\n        appContext.contextId,\n        descriptor,\n        onClosestScroll,\n        previousRef\n    ]);\n    const getScrollWhileDragging = useCallback(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Can only recollect Droppable client for Droppables that have a scroll container\") : 0 : void 0;\n        return getScroll(closest);\n    }, []);\n    const dragStopped = useCallback(()=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot stop drag when no active drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        whileDraggingRef.current = null;\n        if (!closest) {\n            return;\n        }\n        scheduleScrollUpdate.cancel();\n        closest.removeAttribute(scrollContainer.contextId);\n        closest.removeEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n    }, [\n        onClosestScroll,\n        scheduleScrollUpdate\n    ]);\n    const scroll = useCallback((change)=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot scroll when there is no drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !closest ?  true ? invariant(false, \"Cannot scroll a droppable with no closest scrollable\") : 0 : void 0;\n        closest.scrollTop += change.y;\n        closest.scrollLeft += change.x;\n    }, []);\n    const callbacks = useMemo(()=>{\n        return {\n            getDimensionAndWatchScroll,\n            getScrollWhileDragging,\n            dragStopped,\n            scroll\n        };\n    }, [\n        dragStopped,\n        getDimensionAndWatchScroll,\n        getScrollWhileDragging,\n        scroll\n    ]);\n    const entry = useMemo(()=>({\n            uniqueId,\n            descriptor,\n            callbacks\n        }), [\n        callbacks,\n        descriptor,\n        uniqueId\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        publishedDescriptorRef.current = entry.descriptor;\n        registry.droppable.register(entry);\n        return ()=>{\n            if (whileDraggingRef.current) {\n                 true ? warning(\"Unsupported: changing the droppableId or type of a Droppable during a drag\") : 0;\n                dragStopped();\n            }\n            registry.droppable.unregister(entry);\n        };\n    }, [\n        callbacks,\n        descriptor,\n        dragStopped,\n        entry,\n        marshal,\n        registry.droppable\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n    }, [\n        args.isDropDisabled,\n        marshal\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n    }, [\n        args.isCombineEnabled,\n        marshal\n    ]);\n}\nfunction noop() {}\nconst empty = {\n    width: 0,\n    height: 0,\n    margin: noSpacing\n};\nconst getSize = ({ isAnimatingOpenOnMount, placeholder, animate })=>{\n    if (isAnimatingOpenOnMount) {\n        return empty;\n    }\n    if (animate === \"close\") {\n        return empty;\n    }\n    return {\n        height: placeholder.client.borderBox.height,\n        width: placeholder.client.borderBox.width,\n        margin: placeholder.client.margin\n    };\n};\nconst getStyle = ({ isAnimatingOpenOnMount, placeholder, animate })=>{\n    const size = getSize({\n        isAnimatingOpenOnMount,\n        placeholder,\n        animate\n    });\n    return {\n        display: placeholder.display,\n        boxSizing: \"border-box\",\n        width: size.width,\n        height: size.height,\n        marginTop: size.margin.top,\n        marginRight: size.margin.right,\n        marginBottom: size.margin.bottom,\n        marginLeft: size.margin.left,\n        flexShrink: \"0\",\n        flexGrow: \"0\",\n        pointerEvents: \"none\",\n        transition: animate !== \"none\" ? transitions.placeholder : null\n    };\n};\nconst Placeholder = (props)=>{\n    const animateOpenTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const tryClearAnimateOpenTimer = useCallback(()=>{\n        if (!animateOpenTimerRef.current) {\n            return;\n        }\n        clearTimeout(animateOpenTimerRef.current);\n        animateOpenTimerRef.current = null;\n    }, []);\n    const { animate, onTransitionEnd, onClose, contextId } = props;\n    const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate === \"open\");\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isAnimatingOpenOnMount) {\n            return noop;\n        }\n        if (animate !== \"open\") {\n            tryClearAnimateOpenTimer();\n            setIsAnimatingOpenOnMount(false);\n            return noop;\n        }\n        if (animateOpenTimerRef.current) {\n            return noop;\n        }\n        animateOpenTimerRef.current = setTimeout(()=>{\n            animateOpenTimerRef.current = null;\n            setIsAnimatingOpenOnMount(false);\n        });\n        return tryClearAnimateOpenTimer;\n    }, [\n        animate,\n        isAnimatingOpenOnMount,\n        tryClearAnimateOpenTimer\n    ]);\n    const onSizeChangeEnd = useCallback((event)=>{\n        if (event.propertyName !== \"height\") {\n            return;\n        }\n        onTransitionEnd();\n        if (animate === \"close\") {\n            onClose();\n        }\n    }, [\n        animate,\n        onClose,\n        onTransitionEnd\n    ]);\n    const style = getStyle({\n        isAnimatingOpenOnMount,\n        animate: props.animate,\n        placeholder: props.placeholder\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(props.placeholder.tagName, {\n        style,\n        \"data-rfd-placeholder-context-id\": contextId,\n        onTransitionEnd: onSizeChangeEnd,\n        ref: props.innerRef\n    });\n};\nvar Placeholder$1 = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().memo(Placeholder);\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nfunction runChecks(args, checks) {\n    checks.forEach((check)=>check(args));\n}\nconst shared = [\n    function required({ props }) {\n        !props.droppableId ?  true ? invariant(false, \"A Droppable requires a droppableId prop\") : 0 : void 0;\n        !(typeof props.droppableId === \"string\") ?  true ? invariant(false, `A Droppable requires a [string] droppableId. Provided: [${typeof props.droppableId}]`) : 0 : void 0;\n    },\n    function boolean({ props }) {\n        !isBoolean(props.isDropDisabled) ?  true ? invariant(false, \"isDropDisabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.isCombineEnabled) ?  true ? invariant(false, \"isCombineEnabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.ignoreContainerClipping) ?  true ? invariant(false, \"ignoreContainerClipping must be a boolean\") : 0 : void 0;\n    },\n    function ref({ getDroppableRef }) {\n        checkIsValidInnerRef(getDroppableRef());\n    }\n];\nconst standard = [\n    function placeholder({ props, getPlaceholderRef }) {\n        if (!props.placeholder) {\n            return;\n        }\n        const ref = getPlaceholderRef();\n        if (ref) {\n            return;\n        }\n         true ? warning(`\n      Droppable setup issue [droppableId: \"${props.droppableId}\"]:\n      DroppableProvided > placeholder could not be found.\n\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\n      More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md\n    `) : 0;\n    }\n];\nconst virtual = [\n    function hasClone({ props }) {\n        !props.renderClone ?  true ? invariant(false, \"Must provide a clone render function (renderClone) for virtual lists\") : 0 : void 0;\n    },\n    function hasNoPlaceholder({ getPlaceholderRef }) {\n        !!getPlaceholderRef() ?  true ? invariant(false, \"Expected virtual list to not have a placeholder\") : 0 : void 0;\n    }\n];\nfunction useValidation(args) {\n    useDevSetupWarning(()=>{\n        runChecks(args, shared);\n        if (args.props.mode === \"standard\") {\n            runChecks(args, standard);\n        }\n        if (args.props.mode === \"virtual\") {\n            runChecks(args, virtual);\n        }\n    });\n}\nclass AnimateInOut extends (react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent) {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            isVisible: Boolean(this.props.on),\n            data: this.props.on,\n            animate: this.props.shouldAnimate && this.props.on ? \"open\" : \"none\"\n        };\n        this.onClose = ()=>{\n            if (this.state.animate !== \"close\") {\n                return;\n            }\n            this.setState({\n                isVisible: false\n            });\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (!props.shouldAnimate) {\n            return {\n                isVisible: Boolean(props.on),\n                data: props.on,\n                animate: \"none\"\n            };\n        }\n        if (props.on) {\n            return {\n                isVisible: true,\n                data: props.on,\n                animate: \"open\"\n            };\n        }\n        if (state.isVisible) {\n            return {\n                isVisible: true,\n                data: state.data,\n                animate: \"close\"\n            };\n        }\n        return {\n            isVisible: false,\n            animate: \"close\",\n            data: null\n        };\n    }\n    render() {\n        if (!this.state.isVisible) {\n            return null;\n        }\n        const provided = {\n            onClose: this.onClose,\n            data: this.state.data,\n            animate: this.state.animate\n        };\n        return this.props.children(provided);\n    }\n}\nconst Droppable = (props)=>{\n    const appContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AppContext);\n    !appContext ?  true ? invariant(false, \"Could not find app context\") : 0 : void 0;\n    const { contextId, isMovementAllowed } = appContext;\n    const droppableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { children, droppableId, type, mode, direction, ignoreContainerClipping, isDropDisabled, isCombineEnabled, snapshot, useClone, updateViewportMaxScroll, getContainerForClone } = props;\n    const getDroppableRef = useCallback(()=>droppableRef.current, []);\n    const setDroppableRef = useCallback((value = null)=>{\n        droppableRef.current = value;\n    }, []);\n    const getPlaceholderRef = useCallback(()=>placeholderRef.current, []);\n    const setPlaceholderRef = useCallback((value = null)=>{\n        placeholderRef.current = value;\n    }, []);\n    useValidation({\n        props,\n        getDroppableRef,\n        getPlaceholderRef\n    });\n    const onPlaceholderTransitionEnd = useCallback(()=>{\n        if (isMovementAllowed()) {\n            updateViewportMaxScroll({\n                maxScroll: getMaxWindowScroll()\n            });\n        }\n    }, [\n        isMovementAllowed,\n        updateViewportMaxScroll\n    ]);\n    useDroppablePublisher({\n        droppableId,\n        type,\n        mode,\n        direction,\n        isDropDisabled,\n        isCombineEnabled,\n        ignoreContainerClipping,\n        getDroppableRef\n    });\n    const placeholder = useMemo(()=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimateInOut, {\n            on: props.placeholder,\n            shouldAnimate: props.shouldAnimatePlaceholder\n        }, ({ onClose, data, animate })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Placeholder$1, {\n                placeholder: data,\n                onClose: onClose,\n                innerRef: setPlaceholderRef,\n                animate: animate,\n                contextId: contextId,\n                onTransitionEnd: onPlaceholderTransitionEnd\n            })), [\n        contextId,\n        onPlaceholderTransitionEnd,\n        props.placeholder,\n        props.shouldAnimatePlaceholder,\n        setPlaceholderRef\n    ]);\n    const provided = useMemo(()=>({\n            innerRef: setDroppableRef,\n            placeholder,\n            droppableProps: {\n                \"data-rfd-droppable-id\": droppableId,\n                \"data-rfd-droppable-context-id\": contextId\n            }\n        }), [\n        contextId,\n        droppableId,\n        placeholder,\n        setDroppableRef\n    ]);\n    const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n    const droppableContext = useMemo(()=>({\n            droppableId,\n            type,\n            isUsingCloneFor\n        }), [\n        droppableId,\n        isUsingCloneFor,\n        type\n    ]);\n    function getClone() {\n        if (!useClone) {\n            return null;\n        }\n        const { dragging, render } = useClone;\n        const node = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, {\n            draggableId: dragging.draggableId,\n            index: dragging.source.index,\n            isClone: true,\n            isEnabled: true,\n            shouldRespectForcePress: false,\n            canDragInteractiveElements: true\n        }, (draggableProvided, draggableSnapshot)=>render(draggableProvided, draggableSnapshot, dragging));\n        return /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_1___default().createPortal(node, getContainerForClone());\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DroppableContext.Provider, {\n        value: droppableContext\n    }, children(provided, snapshot), getClone());\n};\nfunction getBody() {\n    !document.body ?  true ? invariant(false, \"document.body is not ready\") : 0 : void 0;\n    return document.body;\n}\nconst defaultProps = {\n    mode: \"standard\",\n    type: \"DEFAULT\",\n    direction: \"vertical\",\n    isDropDisabled: false,\n    isCombineEnabled: false,\n    ignoreContainerClipping: false,\n    renderClone: null,\n    getContainerForClone: getBody\n};\nconst attachDefaultPropsToOwnProps = (ownProps)=>{\n    let mergedProps = {\n        ...ownProps\n    };\n    let defaultPropKey;\n    for(defaultPropKey in defaultProps){\n        if (ownProps[defaultPropKey] === undefined) {\n            mergedProps = {\n                ...mergedProps,\n                [defaultPropKey]: defaultProps[defaultPropKey]\n            };\n        }\n    }\n    return mergedProps;\n};\nconst isMatchingType = (type, critical)=>type === critical.droppable.type;\nconst getDraggable = (critical, dimensions)=>dimensions.draggables[critical.draggable.id];\nconst makeMapStateToProps = ()=>{\n    const idleWithAnimation = {\n        placeholder: null,\n        shouldAnimatePlaceholder: true,\n        snapshot: {\n            isDraggingOver: false,\n            draggingOverWith: null,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: false\n        },\n        useClone: null\n    };\n    const idleWithoutAnimation = {\n        ...idleWithAnimation,\n        shouldAnimatePlaceholder: false\n    };\n    const getDraggableRubric = memoizeOne((descriptor)=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }));\n    const getMapProps = memoizeOne((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone)=>{\n        const draggableId = dragging.descriptor.id;\n        const isHome = dragging.descriptor.droppableId === id;\n        if (isHome) {\n            const useClone = renderClone ? {\n                render: renderClone,\n                dragging: getDraggableRubric(dragging.descriptor)\n            } : null;\n            const snapshot = {\n                isDraggingOver: isDraggingOverForConsumer,\n                draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n                draggingFromThisWith: draggableId,\n                isUsingPlaceholder: true\n            };\n            return {\n                placeholder: dragging.placeholder,\n                shouldAnimatePlaceholder: false,\n                snapshot,\n                useClone\n            };\n        }\n        if (!isEnabled) {\n            return idleWithoutAnimation;\n        }\n        if (!isDraggingOverForImpact) {\n            return idleWithAnimation;\n        }\n        const snapshot = {\n            isDraggingOver: isDraggingOverForConsumer,\n            draggingOverWith: draggableId,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: true\n        };\n        return {\n            placeholder: dragging.placeholder,\n            shouldAnimatePlaceholder: true,\n            snapshot,\n            useClone: null\n        };\n    });\n    const selector = (state, ownProps)=>{\n        const ownPropsWithDefaultProps = attachDefaultPropsToOwnProps(ownProps);\n        const id = ownPropsWithDefaultProps.droppableId;\n        const type = ownPropsWithDefaultProps.type;\n        const isEnabled = !ownPropsWithDefaultProps.isDropDisabled;\n        const renderClone = ownPropsWithDefaultProps.renderClone;\n        if (isDragging(state)) {\n            const critical = state.critical;\n            if (!isMatchingType(type, critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(critical, state.dimensions);\n            const isDraggingOver = whatIsDraggedOver(state.impact) === id;\n            return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(completed.critical, state.dimensions);\n            return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);\n        }\n        if (state.phase === \"IDLE\" && state.completed && !state.shouldFlush) {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const wasOver = whatIsDraggedOver(completed.impact) === id;\n            const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === \"COMBINE\");\n            const isHome = completed.critical.droppable.id === id;\n            if (wasOver) {\n                return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n            }\n            if (isHome) {\n                return idleWithAnimation;\n            }\n            return idleWithoutAnimation;\n        }\n        return idleWithoutAnimation;\n    };\n    return selector;\n};\nconst mapDispatchToProps = {\n    updateViewportMaxScroll: updateViewportMaxScroll\n};\nconst ConnectedDroppable = (0,react_redux__WEBPACK_IMPORTED_MODULE_6__.connect)(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps)=>{\n    return {\n        ...attachDefaultPropsToOwnProps(ownProps),\n        ...stateProps,\n        ...dispatchProps\n    };\n}, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Droppable);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvZGlzdC9kbmQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RjtBQUN4QztBQUNtRDtBQUNuRDtBQUNxRDtBQUN0RTtBQUMyQjtBQUUxRCxNQUFNd0IsaUJBQWlCQyxrQkFBeUI7QUFDaEQsTUFBTUMsZ0JBQWdCO0FBQ3RCLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyxVQUFVQyxDQUFBQSxRQUFTQSxNQUFNQyxPQUFPLENBQUNKLGVBQWUsS0FBS0ksT0FBTyxDQUFDSCxxQkFBcUIsSUFBSUksSUFBSTtBQUNoRyxNQUFNQyxnQkFBZ0JDLENBQUFBLFVBQVdMLFFBQVEsQ0FBQzs7O0lBR3RDLEVBQUVBLFFBQVFLLFNBQVM7OztBQUd2QixDQUFDO0FBQ0QsTUFBTUMsc0JBQXNCRCxDQUFBQSxVQUFXO1FBQUNELGNBQWNDO1FBQVU7UUFBd0Q7UUFBb0I7S0FBa0I7QUFDOUosTUFBTUUsaUJBQWlCO0FBQ3ZCLFNBQVNDLElBQUlDLElBQUksRUFBRUosT0FBTztJQUN4QixJQUFJVCxnQkFBZ0I7UUFDbEI7SUFDRjtJQUNBLElBQUksS0FBdUQsRUFBRSxFQUU1RDtJQUNEZSxPQUFPLENBQUNGLEtBQUssSUFBSUgsb0JBQW9CRDtBQUN2QztBQUNBLE1BQU1PLFVBQVVKLElBQUlLLElBQUksQ0FBQyxNQUFNO0FBQy9CLE1BQU1DLFFBQVFOLElBQUlLLElBQUksQ0FBQyxNQUFNO0FBRTdCLFNBQVNFLFVBQVU7QUFFbkIsU0FBU0MsV0FBV0MsTUFBTSxFQUFFQyxXQUFXO0lBQ3JDLE9BQU87UUFDTCxHQUFHRCxNQUFNO1FBQ1QsR0FBR0MsV0FBVztJQUNoQjtBQUNGO0FBQ0EsU0FBU0MsV0FBV0MsRUFBRSxFQUFFQyxRQUFRLEVBQUVDLGFBQWE7SUFDN0MsTUFBTUMsYUFBYUYsU0FBU0csR0FBRyxDQUFDQyxDQUFBQTtRQUM5QixNQUFNQyxVQUFVVixXQUFXTSxlQUFlRyxRQUFR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MEIsTUFBTVUsS0FBSyxLQUFLLFVBQVVWLE1BQU1pRyxTQUFTLElBQUksQ0FBQ2pHLE1BQU1rRyxXQUFXLEVBQUU7WUFDbkUsTUFBTUQsWUFBWWpHLE1BQU1pRyxTQUFTO1lBQ2pDLElBQUksQ0FBQzZ2QixlQUFldHVDLE1BQU15ZSxVQUFVNUYsUUFBUSxHQUFHO2dCQUM3QyxPQUFPaTJCO1lBQ1Q7WUFDQSxNQUFNL3dCLFVBQVUxRixrQkFBa0JvRyxVQUFVOVMsTUFBTSxNQUFNekg7WUFDeEQsTUFBTW1yQyxlQUFlcnBDLFFBQVF5WSxVQUFVOVMsTUFBTSxDQUFDQyxFQUFFLElBQUk2UyxVQUFVOVMsTUFBTSxDQUFDQyxFQUFFLENBQUM1TCxJQUFJLEtBQUs7WUFDakYsTUFBTW12QyxTQUFTMXdCLFVBQVU1RixRQUFRLENBQUNsUCxTQUFTLENBQUN6RixFQUFFLEtBQUtBO1lBQ25ELElBQUk2WixTQUFTO2dCQUNYLE9BQU9zeEIsZUFBZVosb0JBQW9CSztZQUM1QztZQUNBLElBQUlLLFFBQVE7Z0JBQ1YsT0FBT1Y7WUFDVDtZQUNBLE9BQU9LO1FBQ1Q7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsT0FBTzljO0FBQ1Q7QUFDQSxNQUFNc2QscUJBQXFCO0lBQ3pCcnZCLHlCQUF5QkE7QUFDM0I7QUFDQSxNQUFNc3ZCLHFCQUFxQjl3QyxvREFBT0EsQ0FBQyt2QyxxQkFBcUJjLG9CQUFvQixDQUFDRSxZQUFZQyxlQUFlNUk7SUFDdEcsT0FBTztRQUNMLEdBQUdzSCw2QkFBNkJ0SCxTQUFTO1FBQ3pDLEdBQUcySSxVQUFVO1FBQ2IsR0FBR0MsYUFBYTtJQUNsQjtBQUNGLEdBQUc7SUFDRGhlLFNBQVMrRTtJQUNUcVIsb0JBQW9CM0I7QUFDdEIsR0FBR2dIO0FBRTBJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkaXN1aXRlLXByby8uL25vZGVfbW9kdWxlcy9AaGVsbG8tcGFuZ2VhL2RuZC9kaXN0L2RuZC5lc20uanM/Yzk5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00sIHsgZmx1c2hTeW5jIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IGNyZWF0ZVN0b3JlIGFzIGNyZWF0ZVN0b3JlJDEsIGNvbXBvc2UsIGFwcGx5TWlkZGxld2FyZSwgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgUHJvdmlkZXIsIGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBnZXRSZWN0LCBleHBhbmQsIG9mZnNldCwgd2l0aFNjcm9sbCwgY2FsY3VsYXRlQm94LCBnZXRCb3gsIGNyZWF0ZUJveCB9IGZyb20gJ2Nzcy1ib3gtbW9kZWwnO1xuaW1wb3J0IHJhZlNjaGQgZnJvbSAncmFmLXNjaGQnO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuXG5jb25zdCBpc1Byb2R1Y3Rpb24kMSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5jb25zdCBzcGFjZXNBbmRUYWJzID0gL1sgXFx0XXsyLH0vZztcbmNvbnN0IGxpbmVTdGFydFdpdGhTcGFjZXMgPSAvXlsgXFx0XSovZ207XG5jb25zdCBjbGVhbiQyID0gdmFsdWUgPT4gdmFsdWUucmVwbGFjZShzcGFjZXNBbmRUYWJzLCAnICcpLnJlcGxhY2UobGluZVN0YXJ0V2l0aFNwYWNlcywgJycpLnRyaW0oKTtcbmNvbnN0IGdldERldk1lc3NhZ2UgPSBtZXNzYWdlID0+IGNsZWFuJDIoYFxuICAlY0BoZWxsby1wYW5nZWEvZG5kXG5cbiAgJWMke2NsZWFuJDIobWVzc2FnZSl9XG5cbiAgJWPwn5G34oCNIFRoaXMgaXMgYSBkZXZlbG9wbWVudCBvbmx5IG1lc3NhZ2UuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcy5cbmApO1xuY29uc3QgZ2V0Rm9ybWF0dGVkTWVzc2FnZSA9IG1lc3NhZ2UgPT4gW2dldERldk1lc3NhZ2UobWVzc2FnZSksICdjb2xvcjogIzAwQzU4NDsgZm9udC1zaXplOiAxLjJlbTsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgJ2xpbmUtaGVpZ2h0OiAxLjUnLCAnY29sb3I6ICM3MjM4NzQ7J107XG5jb25zdCBpc0Rpc2FibGVkRmxhZyA9ICdfX0BoZWxsby1wYW5nZWEvZG5kLWRpc2FibGUtZGV2LXdhcm5pbmdzJztcbmZ1bmN0aW9uIGxvZyh0eXBlLCBtZXNzYWdlKSB7XG4gIGlmIChpc1Byb2R1Y3Rpb24kMSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93W2lzRGlzYWJsZWRGbGFnXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlW3R5cGVdKC4uLmdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkpO1xufVxuY29uc3Qgd2FybmluZyA9IGxvZy5iaW5kKG51bGwsICd3YXJuJyk7XG5jb25zdCBlcnJvciA9IGxvZy5iaW5kKG51bGwsICdlcnJvcicpO1xuXG5mdW5jdGlvbiBub29wJDIoKSB7fVxuXG5mdW5jdGlvbiBnZXRPcHRpb25zKHNoYXJlZCwgZnJvbUJpbmRpbmcpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zaGFyZWQsXG4gICAgLi4uZnJvbUJpbmRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIGJpbmRFdmVudHMoZWwsIGJpbmRpbmdzLCBzaGFyZWRPcHRpb25zKSB7XG4gIGNvbnN0IHVuYmluZGluZ3MgPSBiaW5kaW5ncy5tYXAoYmluZGluZyA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGdldE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgYmluZGluZy5vcHRpb25zKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGJpbmRpbmcuZXZlbnROYW1lLCBiaW5kaW5nLmZuLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmV2ZW50TmFtZSwgYmluZGluZy5mbiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiB1bmJpbmRBbGwoKSB7XG4gICAgdW5iaW5kaW5ncy5mb3JFYWNoKHVuYmluZCA9PiB7XG4gICAgICB1bmJpbmQoKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuY29uc3QgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbmNvbnN0IHByZWZpeCQxID0gJ0ludmFyaWFudCBmYWlsZWQnO1xuY2xhc3MgUmJkSW52YXJpYW50IGV4dGVuZHMgRXJyb3Ige31cblJiZEludmFyaWFudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbn07XG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgUmJkSW52YXJpYW50KHByZWZpeCQxKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmJkSW52YXJpYW50KGAke3ByZWZpeCQxfTogJHttZXNzYWdlIHx8ICcnfWApO1xuICB9XG59XG5cbmNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMudW5iaW5kID0gbm9vcCQyO1xuICAgIHRoaXMub25XaW5kb3dFcnJvciA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuZ2V0Q2FsbGJhY2tzKCk7XG4gICAgICBpZiAoY2FsbGJhY2tzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICBjYWxsYmFja3MudHJ5QWJvcnQoKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICAgIEFuIGVycm9yIHdhcyBjYXVnaHQgYnkgb3VyIHdpbmRvdyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHdoaWxlIGEgZHJhZyB3YXMgb2NjdXJyaW5nLlxuICAgICAgICBUaGUgYWN0aXZlIGRyYWcgaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgIGApIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyID0gZXZlbnQuZXJyb3I7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUmJkSW52YXJpYW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldENhbGxiYWNrcyA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBBcHBDYWxsYmFja3MgaW4gPEVycm9yQm91bmRhcnkvPicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tzO1xuICAgIH07XG4gICAgdGhpcy5zZXRDYWxsYmFja3MgPSBjYWxsYmFja3MgPT4ge1xuICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbe1xuICAgICAgZXZlbnROYW1lOiAnZXJyb3InLFxuICAgICAgZm46IHRoaXMub25XaW5kb3dFcnJvclxuICAgIH1dKTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgUmJkSW52YXJpYW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBlcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKHt9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5iaW5kKCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuc2V0Q2FsbGJhY2tzKTtcbiAgfVxufVxuXG5jb25zdCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMgPSBgXG4gIFByZXNzIHNwYWNlIGJhciB0byBzdGFydCBhIGRyYWcuXG4gIFdoZW4gZHJhZ2dpbmcgeW91IGNhbiB1c2UgdGhlIGFycm93IGtleXMgdG8gbW92ZSB0aGUgaXRlbSBhcm91bmQgYW5kIGVzY2FwZSB0byBjYW5jZWwuXG4gIFNvbWUgc2NyZWVuIHJlYWRlcnMgbWF5IHJlcXVpcmUgeW91IHRvIGJlIGluIGZvY3VzIG1vZGUgb3IgdG8gdXNlIHlvdXIgcGFzcyB0aHJvdWdoIGtleVxuYDtcbmNvbnN0IHBvc2l0aW9uID0gaW5kZXggPT4gaW5kZXggKyAxO1xuY29uc3Qgb25EcmFnU3RhcnQgPSBzdGFydCA9PiBgXG4gIFlvdSBoYXZlIGxpZnRlZCBhbiBpdGVtIGluIHBvc2l0aW9uICR7cG9zaXRpb24oc3RhcnQuc291cmNlLmluZGV4KX1cbmA7XG5jb25zdCB3aXRoTG9jYXRpb24gPSAoc291cmNlLCBkZXN0aW5hdGlvbikgPT4ge1xuICBjb25zdCBpc0luSG9tZUxpc3QgPSBzb3VyY2UuZHJvcHBhYmxlSWQgPT09IGRlc3RpbmF0aW9uLmRyb3BwYWJsZUlkO1xuICBjb25zdCBzdGFydFBvc2l0aW9uID0gcG9zaXRpb24oc291cmNlLmluZGV4KTtcbiAgY29uc3QgZW5kUG9zaXRpb24gPSBwb3NpdGlvbihkZXN0aW5hdGlvbi5pbmRleCk7XG4gIGlmIChpc0luSG9tZUxpc3QpIHtcbiAgICByZXR1cm4gYFxuICAgICAgWW91IGhhdmUgbW92ZWQgdGhlIGl0ZW0gZnJvbSBwb3NpdGlvbiAke3N0YXJ0UG9zaXRpb259XG4gICAgICB0byBwb3NpdGlvbiAke2VuZFBvc2l0aW9ufVxuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICBZb3UgaGF2ZSBtb3ZlZCB0aGUgaXRlbSBmcm9tIHBvc2l0aW9uICR7c3RhcnRQb3NpdGlvbn1cbiAgICBpbiBsaXN0ICR7c291cmNlLmRyb3BwYWJsZUlkfVxuICAgIHRvIGxpc3QgJHtkZXN0aW5hdGlvbi5kcm9wcGFibGVJZH1cbiAgICBpbiBwb3NpdGlvbiAke2VuZFBvc2l0aW9ufVxuICBgO1xufTtcbmNvbnN0IHdpdGhDb21iaW5lID0gKGlkLCBzb3VyY2UsIGNvbWJpbmUpID0+IHtcbiAgY29uc3QgaW5Ib21lTGlzdCA9IHNvdXJjZS5kcm9wcGFibGVJZCA9PT0gY29tYmluZS5kcm9wcGFibGVJZDtcbiAgaWYgKGluSG9tZUxpc3QpIHtcbiAgICByZXR1cm4gYFxuICAgICAgVGhlIGl0ZW0gJHtpZH1cbiAgICAgIGhhcyBiZWVuIGNvbWJpbmVkIHdpdGggJHtjb21iaW5lLmRyYWdnYWJsZUlkfWA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICAgIFRoZSBpdGVtICR7aWR9XG4gICAgICBpbiBsaXN0ICR7c291cmNlLmRyb3BwYWJsZUlkfVxuICAgICAgaGFzIGJlZW4gY29tYmluZWQgd2l0aCAke2NvbWJpbmUuZHJhZ2dhYmxlSWR9XG4gICAgICBpbiBsaXN0ICR7Y29tYmluZS5kcm9wcGFibGVJZH1cbiAgICBgO1xufTtcbmNvbnN0IG9uRHJhZ1VwZGF0ZSA9IHVwZGF0ZSA9PiB7XG4gIGNvbnN0IGxvY2F0aW9uID0gdXBkYXRlLmRlc3RpbmF0aW9uO1xuICBpZiAobG9jYXRpb24pIHtcbiAgICByZXR1cm4gd2l0aExvY2F0aW9uKHVwZGF0ZS5zb3VyY2UsIGxvY2F0aW9uKTtcbiAgfVxuICBjb25zdCBjb21iaW5lID0gdXBkYXRlLmNvbWJpbmU7XG4gIGlmIChjb21iaW5lKSB7XG4gICAgcmV0dXJuIHdpdGhDb21iaW5lKHVwZGF0ZS5kcmFnZ2FibGVJZCwgdXBkYXRlLnNvdXJjZSwgY29tYmluZSk7XG4gIH1cbiAgcmV0dXJuICdZb3UgYXJlIG92ZXIgYW4gYXJlYSB0aGF0IGNhbm5vdCBiZSBkcm9wcGVkIG9uJztcbn07XG5jb25zdCByZXR1cm5lZFRvU3RhcnQgPSBzb3VyY2UgPT4gYFxuICBUaGUgaXRlbSBoYXMgcmV0dXJuZWQgdG8gaXRzIHN0YXJ0aW5nIHBvc2l0aW9uXG4gIG9mICR7cG9zaXRpb24oc291cmNlLmluZGV4KX1cbmA7XG5jb25zdCBvbkRyYWdFbmQgPSByZXN1bHQgPT4ge1xuICBpZiAocmVzdWx0LnJlYXNvbiA9PT0gJ0NBTkNFTCcpIHtcbiAgICByZXR1cm4gYFxuICAgICAgTW92ZW1lbnQgY2FuY2VsbGVkLlxuICAgICAgJHtyZXR1cm5lZFRvU3RhcnQocmVzdWx0LnNvdXJjZSl9XG4gICAgYDtcbiAgfVxuICBjb25zdCBsb2NhdGlvbiA9IHJlc3VsdC5kZXN0aW5hdGlvbjtcbiAgY29uc3QgY29tYmluZSA9IHJlc3VsdC5jb21iaW5lO1xuICBpZiAobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYFxuICAgICAgWW91IGhhdmUgZHJvcHBlZCB0aGUgaXRlbS5cbiAgICAgICR7d2l0aExvY2F0aW9uKHJlc3VsdC5zb3VyY2UsIGxvY2F0aW9uKX1cbiAgICBgO1xuICB9XG4gIGlmIChjb21iaW5lKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFlvdSBoYXZlIGRyb3BwZWQgdGhlIGl0ZW0uXG4gICAgICAke3dpdGhDb21iaW5lKHJlc3VsdC5kcmFnZ2FibGVJZCwgcmVzdWx0LnNvdXJjZSwgY29tYmluZSl9XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgIFRoZSBpdGVtIGhhcyBiZWVuIGRyb3BwZWQgd2hpbGUgbm90IG92ZXIgYSBkcm9wIGFyZWEuXG4gICAgJHtyZXR1cm5lZFRvU3RhcnQocmVzdWx0LnNvdXJjZSl9XG4gIGA7XG59O1xuY29uc3QgcHJlc2V0ID0ge1xuICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMsXG4gIG9uRHJhZ1N0YXJ0LFxuICBvbkRyYWdVcGRhdGUsXG4gIG9uRHJhZ0VuZFxufTtcblxuZnVuY3Rpb24gaXNFcXVhbCQyKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSBzZWNvbmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoTnVtYmVyLmlzTmFOKGZpcnN0KSAmJiBOdW1iZXIuaXNOYU4oc2Vjb25kKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFyZUlucHV0c0VxdWFsKG5ld0lucHV0cywgbGFzdElucHV0cykge1xuICBpZiAobmV3SW5wdXRzLmxlbmd0aCAhPT0gbGFzdElucHV0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWlzRXF1YWwkMihuZXdJbnB1dHNbaV0sIGxhc3RJbnB1dHNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB1c2VNZW1vKGdldFJlc3VsdCwgaW5wdXRzKSB7XG4gIGNvbnN0IGluaXRpYWwgPSB1c2VTdGF0ZSgoKSA9PiAoe1xuICAgIGlucHV0cyxcbiAgICByZXN1bHQ6IGdldFJlc3VsdCgpXG4gIH0pKVswXTtcbiAgY29uc3QgaXNGaXJzdFJ1biA9IHVzZVJlZih0cnVlKTtcbiAgY29uc3QgY29tbWl0dGVkID0gdXNlUmVmKGluaXRpYWwpO1xuICBjb25zdCB1c2VDYWNoZSA9IGlzRmlyc3RSdW4uY3VycmVudCB8fCBCb29sZWFuKGlucHV0cyAmJiBjb21taXR0ZWQuY3VycmVudC5pbnB1dHMgJiYgYXJlSW5wdXRzRXF1YWwoaW5wdXRzLCBjb21taXR0ZWQuY3VycmVudC5pbnB1dHMpKTtcbiAgY29uc3QgY2FjaGUgPSB1c2VDYWNoZSA/IGNvbW1pdHRlZC5jdXJyZW50IDoge1xuICAgIGlucHV0cyxcbiAgICByZXN1bHQ6IGdldFJlc3VsdCgpXG4gIH07XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaXNGaXJzdFJ1bi5jdXJyZW50ID0gZmFsc2U7XG4gICAgY29tbWl0dGVkLmN1cnJlbnQgPSBjYWNoZTtcbiAgfSwgW2NhY2hlXSk7XG4gIHJldHVybiBjYWNoZS5yZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgaW5wdXRzKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IGNhbGxiYWNrLCBpbnB1dHMpO1xufVxuXG5jb25zdCBvcmlnaW4gPSB7XG4gIHg6IDAsXG4gIHk6IDBcbn07XG5jb25zdCBhZGQgPSAocG9pbnQxLCBwb2ludDIpID0+ICh7XG4gIHg6IHBvaW50MS54ICsgcG9pbnQyLngsXG4gIHk6IHBvaW50MS55ICsgcG9pbnQyLnlcbn0pO1xuY29uc3Qgc3VidHJhY3QgPSAocG9pbnQxLCBwb2ludDIpID0+ICh7XG4gIHg6IHBvaW50MS54IC0gcG9pbnQyLngsXG4gIHk6IHBvaW50MS55IC0gcG9pbnQyLnlcbn0pO1xuY29uc3QgaXNFcXVhbCQxID0gKHBvaW50MSwgcG9pbnQyKSA9PiBwb2ludDEueCA9PT0gcG9pbnQyLnggJiYgcG9pbnQxLnkgPT09IHBvaW50Mi55O1xuY29uc3QgbmVnYXRlID0gcG9pbnQgPT4gKHtcbiAgeDogcG9pbnQueCAhPT0gMCA/IC1wb2ludC54IDogMCxcbiAgeTogcG9pbnQueSAhPT0gMCA/IC1wb2ludC55IDogMFxufSk7XG5jb25zdCBwYXRjaCA9IChsaW5lLCB2YWx1ZSwgb3RoZXJWYWx1ZSA9IDApID0+IHtcbiAgaWYgKGxpbmUgPT09ICd4Jykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB2YWx1ZSxcbiAgICAgIHk6IG90aGVyVmFsdWVcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogb3RoZXJWYWx1ZSxcbiAgICB5OiB2YWx1ZVxuICB9O1xufTtcbmNvbnN0IGRpc3RhbmNlID0gKHBvaW50MSwgcG9pbnQyKSA9PiBNYXRoLnNxcnQoKHBvaW50Mi54IC0gcG9pbnQxLngpICoqIDIgKyAocG9pbnQyLnkgLSBwb2ludDEueSkgKiogMik7XG5jb25zdCBjbG9zZXN0JDEgPSAodGFyZ2V0LCBwb2ludHMpID0+IE1hdGgubWluKC4uLnBvaW50cy5tYXAocG9pbnQgPT4gZGlzdGFuY2UodGFyZ2V0LCBwb2ludCkpKTtcbmNvbnN0IGFwcGx5ID0gZm4gPT4gcG9pbnQgPT4gKHtcbiAgeDogZm4ocG9pbnQueCksXG4gIHk6IGZuKHBvaW50LnkpXG59KTtcblxudmFyIGV4ZWN1dGVDbGlwID0gKGZyYW1lLCBzdWJqZWN0KSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldFJlY3Qoe1xuICAgIHRvcDogTWF0aC5tYXgoc3ViamVjdC50b3AsIGZyYW1lLnRvcCksXG4gICAgcmlnaHQ6IE1hdGgubWluKHN1YmplY3QucmlnaHQsIGZyYW1lLnJpZ2h0KSxcbiAgICBib3R0b206IE1hdGgubWluKHN1YmplY3QuYm90dG9tLCBmcmFtZS5ib3R0b20pLFxuICAgIGxlZnQ6IE1hdGgubWF4KHN1YmplY3QubGVmdCwgZnJhbWUubGVmdClcbiAgfSk7XG4gIGlmIChyZXN1bHQud2lkdGggPD0gMCB8fCByZXN1bHQuaGVpZ2h0IDw9IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3Qgb2Zmc2V0QnlQb3NpdGlvbiA9IChzcGFjaW5nLCBwb2ludCkgPT4gKHtcbiAgdG9wOiBzcGFjaW5nLnRvcCArIHBvaW50LnksXG4gIGxlZnQ6IHNwYWNpbmcubGVmdCArIHBvaW50LngsXG4gIGJvdHRvbTogc3BhY2luZy5ib3R0b20gKyBwb2ludC55LFxuICByaWdodDogc3BhY2luZy5yaWdodCArIHBvaW50Lnhcbn0pO1xuY29uc3QgZ2V0Q29ybmVycyA9IHNwYWNpbmcgPT4gW3tcbiAgeDogc3BhY2luZy5sZWZ0LFxuICB5OiBzcGFjaW5nLnRvcFxufSwge1xuICB4OiBzcGFjaW5nLnJpZ2h0LFxuICB5OiBzcGFjaW5nLnRvcFxufSwge1xuICB4OiBzcGFjaW5nLmxlZnQsXG4gIHk6IHNwYWNpbmcuYm90dG9tXG59LCB7XG4gIHg6IHNwYWNpbmcucmlnaHQsXG4gIHk6IHNwYWNpbmcuYm90dG9tXG59XTtcbmNvbnN0IG5vU3BhY2luZyA9IHtcbiAgdG9wOiAwLFxuICByaWdodDogMCxcbiAgYm90dG9tOiAwLFxuICBsZWZ0OiAwXG59O1xuXG5jb25zdCBzY3JvbGwkMSA9ICh0YXJnZXQsIGZyYW1lKSA9PiB7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBvZmZzZXRCeVBvc2l0aW9uKHRhcmdldCwgZnJhbWUuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50KTtcbn07XG5jb25zdCBpbmNyZWFzZSA9ICh0YXJnZXQsIGF4aXMsIHdpdGhQbGFjZWhvbGRlcikgPT4ge1xuICBpZiAod2l0aFBsYWNlaG9sZGVyICYmIHdpdGhQbGFjZWhvbGRlci5pbmNyZWFzZWRCeSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBbYXhpcy5lbmRdOiB0YXJnZXRbYXhpcy5lbmRdICsgd2l0aFBsYWNlaG9sZGVyLmluY3JlYXNlZEJ5W2F4aXMubGluZV1cbiAgICB9O1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuY29uc3QgY2xpcCA9ICh0YXJnZXQsIGZyYW1lKSA9PiB7XG4gIGlmIChmcmFtZSAmJiBmcmFtZS5zaG91bGRDbGlwU3ViamVjdCkge1xuICAgIHJldHVybiBleGVjdXRlQ2xpcChmcmFtZS5wYWdlTWFyZ2luQm94LCB0YXJnZXQpO1xuICB9XG4gIHJldHVybiBnZXRSZWN0KHRhcmdldCk7XG59O1xudmFyIGdldFN1YmplY3QgPSAoe1xuICBwYWdlLFxuICB3aXRoUGxhY2Vob2xkZXIsXG4gIGF4aXMsXG4gIGZyYW1lXG59KSA9PiB7XG4gIGNvbnN0IHNjcm9sbGVkID0gc2Nyb2xsJDEocGFnZS5tYXJnaW5Cb3gsIGZyYW1lKTtcbiAgY29uc3QgaW5jcmVhc2VkID0gaW5jcmVhc2Uoc2Nyb2xsZWQsIGF4aXMsIHdpdGhQbGFjZWhvbGRlcik7XG4gIGNvbnN0IGNsaXBwZWQgPSBjbGlwKGluY3JlYXNlZCwgZnJhbWUpO1xuICByZXR1cm4ge1xuICAgIHBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyLFxuICAgIGFjdGl2ZTogY2xpcHBlZFxuICB9O1xufTtcblxudmFyIHNjcm9sbERyb3BwYWJsZSA9IChkcm9wcGFibGUsIG5ld1Njcm9sbCkgPT4ge1xuICAhZHJvcHBhYmxlLmZyYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3Qgc2Nyb2xsYWJsZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgY29uc3Qgc2Nyb2xsRGlmZiA9IHN1YnRyYWN0KG5ld1Njcm9sbCwgc2Nyb2xsYWJsZS5zY3JvbGwuaW5pdGlhbCk7XG4gIGNvbnN0IHNjcm9sbERpc3BsYWNlbWVudCA9IG5lZ2F0ZShzY3JvbGxEaWZmKTtcbiAgY29uc3QgZnJhbWUgPSB7XG4gICAgLi4uc2Nyb2xsYWJsZSxcbiAgICBzY3JvbGw6IHtcbiAgICAgIGluaXRpYWw6IHNjcm9sbGFibGUuc2Nyb2xsLmluaXRpYWwsXG4gICAgICBjdXJyZW50OiBuZXdTY3JvbGwsXG4gICAgICBkaWZmOiB7XG4gICAgICAgIHZhbHVlOiBzY3JvbGxEaWZmLFxuICAgICAgICBkaXNwbGFjZW1lbnQ6IHNjcm9sbERpc3BsYWNlbWVudFxuICAgICAgfSxcbiAgICAgIG1heDogc2Nyb2xsYWJsZS5zY3JvbGwubWF4XG4gICAgfVxuICB9O1xuICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IGRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcixcbiAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICBmcmFtZVxuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLmRyb3BwYWJsZSxcbiAgICBmcmFtZSxcbiAgICBzdWJqZWN0XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBtZW1vaXplT25lKHJlc3VsdEZuLCBpc0VxdWFsID0gYXJlSW5wdXRzRXF1YWwpIHtcbiAgbGV0IGNhY2hlID0gbnVsbDtcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoLi4ubmV3QXJncykge1xuICAgIGlmIChjYWNoZSAmJiBjYWNoZS5sYXN0VGhpcyA9PT0gdGhpcyAmJiBpc0VxdWFsKG5ld0FyZ3MsIGNhY2hlLmxhc3RBcmdzKSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmxhc3RSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RSZXN1bHQgPSByZXN1bHRGbi5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgICBjYWNoZSA9IHtcbiAgICAgIGxhc3RSZXN1bHQsXG4gICAgICBsYXN0QXJnczogbmV3QXJncyxcbiAgICAgIGxhc3RUaGlzOiB0aGlzXG4gICAgfTtcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgfVxuICBtZW1vaXplZC5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGNhY2hlID0gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG5jb25zdCB0b0Ryb3BwYWJsZU1hcCA9IG1lbW9pemVPbmUoZHJvcHBhYmxlcyA9PiBkcm9wcGFibGVzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgcHJldmlvdXNbY3VycmVudC5kZXNjcmlwdG9yLmlkXSA9IGN1cnJlbnQ7XG4gIHJldHVybiBwcmV2aW91cztcbn0sIHt9KSk7XG5jb25zdCB0b0RyYWdnYWJsZU1hcCA9IG1lbW9pemVPbmUoZHJhZ2dhYmxlcyA9PiBkcmFnZ2FibGVzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgcHJldmlvdXNbY3VycmVudC5kZXNjcmlwdG9yLmlkXSA9IGN1cnJlbnQ7XG4gIHJldHVybiBwcmV2aW91cztcbn0sIHt9KSk7XG5jb25zdCB0b0Ryb3BwYWJsZUxpc3QgPSBtZW1vaXplT25lKGRyb3BwYWJsZXMgPT4gT2JqZWN0LnZhbHVlcyhkcm9wcGFibGVzKSk7XG5jb25zdCB0b0RyYWdnYWJsZUxpc3QgPSBtZW1vaXplT25lKGRyYWdnYWJsZXMgPT4gT2JqZWN0LnZhbHVlcyhkcmFnZ2FibGVzKSk7XG5cbnZhciBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlID0gbWVtb2l6ZU9uZSgoZHJvcHBhYmxlSWQsIGRyYWdnYWJsZXMpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gdG9EcmFnZ2FibGVMaXN0KGRyYWdnYWJsZXMpLmZpbHRlcihkcmFnZ2FibGUgPT4gZHJvcHBhYmxlSWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkKS5zb3J0KChhLCBiKSA9PiBhLmRlc2NyaXB0b3IuaW5kZXggLSBiLmRlc2NyaXB0b3IuaW5kZXgpO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmZ1bmN0aW9uIHRyeUdldERlc3RpbmF0aW9uKGltcGFjdCkge1xuICBpZiAoaW1wYWN0LmF0ICYmIGltcGFjdC5hdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gaW1wYWN0LmF0LmRlc3RpbmF0aW9uO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdHJ5R2V0Q29tYmluZShpbXBhY3QpIHtcbiAgaWYgKGltcGFjdC5hdCAmJiBpbXBhY3QuYXQudHlwZSA9PT0gJ0NPTUJJTkUnKSB7XG4gICAgcmV0dXJuIGltcGFjdC5hdC5jb21iaW5lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QgPSBtZW1vaXplT25lKChyZW1vdmUsIGxpc3QpID0+IGxpc3QuZmlsdGVyKGl0ZW0gPT4gaXRlbS5kZXNjcmlwdG9yLmlkICE9PSByZW1vdmUuZGVzY3JpcHRvci5pZCkpO1xuXG52YXIgbW92ZVRvTmV4dENvbWJpbmUgPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIGRyYWdnYWJsZSxcbiAgZGVzdGluYXRpb24sXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBwcmV2aW91c0ltcGFjdFxufSkgPT4ge1xuICBpZiAoIWRlc3RpbmF0aW9uLmlzQ29tYmluZUVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsb2NhdGlvbiA9IHRyeUdldERlc3RpbmF0aW9uKHByZXZpb3VzSW1wYWN0KTtcbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldEltcGFjdCh0YXJnZXQpIHtcbiAgICBjb25zdCBhdCA9IHtcbiAgICAgIHR5cGU6ICdDT01CSU5FJyxcbiAgICAgIGNvbWJpbmU6IHtcbiAgICAgICAgZHJhZ2dhYmxlSWQ6IHRhcmdldCxcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWRcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wcmV2aW91c0ltcGFjdCxcbiAgICAgIGF0XG4gICAgfTtcbiAgfVxuICBjb25zdCBhbGwgPSBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQuYWxsO1xuICBjb25zdCBjbG9zZXN0SWQgPSBhbGwubGVuZ3RoID8gYWxsWzBdIDogbnVsbDtcbiAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgIHJldHVybiBjbG9zZXN0SWQgPyBnZXRJbXBhY3QoY2xvc2VzdElkKSA6IG51bGw7XG4gIH1cbiAgY29uc3Qgd2l0aG91dERyYWdnYWJsZSA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuICBpZiAoIWNsb3Nlc3RJZCkge1xuICAgIGlmICghd2l0aG91dERyYWdnYWJsZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gd2l0aG91dERyYWdnYWJsZVt3aXRob3V0RHJhZ2dhYmxlLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBnZXRJbXBhY3QobGFzdC5kZXNjcmlwdG9yLmlkKTtcbiAgfVxuICBjb25zdCBpbmRleE9mQ2xvc2VzdCA9IHdpdGhvdXREcmFnZ2FibGUuZmluZEluZGV4KGQgPT4gZC5kZXNjcmlwdG9yLmlkID09PSBjbG9zZXN0SWQpO1xuICAhKGluZGV4T2ZDbG9zZXN0ICE9PSAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBkaXNwbGFjZWQgaXRlbSBpbiBzZXQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBwcm9wb3NlZEluZGV4ID0gaW5kZXhPZkNsb3Nlc3QgLSAxO1xuICBpZiAocHJvcG9zZWRJbmRleCA8IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBiZWZvcmUgPSB3aXRob3V0RHJhZ2dhYmxlW3Byb3Bvc2VkSW5kZXhdO1xuICByZXR1cm4gZ2V0SW1wYWN0KGJlZm9yZS5kZXNjcmlwdG9yLmlkKTtcbn07XG5cbnZhciBpc0hvbWVPZiA9IChkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKSA9PiBkcmFnZ2FibGUuZGVzY3JpcHRvci5kcm9wcGFibGVJZCA9PT0gZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZDtcblxuY29uc3Qgbm9EaXNwbGFjZWRCeSA9IHtcbiAgcG9pbnQ6IG9yaWdpbixcbiAgdmFsdWU6IDBcbn07XG5jb25zdCBlbXB0eUdyb3VwcyA9IHtcbiAgaW52aXNpYmxlOiB7fSxcbiAgdmlzaWJsZToge30sXG4gIGFsbDogW11cbn07XG5jb25zdCBub0ltcGFjdCA9IHtcbiAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgZGlzcGxhY2VkQnk6IG5vRGlzcGxhY2VkQnksXG4gIGF0OiBudWxsXG59O1xuXG52YXIgaXNXaXRoaW4gPSAobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkgPT4gdmFsdWUgPT4gbG93ZXJCb3VuZCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB1cHBlckJvdW5kO1xuXG52YXIgaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lID0gZnJhbWUgPT4ge1xuICBjb25zdCBpc1dpdGhpblZlcnRpY2FsID0gaXNXaXRoaW4oZnJhbWUudG9wLCBmcmFtZS5ib3R0b20pO1xuICBjb25zdCBpc1dpdGhpbkhvcml6b250YWwgPSBpc1dpdGhpbihmcmFtZS5sZWZ0LCBmcmFtZS5yaWdodCk7XG4gIHJldHVybiBzdWJqZWN0ID0+IHtcbiAgICBjb25zdCBpc0NvbnRhaW5lZCA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICBpZiAoaXNDb250YWluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpc1BhcnRpYWxseVZpc2libGVWZXJ0aWNhbGx5ID0gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgfHwgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSk7XG4gICAgY29uc3QgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5ID0gaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgfHwgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICAgIGNvbnN0IGlzUGFydGlhbGx5Q29udGFpbmVkID0gaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSAmJiBpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHk7XG4gICAgaWYgKGlzUGFydGlhbGx5Q29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNCaWdnZXJWZXJ0aWNhbGx5ID0gc3ViamVjdC50b3AgPCBmcmFtZS50b3AgJiYgc3ViamVjdC5ib3R0b20gPiBmcmFtZS5ib3R0b207XG4gICAgY29uc3QgaXNCaWdnZXJIb3Jpem9udGFsbHkgPSBzdWJqZWN0LmxlZnQgPCBmcmFtZS5sZWZ0ICYmIHN1YmplY3QucmlnaHQgPiBmcmFtZS5yaWdodDtcbiAgICBjb25zdCBpc1RhcmdldEJpZ2dlclRoYW5GcmFtZSA9IGlzQmlnZ2VyVmVydGljYWxseSAmJiBpc0JpZ2dlckhvcml6b250YWxseTtcbiAgICBpZiAoaXNUYXJnZXRCaWdnZXJUaGFuRnJhbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpc1RhcmdldEJpZ2dlck9uT25lQXhpcyA9IGlzQmlnZ2VyVmVydGljYWxseSAmJiBpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHkgfHwgaXNCaWdnZXJIb3Jpem9udGFsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseTtcbiAgICByZXR1cm4gaXNUYXJnZXRCaWdnZXJPbk9uZUF4aXM7XG4gIH07XG59O1xuXG52YXIgaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSA9IGZyYW1lID0+IHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gc3ViamVjdCA9PiB7XG4gICAgY29uc3QgaXNDb250YWluZWQgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSAmJiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgcmV0dXJuIGlzQ29udGFpbmVkO1xuICB9O1xufTtcblxuY29uc3QgdmVydGljYWwgPSB7XG4gIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgbGluZTogJ3knLFxuICBjcm9zc0F4aXNMaW5lOiAneCcsXG4gIHN0YXJ0OiAndG9wJyxcbiAgZW5kOiAnYm90dG9tJyxcbiAgc2l6ZTogJ2hlaWdodCcsXG4gIGNyb3NzQXhpc1N0YXJ0OiAnbGVmdCcsXG4gIGNyb3NzQXhpc0VuZDogJ3JpZ2h0JyxcbiAgY3Jvc3NBeGlzU2l6ZTogJ3dpZHRoJ1xufTtcbmNvbnN0IGhvcml6b250YWwgPSB7XG4gIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLFxuICBsaW5lOiAneCcsXG4gIGNyb3NzQXhpc0xpbmU6ICd5JyxcbiAgc3RhcnQ6ICdsZWZ0JyxcbiAgZW5kOiAncmlnaHQnLFxuICBzaXplOiAnd2lkdGgnLFxuICBjcm9zc0F4aXNTdGFydDogJ3RvcCcsXG4gIGNyb3NzQXhpc0VuZDogJ2JvdHRvbScsXG4gIGNyb3NzQXhpc1NpemU6ICdoZWlnaHQnXG59O1xuXG52YXIgaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZU9uQXhpcyA9IGF4aXMgPT4gZnJhbWUgPT4ge1xuICBjb25zdCBpc1dpdGhpblZlcnRpY2FsID0gaXNXaXRoaW4oZnJhbWUudG9wLCBmcmFtZS5ib3R0b20pO1xuICBjb25zdCBpc1dpdGhpbkhvcml6b250YWwgPSBpc1dpdGhpbihmcmFtZS5sZWZ0LCBmcmFtZS5yaWdodCk7XG4gIHJldHVybiBzdWJqZWN0ID0+IHtcbiAgICBpZiAoYXhpcyA9PT0gdmVydGljYWwpIHtcbiAgICAgIHJldHVybiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSAmJiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgfTtcbn07XG5cbmNvbnN0IGdldERyb3BwYWJsZURpc3BsYWNlZCA9ICh0YXJnZXQsIGRlc3RpbmF0aW9uKSA9PiB7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IGRlc3RpbmF0aW9uLmZyYW1lID8gZGVzdGluYXRpb24uZnJhbWUuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50IDogb3JpZ2luO1xuICByZXR1cm4gb2Zmc2V0QnlQb3NpdGlvbih0YXJnZXQsIGRpc3BsYWNlbWVudCk7XG59O1xuY29uc3QgaXNWaXNpYmxlSW5Ecm9wcGFibGUgPSAodGFyZ2V0LCBkZXN0aW5hdGlvbiwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5zdWJqZWN0LmFjdGl2ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4oZGVzdGluYXRpb24uc3ViamVjdC5hY3RpdmUpKHRhcmdldCk7XG59O1xuY29uc3QgaXNWaXNpYmxlSW5WaWV3cG9ydCA9ICh0YXJnZXQsIHZpZXdwb3J0LCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikgPT4gaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4odmlld3BvcnQpKHRhcmdldCk7XG5jb25zdCBpc1Zpc2libGUkMSA9ICh7XG4gIHRhcmdldDogdG9CZURpc3BsYWNlZCxcbiAgZGVzdGluYXRpb24sXG4gIHZpZXdwb3J0LFxuICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50LFxuICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGblxufSkgPT4ge1xuICBjb25zdCBkaXNwbGFjZWRUYXJnZXQgPSB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50ID8gZ2V0RHJvcHBhYmxlRGlzcGxhY2VkKHRvQmVEaXNwbGFjZWQsIGRlc3RpbmF0aW9uKSA6IHRvQmVEaXNwbGFjZWQ7XG4gIHJldHVybiBpc1Zpc2libGVJbkRyb3BwYWJsZShkaXNwbGFjZWRUYXJnZXQsIGRlc3RpbmF0aW9uLCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikgJiYgaXNWaXNpYmxlSW5WaWV3cG9ydChkaXNwbGFjZWRUYXJnZXQsIHZpZXdwb3J0LCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbik7XG59O1xuY29uc3QgaXNQYXJ0aWFsbHlWaXNpYmxlID0gYXJncyA9PiBpc1Zpc2libGUkMSh7XG4gIC4uLmFyZ3MsXG4gIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWVcbn0pO1xuY29uc3QgaXNUb3RhbGx5VmlzaWJsZSA9IGFyZ3MgPT4gaXNWaXNpYmxlJDEoe1xuICAuLi5hcmdzLFxuICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbjogaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZVxufSk7XG5jb25zdCBpc1RvdGFsbHlWaXNpYmxlT25BeGlzID0gYXJncyA9PiBpc1Zpc2libGUkMSh7XG4gIC4uLmFyZ3MsXG4gIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lT25BeGlzKGFyZ3MuZGVzdGluYXRpb24uYXhpcylcbn0pO1xuXG5jb25zdCBnZXRTaG91bGRBbmltYXRlID0gKGlkLCBsYXN0LCBmb3JjZVNob3VsZEFuaW1hdGUpID0+IHtcbiAgaWYgKHR5cGVvZiBmb3JjZVNob3VsZEFuaW1hdGUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBmb3JjZVNob3VsZEFuaW1hdGU7XG4gIH1cbiAgaWYgKCFsYXN0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qge1xuICAgIGludmlzaWJsZSxcbiAgICB2aXNpYmxlXG4gIH0gPSBsYXN0O1xuICBpZiAoaW52aXNpYmxlW2lkXSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcmV2aW91cyA9IHZpc2libGVbaWRdO1xuICByZXR1cm4gcHJldmlvdXMgPyBwcmV2aW91cy5zaG91bGRBbmltYXRlIDogdHJ1ZTtcbn07XG5mdW5jdGlvbiBnZXRUYXJnZXQoZHJhZ2dhYmxlLCBkaXNwbGFjZWRCeSkge1xuICBjb25zdCBtYXJnaW5Cb3ggPSBkcmFnZ2FibGUucGFnZS5tYXJnaW5Cb3g7XG4gIGNvbnN0IGV4cGFuZEJ5ID0ge1xuICAgIHRvcDogZGlzcGxhY2VkQnkucG9pbnQueSxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogZGlzcGxhY2VkQnkucG9pbnQueFxuICB9O1xuICByZXR1cm4gZ2V0UmVjdChleHBhbmQobWFyZ2luQm94LCBleHBhbmRCeSkpO1xufVxuZnVuY3Rpb24gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgYWZ0ZXJEcmFnZ2luZyxcbiAgZGVzdGluYXRpb24sXG4gIGRpc3BsYWNlZEJ5LFxuICB2aWV3cG9ydCxcbiAgZm9yY2VTaG91bGRBbmltYXRlLFxuICBsYXN0XG59KSB7XG4gIHJldHVybiBhZnRlckRyYWdnaW5nLnJlZHVjZShmdW5jdGlvbiBwcm9jZXNzKGdyb3VwcywgZHJhZ2dhYmxlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGRyYWdnYWJsZSwgZGlzcGxhY2VkQnkpO1xuICAgIGNvbnN0IGlkID0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQ7XG4gICAgZ3JvdXBzLmFsbC5wdXNoKGlkKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSBpc1BhcnRpYWxseVZpc2libGUoe1xuICAgICAgdGFyZ2V0LFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoIWlzVmlzaWJsZSkge1xuICAgICAgZ3JvdXBzLmludmlzaWJsZVtkcmFnZ2FibGUuZGVzY3JpcHRvci5pZF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZSA9IGdldFNob3VsZEFuaW1hdGUoaWQsIGxhc3QsIGZvcmNlU2hvdWxkQW5pbWF0ZSk7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0ge1xuICAgICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgICAgc2hvdWxkQW5pbWF0ZVxuICAgIH07XG4gICAgZ3JvdXBzLnZpc2libGVbaWRdID0gZGlzcGxhY2VtZW50O1xuICAgIHJldHVybiBncm91cHM7XG4gIH0sIHtcbiAgICBhbGw6IFtdLFxuICAgIHZpc2libGU6IHt9LFxuICAgIGludmlzaWJsZToge31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4T2ZMYXN0SXRlbShkcmFnZ2FibGVzLCBvcHRpb25zKSB7XG4gIGlmICghZHJhZ2dhYmxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBpbmRleE9mTGFzdEl0ZW0gPSBkcmFnZ2FibGVzW2RyYWdnYWJsZXMubGVuZ3RoIC0gMV0uZGVzY3JpcHRvci5pbmRleDtcbiAgcmV0dXJuIG9wdGlvbnMuaW5Ib21lTGlzdCA/IGluZGV4T2ZMYXN0SXRlbSA6IGluZGV4T2ZMYXN0SXRlbSArIDE7XG59XG5mdW5jdGlvbiBnb0F0RW5kKHtcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGluSG9tZUxpc3QsXG4gIGRpc3BsYWNlZEJ5LFxuICBkZXN0aW5hdGlvblxufSkge1xuICBjb25zdCBuZXdJbmRleCA9IGdldEluZGV4T2ZMYXN0SXRlbShpbnNpZGVEZXN0aW5hdGlvbiwge1xuICAgIGluSG9tZUxpc3RcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICBkcmFnZ2FibGUsXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBkZXN0aW5hdGlvbixcbiAgdmlld3BvcnQsXG4gIGRpc3BsYWNlZEJ5LFxuICBsYXN0LFxuICBpbmRleCxcbiAgZm9yY2VTaG91bGRBbmltYXRlXG59KSB7XG4gIGNvbnN0IGluSG9tZUxpc3QgPSBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKTtcbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gZ29BdEVuZCh7XG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGluSG9tZUxpc3QsXG4gICAgICBkaXNwbGFjZWRCeSxcbiAgICAgIGRlc3RpbmF0aW9uXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSBpbnNpZGVEZXN0aW5hdGlvbi5maW5kKGl0ZW0gPT4gaXRlbS5kZXNjcmlwdG9yLmluZGV4ID09PSBpbmRleCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZ29BdEVuZCh7XG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGluSG9tZUxpc3QsXG4gICAgICBkaXNwbGFjZWRCeSxcbiAgICAgIGRlc3RpbmF0aW9uXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGNvbnN0IHNsaWNlRnJvbSA9IGluc2lkZURlc3RpbmF0aW9uLmluZGV4T2YobWF0Y2gpO1xuICBjb25zdCBpbXBhY3RlZCA9IHdpdGhvdXREcmFnZ2luZy5zbGljZShzbGljZUZyb20pO1xuICBjb25zdCBkaXNwbGFjZWQgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGltcGFjdGVkLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGxhc3QsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLFxuICAgICAgICBpbmRleFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGRyYWdnYWJsZUlkLCBhZnRlckNyaXRpY2FsKSB7XG4gIHJldHVybiBCb29sZWFuKGFmdGVyQ3JpdGljYWwuZWZmZWN0ZWRbZHJhZ2dhYmxlSWRdKTtcbn1cblxudmFyIGZyb21Db21iaW5lID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBkZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlcyxcbiAgY29tYmluZSxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBpZiAoIWRlc3RpbmF0aW9uLmlzQ29tYmluZUVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBjb21iaW5lSWQgPSBjb21iaW5lLmRyYWdnYWJsZUlkO1xuICBjb25zdCBjb21iaW5lV2l0aCA9IGRyYWdnYWJsZXNbY29tYmluZUlkXTtcbiAgY29uc3QgY29tYmluZVdpdGhJbmRleCA9IGNvbWJpbmVXaXRoLmRlc2NyaXB0b3IuaW5kZXg7XG4gIGNvbnN0IGRpZENvbWJpbmVXaXRoU3RhcnRBZnRlckNyaXRpY2FsID0gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGNvbWJpbmVJZCwgYWZ0ZXJDcml0aWNhbCk7XG4gIGlmIChkaWRDb21iaW5lV2l0aFN0YXJ0QWZ0ZXJDcml0aWNhbCkge1xuICAgIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICAgIHJldHVybiBjb21iaW5lV2l0aEluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleCAtIDE7XG4gIH1cbiAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgIHJldHVybiBjb21iaW5lV2l0aEluZGV4ICsgMTtcbiAgfVxuICByZXR1cm4gY29tYmluZVdpdGhJbmRleDtcbn07XG5cbnZhciBmcm9tUmVvcmRlciA9ICh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgaXNJbkhvbWVMaXN0LFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgbG9jYXRpb25cbn0pID0+IHtcbiAgaWYgKCFpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBjdXJyZW50SW5kZXggPSBsb2NhdGlvbi5pbmRleDtcbiAgY29uc3QgcHJvcG9zZWRJbmRleCA9IGlzTW92aW5nRm9yd2FyZCA/IGN1cnJlbnRJbmRleCArIDEgOiBjdXJyZW50SW5kZXggLSAxO1xuICBjb25zdCBmaXJzdEluZGV4ID0gaW5zaWRlRGVzdGluYXRpb25bMF0uZGVzY3JpcHRvci5pbmRleDtcbiAgY29uc3QgbGFzdEluZGV4ID0gaW5zaWRlRGVzdGluYXRpb25baW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoIC0gMV0uZGVzY3JpcHRvci5pbmRleDtcbiAgY29uc3QgdXBwZXJCb3VuZCA9IGlzSW5Ib21lTGlzdCA/IGxhc3RJbmRleCA6IGxhc3RJbmRleCArIDE7XG4gIGlmIChwcm9wb3NlZEluZGV4IDwgZmlyc3RJbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwcm9wb3NlZEluZGV4ID4gdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwcm9wb3NlZEluZGV4O1xufTtcblxudmFyIG1vdmVUb05leHRJbmRleCA9ICh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgaXNJbkhvbWVMaXN0LFxuICBkcmFnZ2FibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgcHJldmlvdXNJbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IHdhc0F0ID0gcHJldmlvdXNJbXBhY3QuYXQ7XG4gICF3YXNBdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBtb3ZlIGluIGRpcmVjdGlvbiB3aXRob3V0IHByZXZpb3VzIGltcGFjdCBsb2NhdGlvbicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGlmICh3YXNBdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICBjb25zdCBuZXdJbmRleCA9IGZyb21SZW9yZGVyKHtcbiAgICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICAgIGlzSW5Ib21lTGlzdCxcbiAgICAgIGxvY2F0aW9uOiB3YXNBdC5kZXN0aW5hdGlvbixcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uXG4gICAgfSk7XG4gICAgaWYgKG5ld0luZGV4ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBsYXN0OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgICBkaXNwbGFjZWRCeTogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgICBpbmRleDogbmV3SW5kZXhcbiAgICB9KTtcbiAgfVxuICBjb25zdCBuZXdJbmRleCA9IGZyb21Db21iaW5lKHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZGlzcGxhY2VkOiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBjb21iaW5lOiB3YXNBdC5jb21iaW5lLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGlmIChuZXdJbmRleCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgIGRyYWdnYWJsZSxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydCxcbiAgICBsYXN0OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnk6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIGluZGV4OiBuZXdJbmRleFxuICB9KTtcbn07XG5cbnZhciBnZXRDb21iaW5lZEl0ZW1EaXNwbGFjZW1lbnQgPSAoe1xuICBkaXNwbGFjZWQsXG4gIGFmdGVyQ3JpdGljYWwsXG4gIGNvbWJpbmVXaXRoLFxuICBkaXNwbGFjZWRCeVxufSkgPT4ge1xuICBjb25zdCBpc0Rpc3BsYWNlZCA9IEJvb2xlYW4oZGlzcGxhY2VkLnZpc2libGVbY29tYmluZVdpdGhdIHx8IGRpc3BsYWNlZC5pbnZpc2libGVbY29tYmluZVdpdGhdKTtcbiAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjb21iaW5lV2l0aCwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICByZXR1cm4gaXNEaXNwbGFjZWQgPyBvcmlnaW4gOiBuZWdhdGUoZGlzcGxhY2VkQnkucG9pbnQpO1xuICB9XG4gIHJldHVybiBpc0Rpc3BsYWNlZCA/IGRpc3BsYWNlZEJ5LnBvaW50IDogb3JpZ2luO1xufTtcblxudmFyIHdoZW5Db21iaW5pbmcgPSAoe1xuICBhZnRlckNyaXRpY2FsLFxuICBpbXBhY3QsXG4gIGRyYWdnYWJsZXNcbn0pID0+IHtcbiAgY29uc3QgY29tYmluZSA9IHRyeUdldENvbWJpbmUoaW1wYWN0KTtcbiAgIWNvbWJpbmUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBjb21iaW5lV2l0aCA9IGNvbWJpbmUuZHJhZ2dhYmxlSWQ7XG4gIGNvbnN0IGNlbnRlciA9IGRyYWdnYWJsZXNbY29tYmluZVdpdGhdLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgY29uc3QgZGlzcGxhY2VCeSA9IGdldENvbWJpbmVkSXRlbURpc3BsYWNlbWVudCh7XG4gICAgZGlzcGxhY2VkOiBpbXBhY3QuZGlzcGxhY2VkLFxuICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgY29tYmluZVdpdGgsXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeVxuICB9KTtcbiAgcmV0dXJuIGFkZChjZW50ZXIsIGRpc3BsYWNlQnkpO1xufTtcblxuY29uc3QgZGlzdGFuY2VGcm9tU3RhcnRUb0JvcmRlckJveENlbnRlciA9IChheGlzLCBib3gpID0+IGJveC5tYXJnaW5bYXhpcy5zdGFydF0gKyBib3guYm9yZGVyQm94W2F4aXMuc2l6ZV0gLyAyO1xuY29uc3QgZGlzdGFuY2VGcm9tRW5kVG9Cb3JkZXJCb3hDZW50ZXIgPSAoYXhpcywgYm94KSA9PiBib3gubWFyZ2luW2F4aXMuZW5kXSArIGJveC5ib3JkZXJCb3hbYXhpcy5zaXplXSAvIDI7XG5jb25zdCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIgPSAoYXhpcywgdGFyZ2V0LCBpc01vdmluZykgPT4gdGFyZ2V0W2F4aXMuY3Jvc3NBeGlzU3RhcnRdICsgaXNNb3ZpbmcubWFyZ2luW2F4aXMuY3Jvc3NBeGlzU3RhcnRdICsgaXNNb3ZpbmcuYm9yZGVyQm94W2F4aXMuY3Jvc3NBeGlzU2l6ZV0gLyAyO1xuY29uc3QgZ29BZnRlciA9ICh7XG4gIGF4aXMsXG4gIG1vdmVSZWxhdGl2ZVRvLFxuICBpc01vdmluZ1xufSkgPT4gcGF0Y2goYXhpcy5saW5lLCBtb3ZlUmVsYXRpdmVUby5tYXJnaW5Cb3hbYXhpcy5lbmRdICsgZGlzdGFuY2VGcm9tU3RhcnRUb0JvcmRlckJveENlbnRlcihheGlzLCBpc01vdmluZyksIGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlcihheGlzLCBtb3ZlUmVsYXRpdmVUby5tYXJnaW5Cb3gsIGlzTW92aW5nKSk7XG5jb25zdCBnb0JlZm9yZSA9ICh7XG4gIGF4aXMsXG4gIG1vdmVSZWxhdGl2ZVRvLFxuICBpc01vdmluZ1xufSkgPT4gcGF0Y2goYXhpcy5saW5lLCBtb3ZlUmVsYXRpdmVUby5tYXJnaW5Cb3hbYXhpcy5zdGFydF0gLSBkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlcihheGlzLCBpc01vdmluZyksIGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlcihheGlzLCBtb3ZlUmVsYXRpdmVUby5tYXJnaW5Cb3gsIGlzTW92aW5nKSk7XG5jb25zdCBnb0ludG9TdGFydCA9ICh7XG4gIGF4aXMsXG4gIG1vdmVJbnRvLFxuICBpc01vdmluZ1xufSkgPT4gcGF0Y2goYXhpcy5saW5lLCBtb3ZlSW50by5jb250ZW50Qm94W2F4aXMuc3RhcnRdICsgZGlzdGFuY2VGcm9tU3RhcnRUb0JvcmRlckJveENlbnRlcihheGlzLCBpc01vdmluZyksIGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlcihheGlzLCBtb3ZlSW50by5jb250ZW50Qm94LCBpc01vdmluZykpO1xuXG52YXIgd2hlblJlb3JkZXJpbmcgPSAoe1xuICBpbXBhY3QsXG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlLFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IGRyYWdnYWJsZVBhZ2UgPSBkcmFnZ2FibGUucGFnZTtcbiAgY29uc3QgYXhpcyA9IGRyb3BwYWJsZS5heGlzO1xuICBpZiAoIWluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgIHJldHVybiBnb0ludG9TdGFydCh7XG4gICAgICBheGlzLFxuICAgICAgbW92ZUludG86IGRyb3BwYWJsZS5wYWdlLFxuICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7XG4gICAgZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5XG4gIH0gPSBpbXBhY3Q7XG4gIGNvbnN0IGNsb3Nlc3RBZnRlciA9IGRpc3BsYWNlZC5hbGxbMF07XG4gIGlmIChjbG9zZXN0QWZ0ZXIpIHtcbiAgICBjb25zdCBjbG9zZXN0ID0gZHJhZ2dhYmxlc1tjbG9zZXN0QWZ0ZXJdO1xuICAgIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwoY2xvc2VzdEFmdGVyLCBhZnRlckNyaXRpY2FsKSkge1xuICAgICAgcmV0dXJuIGdvQmVmb3JlKHtcbiAgICAgICAgYXhpcyxcbiAgICAgICAgbW92ZVJlbGF0aXZlVG86IGNsb3Nlc3QucGFnZSxcbiAgICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB3aXRoRGlzcGxhY2VtZW50ID0gb2Zmc2V0KGNsb3Nlc3QucGFnZSwgZGlzcGxhY2VkQnkucG9pbnQpO1xuICAgIHJldHVybiBnb0JlZm9yZSh7XG4gICAgICBheGlzLFxuICAgICAgbW92ZVJlbGF0aXZlVG86IHdpdGhEaXNwbGFjZW1lbnQsXG4gICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBpbnNpZGVEZXN0aW5hdGlvbltpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3QuZGVzY3JpcHRvci5pZCA9PT0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQpIHtcbiAgICByZXR1cm4gZHJhZ2dhYmxlUGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICB9XG4gIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwobGFzdC5kZXNjcmlwdG9yLmlkLCBhZnRlckNyaXRpY2FsKSkge1xuICAgIGNvbnN0IHBhZ2UgPSBvZmZzZXQobGFzdC5wYWdlLCBuZWdhdGUoYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCkpO1xuICAgIHJldHVybiBnb0FmdGVyKHtcbiAgICAgIGF4aXMsXG4gICAgICBtb3ZlUmVsYXRpdmVUbzogcGFnZSxcbiAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGdvQWZ0ZXIoe1xuICAgIGF4aXMsXG4gICAgbW92ZVJlbGF0aXZlVG86IGxhc3QucGFnZSxcbiAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICB9KTtcbn07XG5cbnZhciB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50ID0gKGRyb3BwYWJsZSwgcG9pbnQpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cbiAgcmV0dXJuIGFkZChwb2ludCwgZnJhbWUuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50KTtcbn07XG5cbmNvbnN0IGdldFJlc3VsdFdpdGhvdXREcm9wcGFibGVEaXNwbGFjZW1lbnQgPSAoe1xuICBpbXBhY3QsXG4gIGRyYWdnYWJsZSxcbiAgZHJvcHBhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgY29uc3QgYXQgPSBpbXBhY3QuYXQ7XG4gIGlmICghZHJvcHBhYmxlKSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsO1xuICB9XG4gIGlmICghYXQpIHtcbiAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cbiAgaWYgKGF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiB3aGVuUmVvcmRlcmluZyh7XG4gICAgICBpbXBhY3QsXG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBkcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlLFxuICAgICAgYWZ0ZXJDcml0aWNhbFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB3aGVuQ29tYmluaW5nKHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xufTtcbnZhciBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCA9IGFyZ3MgPT4ge1xuICBjb25zdCB3aXRob3V0RGlzcGxhY2VtZW50ID0gZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudChhcmdzKTtcbiAgY29uc3QgZHJvcHBhYmxlID0gYXJncy5kcm9wcGFibGU7XG4gIGNvbnN0IHdpdGhEaXNwbGFjZW1lbnQgPSBkcm9wcGFibGUgPyB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50KGRyb3BwYWJsZSwgd2l0aG91dERpc3BsYWNlbWVudCkgOiB3aXRob3V0RGlzcGxhY2VtZW50O1xuICByZXR1cm4gd2l0aERpc3BsYWNlbWVudDtcbn07XG5cbnZhciBzY3JvbGxWaWV3cG9ydCA9ICh2aWV3cG9ydCwgbmV3U2Nyb2xsKSA9PiB7XG4gIGNvbnN0IGRpZmYgPSBzdWJ0cmFjdChuZXdTY3JvbGwsIHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsKTtcbiAgY29uc3QgZGlzcGxhY2VtZW50ID0gbmVnYXRlKGRpZmYpO1xuICBjb25zdCBmcmFtZSA9IGdldFJlY3Qoe1xuICAgIHRvcDogbmV3U2Nyb2xsLnksXG4gICAgYm90dG9tOiBuZXdTY3JvbGwueSArIHZpZXdwb3J0LmZyYW1lLmhlaWdodCxcbiAgICBsZWZ0OiBuZXdTY3JvbGwueCxcbiAgICByaWdodDogbmV3U2Nyb2xsLnggKyB2aWV3cG9ydC5mcmFtZS53aWR0aFxuICB9KTtcbiAgY29uc3QgdXBkYXRlZCA9IHtcbiAgICBmcmFtZSxcbiAgICBzY3JvbGw6IHtcbiAgICAgIGluaXRpYWw6IHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsLFxuICAgICAgbWF4OiB2aWV3cG9ydC5zY3JvbGwubWF4LFxuICAgICAgY3VycmVudDogbmV3U2Nyb2xsLFxuICAgICAgZGlmZjoge1xuICAgICAgICB2YWx1ZTogZGlmZixcbiAgICAgICAgZGlzcGxhY2VtZW50XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gdXBkYXRlZDtcbn07XG5cbmZ1bmN0aW9uIGdldERyYWdnYWJsZXMkMShpZHMsIGRyYWdnYWJsZXMpIHtcbiAgcmV0dXJuIGlkcy5tYXAoaWQgPT4gZHJhZ2dhYmxlc1tpZF0pO1xufVxuZnVuY3Rpb24gdHJ5R2V0VmlzaWJsZShpZCwgZ3JvdXBzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gZ3JvdXBzW2ldLnZpc2libGVbaWRdO1xuICAgIGlmIChkaXNwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxudmFyIHNwZWN1bGF0aXZlbHlJbmNyZWFzZSA9ICh7XG4gIGltcGFjdCxcbiAgdmlld3BvcnQsXG4gIGRlc3RpbmF0aW9uLFxuICBkcmFnZ2FibGVzLFxuICBtYXhTY3JvbGxDaGFuZ2Vcbn0pID0+IHtcbiAgY29uc3Qgc2Nyb2xsZWRWaWV3cG9ydCA9IHNjcm9sbFZpZXdwb3J0KHZpZXdwb3J0LCBhZGQodmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQsIG1heFNjcm9sbENoYW5nZSkpO1xuICBjb25zdCBzY3JvbGxlZERyb3BwYWJsZSA9IGRlc3RpbmF0aW9uLmZyYW1lID8gc2Nyb2xsRHJvcHBhYmxlKGRlc3RpbmF0aW9uLCBhZGQoZGVzdGluYXRpb24uZnJhbWUuc2Nyb2xsLmN1cnJlbnQsIG1heFNjcm9sbENoYW5nZSkpIDogZGVzdGluYXRpb247XG4gIGNvbnN0IGxhc3QgPSBpbXBhY3QuZGlzcGxhY2VkO1xuICBjb25zdCB3aXRoVmlld3BvcnRTY3JvbGwgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGdldERyYWdnYWJsZXMkMShsYXN0LmFsbCwgZHJhZ2dhYmxlcyksXG4gICAgZGVzdGluYXRpb24sXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICB2aWV3cG9ydDogc2Nyb2xsZWRWaWV3cG9ydC5mcmFtZSxcbiAgICBsYXN0LFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IHdpdGhEcm9wcGFibGVTY3JvbGwgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGdldERyYWdnYWJsZXMkMShsYXN0LmFsbCwgZHJhZ2dhYmxlcyksXG4gICAgZGVzdGluYXRpb246IHNjcm9sbGVkRHJvcHBhYmxlLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGxhc3QsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgaW52aXNpYmxlID0ge307XG4gIGNvbnN0IHZpc2libGUgPSB7fTtcbiAgY29uc3QgZ3JvdXBzID0gW2xhc3QsIHdpdGhWaWV3cG9ydFNjcm9sbCwgd2l0aERyb3BwYWJsZVNjcm9sbF07XG4gIGxhc3QuYWxsLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRyeUdldFZpc2libGUoaWQsIGdyb3Vwcyk7XG4gICAgaWYgKGRpc3BsYWNlbWVudCkge1xuICAgICAgdmlzaWJsZVtpZF0gPSBkaXNwbGFjZW1lbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmlzaWJsZVtpZF0gPSB0cnVlO1xuICB9KTtcbiAgY29uc3QgbmV3SW1wYWN0ID0ge1xuICAgIC4uLmltcGFjdCxcbiAgICBkaXNwbGFjZWQ6IHtcbiAgICAgIGFsbDogbGFzdC5hbGwsXG4gICAgICBpbnZpc2libGUsXG4gICAgICB2aXNpYmxlXG4gICAgfVxuICB9O1xuICByZXR1cm4gbmV3SW1wYWN0O1xufTtcblxudmFyIHdpdGhWaWV3cG9ydERpc3BsYWNlbWVudCA9ICh2aWV3cG9ydCwgcG9pbnQpID0+IGFkZCh2aWV3cG9ydC5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQsIHBvaW50KTtcblxudmFyIGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyID0gKHtcbiAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgZHJhZ2dhYmxlLFxuICB2aWV3cG9ydFxufSkgPT4ge1xuICBjb25zdCB3aXRob3V0UGFnZVNjcm9sbENoYW5nZSA9IHdpdGhWaWV3cG9ydERpc3BsYWNlbWVudCh2aWV3cG9ydCwgcGFnZUJvcmRlckJveENlbnRlcik7XG4gIGNvbnN0IG9mZnNldCA9IHN1YnRyYWN0KHdpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlLCBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyKTtcbiAgcmV0dXJuIGFkZChkcmFnZ2FibGUuY2xpZW50LmJvcmRlckJveC5jZW50ZXIsIG9mZnNldCk7XG59O1xuXG52YXIgaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24gPSAoe1xuICBkcmFnZ2FibGUsXG4gIGRlc3RpbmF0aW9uLFxuICBuZXdQYWdlQm9yZGVyQm94Q2VudGVyLFxuICB2aWV3cG9ydCxcbiAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCxcbiAgb25seU9uTWFpbkF4aXMgPSBmYWxzZVxufSkgPT4ge1xuICBjb25zdCBjaGFuZ2VOZWVkZWQgPSBzdWJ0cmFjdChuZXdQYWdlQm9yZGVyQm94Q2VudGVyLCBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyKTtcbiAgY29uc3Qgc2hpZnRlZCA9IG9mZnNldEJ5UG9zaXRpb24oZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LCBjaGFuZ2VOZWVkZWQpO1xuICBjb25zdCBhcmdzID0ge1xuICAgIHRhcmdldDogc2hpZnRlZCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50LFxuICAgIHZpZXdwb3J0XG4gIH07XG4gIHJldHVybiBvbmx5T25NYWluQXhpcyA/IGlzVG90YWxseVZpc2libGVPbkF4aXMoYXJncykgOiBpc1RvdGFsbHlWaXNpYmxlKGFyZ3MpO1xufTtcblxudmFyIG1vdmVUb05leHRQbGFjZSA9ICh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgZHJhZ2dhYmxlLFxuICBkZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlcyxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIHByZXZpb3VzQ2xpZW50U2VsZWN0aW9uLFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGlmICghZGVzdGluYXRpb24uaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBpc0luSG9tZUxpc3QgPSBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKTtcbiAgY29uc3QgaW1wYWN0ID0gbW92ZVRvTmV4dENvbWJpbmUoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgcHJldmlvdXNJbXBhY3RcbiAgfSkgfHwgbW92ZVRvTmV4dEluZGV4KHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgaXNJbkhvbWVMaXN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGlmICghaW1wYWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID0gaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24oe1xuICAgIGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBuZXdQYWdlQm9yZGVyQm94Q2VudGVyOiBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiBmYWxzZSxcbiAgICBvbmx5T25NYWluQXhpczogdHJ1ZVxuICB9KTtcbiAgaWYgKGlzVmlzaWJsZUluTmV3TG9jYXRpb24pIHtcbiAgICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgdmlld3BvcnRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50U2VsZWN0aW9uLFxuICAgICAgaW1wYWN0LFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRpc3RhbmNlID0gc3VidHJhY3QocGFnZUJvcmRlckJveENlbnRlciwgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyKTtcbiAgY29uc3QgY2F1dGlvdXMgPSBzcGVjdWxhdGl2ZWx5SW5jcmVhc2Uoe1xuICAgIGltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIG1heFNjcm9sbENoYW5nZTogZGlzdGFuY2VcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2xpZW50U2VsZWN0aW9uOiBwcmV2aW91c0NsaWVudFNlbGVjdGlvbixcbiAgICBpbXBhY3Q6IGNhdXRpb3VzLFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBkaXN0YW5jZVxuICB9O1xufTtcblxuY29uc3QgZ2V0S25vd25BY3RpdmUgPSBkcm9wcGFibGUgPT4ge1xuICBjb25zdCByZWN0ID0gZHJvcHBhYmxlLnN1YmplY3QuYWN0aXZlO1xuICAhcmVjdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBnZXQgY2xpcHBlZCBhcmVhIGZyb20gZHJvcHBhYmxlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHJlY3Q7XG59O1xudmFyIGdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUgPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIHNvdXJjZSxcbiAgZHJvcHBhYmxlcyxcbiAgdmlld3BvcnRcbn0pID0+IHtcbiAgY29uc3QgYWN0aXZlID0gc291cmNlLnN1YmplY3QuYWN0aXZlO1xuICBpZiAoIWFjdGl2ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGF4aXMgPSBzb3VyY2UuYXhpcztcbiAgY29uc3QgaXNCZXR3ZWVuU291cmNlQ2xpcHBlZCA9IGlzV2l0aGluKGFjdGl2ZVtheGlzLnN0YXJ0XSwgYWN0aXZlW2F4aXMuZW5kXSk7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSB0b0Ryb3BwYWJsZUxpc3QoZHJvcHBhYmxlcykuZmlsdGVyKGRyb3BwYWJsZSA9PiBkcm9wcGFibGUgIT09IHNvdXJjZSkuZmlsdGVyKGRyb3BwYWJsZSA9PiBkcm9wcGFibGUuaXNFbmFibGVkKS5maWx0ZXIoZHJvcHBhYmxlID0+IEJvb2xlYW4oZHJvcHBhYmxlLnN1YmplY3QuYWN0aXZlKSkuZmlsdGVyKGRyb3BwYWJsZSA9PiBpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWUodmlld3BvcnQuZnJhbWUpKGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSkpKS5maWx0ZXIoZHJvcHBhYmxlID0+IHtcbiAgICBjb25zdCBhY3RpdmVPZlRhcmdldCA9IGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSk7XG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZVtheGlzLmNyb3NzQXhpc0VuZF0gPCBhY3RpdmVPZlRhcmdldFtheGlzLmNyb3NzQXhpc0VuZF07XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVPZlRhcmdldFtheGlzLmNyb3NzQXhpc1N0YXJ0XSA8IGFjdGl2ZVtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcbiAgfSkuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gICAgY29uc3QgYWN0aXZlT2ZUYXJnZXQgPSBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpO1xuICAgIGNvbnN0IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZCA9IGlzV2l0aGluKGFjdGl2ZU9mVGFyZ2V0W2F4aXMuc3RhcnRdLCBhY3RpdmVPZlRhcmdldFtheGlzLmVuZF0pO1xuICAgIHJldHVybiBpc0JldHdlZW5Tb3VyY2VDbGlwcGVkKGFjdGl2ZU9mVGFyZ2V0W2F4aXMuc3RhcnRdKSB8fCBpc0JldHdlZW5Tb3VyY2VDbGlwcGVkKGFjdGl2ZU9mVGFyZ2V0W2F4aXMuZW5kXSkgfHwgaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkKGFjdGl2ZVtheGlzLnN0YXJ0XSkgfHwgaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkKGFjdGl2ZVtheGlzLmVuZF0pO1xuICB9KS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgZmlyc3QgPSBnZXRLbm93bkFjdGl2ZShhKVtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcbiAgICBjb25zdCBzZWNvbmQgPSBnZXRLbm93bkFjdGl2ZShiKVtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcbiAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICByZXR1cm4gZmlyc3QgLSBzZWNvbmQ7XG4gICAgfVxuICAgIHJldHVybiBzZWNvbmQgLSBmaXJzdDtcbiAgfSkuZmlsdGVyKChkcm9wcGFibGUsIGluZGV4LCBhcnJheSkgPT4gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKVtheGlzLmNyb3NzQXhpc1N0YXJ0XSA9PT0gZ2V0S25vd25BY3RpdmUoYXJyYXlbMF0pW2F4aXMuY3Jvc3NBeGlzU3RhcnRdKTtcbiAgaWYgKCFjYW5kaWRhdGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjYW5kaWRhdGVzWzBdO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5zID0gY2FuZGlkYXRlcy5maWx0ZXIoZHJvcHBhYmxlID0+IHtcbiAgICBjb25zdCBpc1dpdGhpbkRyb3BwYWJsZSA9IGlzV2l0aGluKGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSlbYXhpcy5zdGFydF0sIGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSlbYXhpcy5lbmRdKTtcbiAgICByZXR1cm4gaXNXaXRoaW5Ecm9wcGFibGUocGFnZUJvcmRlckJveENlbnRlcltheGlzLmxpbmVdKTtcbiAgfSk7XG4gIGlmIChjb250YWlucy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY29udGFpbnNbMF07XG4gIH1cbiAgaWYgKGNvbnRhaW5zLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gY29udGFpbnMuc29ydCgoYSwgYikgPT4gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5zdGFydF0gLSBnZXRLbm93bkFjdGl2ZShiKVtheGlzLnN0YXJ0XSlbMF07XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGZpcnN0ID0gY2xvc2VzdCQxKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIGdldENvcm5lcnMoZ2V0S25vd25BY3RpdmUoYSkpKTtcbiAgICBjb25zdCBzZWNvbmQgPSBjbG9zZXN0JDEocGFnZUJvcmRlckJveENlbnRlciwgZ2V0Q29ybmVycyhnZXRLbm93bkFjdGl2ZShiKSkpO1xuICAgIGlmIChmaXJzdCAhPT0gc2Vjb25kKSB7XG4gICAgICByZXR1cm4gZmlyc3QgLSBzZWNvbmQ7XG4gICAgfVxuICAgIHJldHVybiBnZXRLbm93bkFjdGl2ZShhKVtheGlzLnN0YXJ0XSAtIGdldEtub3duQWN0aXZlKGIpW2F4aXMuc3RhcnRdO1xuICB9KVswXTtcbn07XG5cbmNvbnN0IGdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyID0gKGRyYWdnYWJsZSwgYWZ0ZXJDcml0aWNhbCkgPT4ge1xuICBjb25zdCBvcmlnaW5hbCA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIHJldHVybiBkaWRTdGFydEFmdGVyQ3JpdGljYWwoZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpID8gc3VidHJhY3Qob3JpZ2luYWwsIGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpIDogb3JpZ2luYWw7XG59O1xuY29uc3QgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3ggPSAoZHJhZ2dhYmxlLCBhZnRlckNyaXRpY2FsKSA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94O1xuICByZXR1cm4gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkLCBhZnRlckNyaXRpY2FsKSA/IG9mZnNldEJ5UG9zaXRpb24ob3JpZ2luYWwsIG5lZ2F0ZShhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KSkgOiBvcmlnaW5hbDtcbn07XG5cbnZhciBnZXRDbG9zZXN0RHJhZ2dhYmxlID0gKHtcbiAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgdmlld3BvcnQsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBzb3J0ZWQgPSBpbnNpZGVEZXN0aW5hdGlvbi5maWx0ZXIoZHJhZ2dhYmxlID0+IGlzVG90YWxseVZpc2libGUoe1xuICAgIHRhcmdldDogZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3goZHJhZ2dhYmxlLCBhZnRlckNyaXRpY2FsKSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogdHJ1ZVxuICB9KSkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGRpc3RhbmNlVG9BID0gZGlzdGFuY2UocGFnZUJvcmRlckJveENlbnRlciwgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudChkZXN0aW5hdGlvbiwgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIoYSwgYWZ0ZXJDcml0aWNhbCkpKTtcbiAgICBjb25zdCBkaXN0YW5jZVRvQiA9IGRpc3RhbmNlKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQoZGVzdGluYXRpb24sIGdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyKGIsIGFmdGVyQ3JpdGljYWwpKSk7XG4gICAgaWYgKGRpc3RhbmNlVG9BIDwgZGlzdGFuY2VUb0IpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGRpc3RhbmNlVG9CIDwgZGlzdGFuY2VUb0EpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4O1xuICB9KTtcbiAgcmV0dXJuIHNvcnRlZFswXSB8fCBudWxsO1xufTtcblxudmFyIGdldERpc3BsYWNlZEJ5ID0gbWVtb2l6ZU9uZShmdW5jdGlvbiBnZXREaXNwbGFjZWRCeShheGlzLCBkaXNwbGFjZUJ5KSB7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IGRpc3BsYWNlQnlbYXhpcy5saW5lXTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogZGlzcGxhY2VtZW50LFxuICAgIHBvaW50OiBwYXRjaChheGlzLmxpbmUsIGRpc3BsYWNlbWVudClcbiAgfTtcbn0pO1xuXG5jb25zdCBnZXRSZXF1aXJlZEdyb3d0aEZvclBsYWNlaG9sZGVyID0gKGRyb3BwYWJsZSwgcGxhY2Vob2xkZXJTaXplLCBkcmFnZ2FibGVzKSA9PiB7XG4gIGNvbnN0IGF4aXMgPSBkcm9wcGFibGUuYXhpcztcbiAgaWYgKGRyb3BwYWJsZS5kZXNjcmlwdG9yLm1vZGUgPT09ICd2aXJ0dWFsJykge1xuICAgIHJldHVybiBwYXRjaChheGlzLmxpbmUsIHBsYWNlaG9sZGVyU2l6ZVtheGlzLmxpbmVdKTtcbiAgfVxuICBjb25zdCBhdmFpbGFibGVTcGFjZSA9IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UuY29udGVudEJveFtheGlzLnNpemVdO1xuICBjb25zdCBpbnNpZGVEcm9wcGFibGUgPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3Qgc3BhY2VVc2VkID0gaW5zaWRlRHJvcHBhYmxlLnJlZHVjZSgoc3VtLCBkaW1lbnNpb24pID0+IHN1bSArIGRpbWVuc2lvbi5jbGllbnQubWFyZ2luQm94W2F4aXMuc2l6ZV0sIDApO1xuICBjb25zdCByZXF1aXJlZFNwYWNlID0gc3BhY2VVc2VkICsgcGxhY2Vob2xkZXJTaXplW2F4aXMubGluZV07XG4gIGNvbnN0IG5lZWRzVG9Hcm93QnkgPSByZXF1aXJlZFNwYWNlIC0gYXZhaWxhYmxlU3BhY2U7XG4gIGlmIChuZWVkc1RvR3Jvd0J5IDw9IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBuZWVkc1RvR3Jvd0J5KTtcbn07XG5jb25zdCB3aXRoTWF4U2Nyb2xsID0gKGZyYW1lLCBtYXgpID0+ICh7XG4gIC4uLmZyYW1lLFxuICBzY3JvbGw6IHtcbiAgICAuLi5mcmFtZS5zY3JvbGwsXG4gICAgbWF4XG4gIH1cbn0pO1xuY29uc3QgYWRkUGxhY2Vob2xkZXIgPSAoZHJvcHBhYmxlLCBkcmFnZ2FibGUsIGRyYWdnYWJsZXMpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gICEhaXNIb21lT2YoZHJhZ2dhYmxlLCBkcm9wcGFibGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIG5vdCBhZGQgcGxhY2Vob2xkZXIgc3BhY2UgdG8gaG9tZSBsaXN0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgISFkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgYWRkIHBsYWNlaG9sZGVyIHNpemUgdG8gYSBzdWJqZWN0IHdoZW4gaXQgYWxyZWFkeSBoYXMgb25lJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgcGxhY2Vob2xkZXJTaXplID0gZ2V0RGlzcGxhY2VkQnkoZHJvcHBhYmxlLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KS5wb2ludDtcbiAgY29uc3QgcmVxdWlyZWRHcm93dGggPSBnZXRSZXF1aXJlZEdyb3d0aEZvclBsYWNlaG9sZGVyKGRyb3BwYWJsZSwgcGxhY2Vob2xkZXJTaXplLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgYWRkZWQgPSB7XG4gICAgcGxhY2Vob2xkZXJTaXplLFxuICAgIGluY3JlYXNlZEJ5OiByZXF1aXJlZEdyb3d0aCxcbiAgICBvbGRGcmFtZU1heFNjcm9sbDogZHJvcHBhYmxlLmZyYW1lID8gZHJvcHBhYmxlLmZyYW1lLnNjcm9sbC5tYXggOiBudWxsXG4gIH07XG4gIGlmICghZnJhbWUpIHtcbiAgICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgICAgd2l0aFBsYWNlaG9sZGVyOiBhZGRlZCxcbiAgICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgICAgZnJhbWU6IGRyb3BwYWJsZS5mcmFtZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kcm9wcGFibGUsXG4gICAgICBzdWJqZWN0XG4gICAgfTtcbiAgfVxuICBjb25zdCBtYXhTY3JvbGwgPSByZXF1aXJlZEdyb3d0aCA/IGFkZChmcmFtZS5zY3JvbGwubWF4LCByZXF1aXJlZEdyb3d0aCkgOiBmcmFtZS5zY3JvbGwubWF4O1xuICBjb25zdCBuZXdGcmFtZSA9IHdpdGhNYXhTY3JvbGwoZnJhbWUsIG1heFNjcm9sbCk7XG4gIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogYWRkZWQsXG4gICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgZnJhbWU6IG5ld0ZyYW1lXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmRyb3BwYWJsZSxcbiAgICBzdWJqZWN0LFxuICAgIGZyYW1lOiBuZXdGcmFtZVxuICB9O1xufTtcbmNvbnN0IHJlbW92ZVBsYWNlaG9sZGVyID0gZHJvcHBhYmxlID0+IHtcbiAgY29uc3QgYWRkZWQgPSBkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXI7XG4gICFhZGRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCByZW1vdmUgcGxhY2Vob2xkZXIgZm9ybSBzdWJqZWN0IHdoZW4gdGhlcmUgd2FzIG5vbmUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICAgIGZyYW1lOiBudWxsLFxuICAgICAgd2l0aFBsYWNlaG9sZGVyOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRyb3BwYWJsZSxcbiAgICAgIHN1YmplY3RcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9sZE1heFNjcm9sbCA9IGFkZGVkLm9sZEZyYW1lTWF4U2Nyb2xsO1xuICAhb2xkTWF4U2Nyb2xsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZHJvcHBhYmxlIHdpdGggZnJhbWUgdG8gaGF2ZSBvbGQgbWF4IGZyYW1lIHNjcm9sbCB3aGVuIHJlbW92aW5nIHBsYWNlaG9sZGVyJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgbmV3RnJhbWUgPSB3aXRoTWF4U2Nyb2xsKGZyYW1lLCBvbGRNYXhTY3JvbGwpO1xuICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICBmcmFtZTogbmV3RnJhbWUsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBudWxsXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmRyb3BwYWJsZSxcbiAgICBzdWJqZWN0LFxuICAgIGZyYW1lOiBuZXdGcmFtZVxuICB9O1xufTtcblxudmFyIG1vdmVUb05ld0Ryb3BwYWJsZSA9ICh7XG4gIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgbW92ZVJlbGF0aXZlVG8sXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBkcmFnZ2FibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGRlc3RpbmF0aW9uLFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBpZiAoIW1vdmVSZWxhdGl2ZVRvKSB7XG4gICAgaWYgKGluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHByb3Bvc2VkID0ge1xuICAgICAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgICAgIGRpc3BsYWNlZEJ5OiBub0Rpc3BsYWNlZEJ5LFxuICAgICAgYXQ6IHtcbiAgICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLFxuICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByb3Bvc2VkUGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICAgIGltcGFjdDogcHJvcG9zZWQsXG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgICAgZHJhZ2dhYmxlcyxcbiAgICAgIGFmdGVyQ3JpdGljYWxcbiAgICB9KTtcbiAgICBjb25zdCB3aXRoUGxhY2Vob2xkZXIgPSBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKSA/IGRlc3RpbmF0aW9uIDogYWRkUGxhY2Vob2xkZXIoZGVzdGluYXRpb24sIGRyYWdnYWJsZSwgZHJhZ2dhYmxlcyk7XG4gICAgY29uc3QgaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiA9IGlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uKHtcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGRlc3RpbmF0aW9uOiB3aXRoUGxhY2Vob2xkZXIsXG4gICAgICBuZXdQYWdlQm9yZGVyQm94Q2VudGVyOiBwcm9wb3NlZFBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiBmYWxzZSxcbiAgICAgIG9ubHlPbk1haW5BeGlzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPyBwcm9wb3NlZCA6IG51bGw7XG4gIH1cbiAgY29uc3QgaXNHb2luZ0JlZm9yZVRhcmdldCA9IEJvb2xlYW4ocHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyW2Rlc3RpbmF0aW9uLmF4aXMubGluZV0gPD0gbW92ZVJlbGF0aXZlVG8ucGFnZS5ib3JkZXJCb3guY2VudGVyW2Rlc3RpbmF0aW9uLmF4aXMubGluZV0pO1xuICBjb25zdCBwcm9wb3NlZEluZGV4ID0gKCgpID0+IHtcbiAgICBjb25zdCByZWxhdGl2ZVRvID0gbW92ZVJlbGF0aXZlVG8uZGVzY3JpcHRvci5pbmRleDtcbiAgICBpZiAobW92ZVJlbGF0aXZlVG8uZGVzY3JpcHRvci5pZCA9PT0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQpIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZVRvO1xuICAgIH1cbiAgICBpZiAoaXNHb2luZ0JlZm9yZVRhcmdldCkge1xuICAgICAgcmV0dXJuIHJlbGF0aXZlVG87XG4gICAgfVxuICAgIHJldHVybiByZWxhdGl2ZVRvICsgMTtcbiAgfSkoKTtcbiAgY29uc3QgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShkZXN0aW5hdGlvbi5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgbGFzdDogZW1wdHlHcm91cHMsXG4gICAgaW5kZXg6IHByb3Bvc2VkSW5kZXhcbiAgfSk7XG59O1xuXG52YXIgbW92ZUNyb3NzQXhpcyA9ICh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICBkcmFnZ2FibGUsXG4gIGlzT3ZlcixcbiAgZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlcyxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgZGVzdGluYXRpb24gPSBnZXRCZXN0Q3Jvc3NBeGlzRHJvcHBhYmxlKHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgcGFnZUJvcmRlckJveENlbnRlcjogcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHNvdXJjZTogaXNPdmVyLFxuICAgIGRyb3BwYWJsZXMsXG4gICAgdmlld3BvcnRcbiAgfSk7XG4gIGlmICghZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IG1vdmVSZWxhdGl2ZVRvID0gZ2V0Q2xvc2VzdERyYWdnYWJsZSh7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcjogcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGltcGFjdCA9IG1vdmVUb05ld0Ryb3BwYWJsZSh7XG4gICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIG1vdmVSZWxhdGl2ZVRvLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGlmICghaW1wYWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgdmlld3BvcnRcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2xpZW50U2VsZWN0aW9uLFxuICAgIGltcGFjdCxcbiAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbFxuICB9O1xufTtcblxudmFyIHdoYXRJc0RyYWdnZWRPdmVyID0gaW1wYWN0ID0+IHtcbiAgY29uc3QgYXQgPSBpbXBhY3QuYXQ7XG4gIGlmICghYXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIGF0LmRlc3RpbmF0aW9uLmRyb3BwYWJsZUlkO1xuICB9XG4gIHJldHVybiBhdC5jb21iaW5lLmRyb3BwYWJsZUlkO1xufTtcblxuY29uc3QgZ2V0RHJvcHBhYmxlT3ZlciQxID0gKGltcGFjdCwgZHJvcHBhYmxlcykgPT4ge1xuICBjb25zdCBpZCA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIHJldHVybiBpZCA/IGRyb3BwYWJsZXNbaWRdIDogbnVsbDtcbn07XG52YXIgbW92ZUluRGlyZWN0aW9uID0gKHtcbiAgc3RhdGUsXG4gIHR5cGVcbn0pID0+IHtcbiAgY29uc3QgaXNBY3R1YWxseU92ZXIgPSBnZXREcm9wcGFibGVPdmVyJDEoc3RhdGUuaW1wYWN0LCBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXMpO1xuICBjb25zdCBpc01haW5BeGlzTW92ZW1lbnRBbGxvd2VkID0gQm9vbGVhbihpc0FjdHVhbGx5T3Zlcik7XG4gIGNvbnN0IGhvbWUgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJvcHBhYmxlLmlkXTtcbiAgY29uc3QgaXNPdmVyID0gaXNBY3R1YWxseU92ZXIgfHwgaG9tZTtcbiAgY29uc3QgZGlyZWN0aW9uID0gaXNPdmVyLmF4aXMuZGlyZWN0aW9uO1xuICBjb25zdCBpc01vdmluZ09uTWFpbkF4aXMgPSBkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgJiYgKHR5cGUgPT09ICdNT1ZFX1VQJyB8fCB0eXBlID09PSAnTU9WRV9ET1dOJykgfHwgZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgKHR5cGUgPT09ICdNT1ZFX0xFRlQnIHx8IHR5cGUgPT09ICdNT1ZFX1JJR0hUJyk7XG4gIGlmIChpc01vdmluZ09uTWFpbkF4aXMgJiYgIWlzTWFpbkF4aXNNb3ZlbWVudEFsbG93ZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpc01vdmluZ0ZvcndhcmQgPSB0eXBlID09PSAnTU9WRV9ET1dOJyB8fCB0eXBlID09PSAnTU9WRV9SSUdIVCc7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIgPSBzdGF0ZS5jdXJyZW50LnBhZ2UuYm9yZGVyQm94Q2VudGVyO1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzXG4gIH0gPSBzdGF0ZS5kaW1lbnNpb25zO1xuICByZXR1cm4gaXNNb3ZpbmdPbk1haW5BeGlzID8gbW92ZVRvTmV4dFBsYWNlKHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbjogaXNPdmVyLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIHByZXZpb3VzQ2xpZW50U2VsZWN0aW9uOiBzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb24sXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pIDogbW92ZUNyb3NzQXhpcyh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgaXNPdmVyLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnO1xufVxuXG5mdW5jdGlvbiBpc1Bvc2l0aW9uSW5GcmFtZShmcmFtZSkge1xuICBjb25zdCBpc1dpdGhpblZlcnRpY2FsID0gaXNXaXRoaW4oZnJhbWUudG9wLCBmcmFtZS5ib3R0b20pO1xuICBjb25zdCBpc1dpdGhpbkhvcml6b250YWwgPSBpc1dpdGhpbihmcmFtZS5sZWZ0LCBmcmFtZS5yaWdodCk7XG4gIHJldHVybiBmdW5jdGlvbiBydW4ocG9pbnQpIHtcbiAgICByZXR1cm4gaXNXaXRoaW5WZXJ0aWNhbChwb2ludC55KSAmJiBpc1dpdGhpbkhvcml6b250YWwocG9pbnQueCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEhhc092ZXJsYXAoZmlyc3QsIHNlY29uZCkge1xuICByZXR1cm4gZmlyc3QubGVmdCA8IHNlY29uZC5yaWdodCAmJiBmaXJzdC5yaWdodCA+IHNlY29uZC5sZWZ0ICYmIGZpcnN0LnRvcCA8IHNlY29uZC5ib3R0b20gJiYgZmlyc3QuYm90dG9tID4gc2Vjb25kLnRvcDtcbn1cbmZ1bmN0aW9uIGdldEZ1cnRoZXN0QXdheSh7XG4gIHBhZ2VCb3JkZXJCb3gsXG4gIGRyYWdnYWJsZSxcbiAgY2FuZGlkYXRlc1xufSkge1xuICBjb25zdCBzdGFydENlbnRlciA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIGNvbnN0IHNvcnRlZCA9IGNhbmRpZGF0ZXMubWFwKGNhbmRpZGF0ZSA9PiB7XG4gICAgY29uc3QgYXhpcyA9IGNhbmRpZGF0ZS5heGlzO1xuICAgIGNvbnN0IHRhcmdldCA9IHBhdGNoKGNhbmRpZGF0ZS5heGlzLmxpbmUsIHBhZ2VCb3JkZXJCb3guY2VudGVyW2F4aXMubGluZV0sIGNhbmRpZGF0ZS5wYWdlLmJvcmRlckJveC5jZW50ZXJbYXhpcy5jcm9zc0F4aXNMaW5lXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBjYW5kaWRhdGUuZGVzY3JpcHRvci5pZCxcbiAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZShzdGFydENlbnRlciwgdGFyZ2V0KVxuICAgIH07XG4gIH0pLnNvcnQoKGEsIGIpID0+IGIuZGlzdGFuY2UgLSBhLmRpc3RhbmNlKTtcbiAgcmV0dXJuIHNvcnRlZFswXSA/IHNvcnRlZFswXS5pZCA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXREcm9wcGFibGVPdmVyKHtcbiAgcGFnZUJvcmRlckJveCxcbiAgZHJhZ2dhYmxlLFxuICBkcm9wcGFibGVzXG59KSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSB0b0Ryb3BwYWJsZUxpc3QoZHJvcHBhYmxlcykuZmlsdGVyKGl0ZW0gPT4ge1xuICAgIGlmICghaXRlbS5pc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlID0gaXRlbS5zdWJqZWN0LmFjdGl2ZTtcbiAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWdldEhhc092ZXJsYXAocGFnZUJvcmRlckJveCwgYWN0aXZlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNQb3NpdGlvbkluRnJhbWUoYWN0aXZlKShwYWdlQm9yZGVyQm94LmNlbnRlcikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gaXRlbS5heGlzO1xuICAgIGNvbnN0IGNoaWxkQ2VudGVyID0gYWN0aXZlLmNlbnRlcltheGlzLmNyb3NzQXhpc0xpbmVdO1xuICAgIGNvbnN0IGNyb3NzQXhpc1N0YXJ0ID0gcGFnZUJvcmRlckJveFtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcbiAgICBjb25zdCBjcm9zc0F4aXNFbmQgPSBwYWdlQm9yZGVyQm94W2F4aXMuY3Jvc3NBeGlzRW5kXTtcbiAgICBjb25zdCBpc0NvbnRhaW5lZCA9IGlzV2l0aGluKGFjdGl2ZVtheGlzLmNyb3NzQXhpc1N0YXJ0XSwgYWN0aXZlW2F4aXMuY3Jvc3NBeGlzRW5kXSk7XG4gICAgY29uc3QgaXNTdGFydENvbnRhaW5lZCA9IGlzQ29udGFpbmVkKGNyb3NzQXhpc1N0YXJ0KTtcbiAgICBjb25zdCBpc0VuZENvbnRhaW5lZCA9IGlzQ29udGFpbmVkKGNyb3NzQXhpc0VuZCk7XG4gICAgaWYgKCFpc1N0YXJ0Q29udGFpbmVkICYmICFpc0VuZENvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc1N0YXJ0Q29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gY3Jvc3NBeGlzU3RhcnQgPCBjaGlsZENlbnRlcjtcbiAgICB9XG4gICAgcmV0dXJuIGNyb3NzQXhpc0VuZCA+IGNoaWxkQ2VudGVyO1xuICB9KTtcbiAgaWYgKCFjYW5kaWRhdGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjYW5kaWRhdGVzWzBdLmRlc2NyaXB0b3IuaWQ7XG4gIH1cbiAgcmV0dXJuIGdldEZ1cnRoZXN0QXdheSh7XG4gICAgcGFnZUJvcmRlckJveCxcbiAgICBkcmFnZ2FibGUsXG4gICAgY2FuZGlkYXRlc1xuICB9KTtcbn1cblxuY29uc3Qgb2Zmc2V0UmVjdEJ5UG9zaXRpb24gPSAocmVjdCwgcG9pbnQpID0+IGdldFJlY3Qob2Zmc2V0QnlQb3NpdGlvbihyZWN0LCBwb2ludCkpO1xuXG52YXIgd2l0aERyb3BwYWJsZVNjcm9sbCA9IChkcm9wcGFibGUsIGFyZWEpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gYXJlYTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UmVjdEJ5UG9zaXRpb24oYXJlYSwgZnJhbWUuc2Nyb2xsLmRpZmYudmFsdWUpO1xufTtcblxuZnVuY3Rpb24gZ2V0SXNEaXNwbGFjZWQoe1xuICBkaXNwbGFjZWQsXG4gIGlkXG59KSB7XG4gIHJldHVybiBCb29sZWFuKGRpc3BsYWNlZC52aXNpYmxlW2lkXSB8fCBkaXNwbGFjZWQuaW52aXNpYmxlW2lkXSk7XG59XG5cbmZ1bmN0aW9uIGF0SW5kZXgoe1xuICBkcmFnZ2FibGUsXG4gIGNsb3Nlc3QsXG4gIGluSG9tZUxpc3Rcbn0pIHtcbiAgaWYgKCFjbG9zZXN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleDtcbiAgfVxuICBpZiAoY2xvc2VzdC5kZXNjcmlwdG9yLmluZGV4ID4gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaW5kZXgpIHtcbiAgICByZXR1cm4gY2xvc2VzdC5kZXNjcmlwdG9yLmluZGV4IC0gMTtcbiAgfVxuICByZXR1cm4gY2xvc2VzdC5kZXNjcmlwdG9yLmluZGV4O1xufVxudmFyIGdldFJlb3JkZXJJbXBhY3QgPSAoe1xuICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbDogdGFyZ2V0UmVjdCxcbiAgZHJhZ2dhYmxlLFxuICBkZXN0aW5hdGlvbixcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGxhc3QsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IGF4aXMgPSBkZXN0aW5hdGlvbi5heGlzO1xuICBjb25zdCBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGRlc3RpbmF0aW9uLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgY29uc3QgZGlzcGxhY2VtZW50ID0gZGlzcGxhY2VkQnkudmFsdWU7XG4gIGNvbnN0IHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFtheGlzLnN0YXJ0XTtcbiAgY29uc3QgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFtheGlzLmVuZF07XG4gIGNvbnN0IHdpdGhvdXREcmFnZ2luZyA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuICBjb25zdCBjbG9zZXN0ID0gd2l0aG91dERyYWdnaW5nLmZpbmQoY2hpbGQgPT4ge1xuICAgIGNvbnN0IGlkID0gY2hpbGQuZGVzY3JpcHRvci5pZDtcbiAgICBjb25zdCBjaGlsZENlbnRlciA9IGNoaWxkLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltheGlzLmxpbmVdO1xuICAgIGNvbnN0IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxID0gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGlkLCBhZnRlckNyaXRpY2FsKTtcbiAgICBjb25zdCBpc0Rpc3BsYWNlZCA9IGdldElzRGlzcGxhY2VkKHtcbiAgICAgIGRpc3BsYWNlZDogbGFzdCxcbiAgICAgIGlkXG4gICAgfSk7XG4gICAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxKSB7XG4gICAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEVuZCA8PSBjaGlsZENlbnRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRTdGFydCA8IGNoaWxkQ2VudGVyIC0gZGlzcGxhY2VtZW50O1xuICAgIH1cbiAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgIHJldHVybiB0YXJnZXRFbmQgPD0gY2hpbGRDZW50ZXIgKyBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRTdGFydCA8IGNoaWxkQ2VudGVyO1xuICB9KSB8fCBudWxsO1xuICBjb25zdCBuZXdJbmRleCA9IGF0SW5kZXgoe1xuICAgIGRyYWdnYWJsZSxcbiAgICBjbG9zZXN0LFxuICAgIGluSG9tZUxpc3Q6IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pXG4gIH0pO1xuICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIGxhc3QsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgaW5kZXg6IG5ld0luZGV4XG4gIH0pO1xufTtcblxuY29uc3QgY29tYmluZVRocmVzaG9sZERpdmlzb3IgPSA0O1xudmFyIGdldENvbWJpbmVJbXBhY3QgPSAoe1xuICBkcmFnZ2FibGUsXG4gIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsOiB0YXJnZXRSZWN0LFxuICBwcmV2aW91c0ltcGFjdCxcbiAgZGVzdGluYXRpb24sXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGlmICghZGVzdGluYXRpb24uaXNDb21iaW5lRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGF4aXMgPSBkZXN0aW5hdGlvbi5heGlzO1xuICBjb25zdCBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGRlc3RpbmF0aW9uLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgY29uc3QgZGlzcGxhY2VtZW50ID0gZGlzcGxhY2VkQnkudmFsdWU7XG4gIGNvbnN0IHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFtheGlzLnN0YXJ0XTtcbiAgY29uc3QgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFtheGlzLmVuZF07XG4gIGNvbnN0IHdpdGhvdXREcmFnZ2luZyA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuICBjb25zdCBjb21iaW5lV2l0aCA9IHdpdGhvdXREcmFnZ2luZy5maW5kKGNoaWxkID0+IHtcbiAgICBjb25zdCBpZCA9IGNoaWxkLmRlc2NyaXB0b3IuaWQ7XG4gICAgY29uc3QgY2hpbGRSZWN0ID0gY2hpbGQucGFnZS5ib3JkZXJCb3g7XG4gICAgY29uc3QgY2hpbGRTaXplID0gY2hpbGRSZWN0W2F4aXMuc2l6ZV07XG4gICAgY29uc3QgdGhyZXNob2xkID0gY2hpbGRTaXplIC8gY29tYmluZVRocmVzaG9sZERpdmlzb3I7XG4gICAgY29uc3QgZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoaWQsIGFmdGVyQ3JpdGljYWwpO1xuICAgIGNvbnN0IGlzRGlzcGxhY2VkID0gZ2V0SXNEaXNwbGFjZWQoe1xuICAgICAgZGlzcGxhY2VkOiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgICBpZFxuICAgIH0pO1xuICAgIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSkge1xuICAgICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRFbmQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gKyB0aHJlc2hvbGQgJiYgdGFyZ2V0RW5kIDwgY2hpbGRSZWN0W2F4aXMuZW5kXSAtIHRocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRTdGFydCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSAtIGRpc3BsYWNlbWVudCArIHRocmVzaG9sZCAmJiB0YXJnZXRTdGFydCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gLSBkaXNwbGFjZW1lbnQgLSB0aHJlc2hvbGQ7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgcmV0dXJuIHRhcmdldEVuZCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSArIGRpc3BsYWNlbWVudCArIHRocmVzaG9sZCAmJiB0YXJnZXRFbmQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdICsgZGlzcGxhY2VtZW50IC0gdGhyZXNob2xkO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gKyB0aHJlc2hvbGQgJiYgdGFyZ2V0U3RhcnQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdIC0gdGhyZXNob2xkO1xuICB9KTtcbiAgaWYgKCFjb21iaW5lV2l0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGltcGFjdCA9IHtcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBkaXNwbGFjZWQ6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ0NPTUJJTkUnLFxuICAgICAgY29tYmluZToge1xuICAgICAgICBkcmFnZ2FibGVJZDogY29tYmluZVdpdGguZGVzY3JpcHRvci5pZCxcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBpbXBhY3Q7XG59O1xuXG52YXIgZ2V0RHJhZ0ltcGFjdCA9ICh7XG4gIHBhZ2VPZmZzZXQsXG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlcyxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3ggPSBvZmZzZXRSZWN0QnlQb3NpdGlvbihkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3gsIHBhZ2VPZmZzZXQpO1xuICBjb25zdCBkZXN0aW5hdGlvbklkID0gZ2V0RHJvcHBhYmxlT3Zlcih7XG4gICAgcGFnZUJvcmRlckJveCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlc1xuICB9KTtcbiAgaWYgKCFkZXN0aW5hdGlvbklkKSB7XG4gICAgcmV0dXJuIG5vSW1wYWN0O1xuICB9XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZHJvcHBhYmxlc1tkZXN0aW5hdGlvbklkXTtcbiAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCA9IHdpdGhEcm9wcGFibGVTY3JvbGwoZGVzdGluYXRpb24sIHBhZ2VCb3JkZXJCb3gpO1xuICByZXR1cm4gZ2V0Q29tYmluZUltcGFjdCh7XG4gICAgcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGwsXG4gICAgZHJhZ2dhYmxlLFxuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSkgfHwgZ2V0UmVvcmRlckltcGFjdCh7XG4gICAgcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGwsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGxhc3Q6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xufTtcblxudmFyIHBhdGNoRHJvcHBhYmxlTWFwID0gKGRyb3BwYWJsZXMsIHVwZGF0ZWQpID0+ICh7XG4gIC4uLmRyb3BwYWJsZXMsXG4gIFt1cGRhdGVkLmRlc2NyaXB0b3IuaWRdOiB1cGRhdGVkXG59KTtcblxuY29uc3QgY2xlYXJVbnVzZWRQbGFjZWhvbGRlciA9ICh7XG4gIHByZXZpb3VzSW1wYWN0LFxuICBpbXBhY3QsXG4gIGRyb3BwYWJsZXNcbn0pID0+IHtcbiAgY29uc3QgbGFzdCA9IHdoYXRJc0RyYWdnZWRPdmVyKHByZXZpb3VzSW1wYWN0KTtcbiAgY29uc3Qgbm93ID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcbiAgaWYgKCFsYXN0KSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZXM7XG4gIH1cbiAgaWYgKGxhc3QgPT09IG5vdykge1xuICAgIHJldHVybiBkcm9wcGFibGVzO1xuICB9XG4gIGNvbnN0IGxhc3REcm9wcGFibGUgPSBkcm9wcGFibGVzW2xhc3RdO1xuICBpZiAoIWxhc3REcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlcztcbiAgfVxuICBjb25zdCB1cGRhdGVkID0gcmVtb3ZlUGxhY2Vob2xkZXIobGFzdERyb3BwYWJsZSk7XG4gIHJldHVybiBwYXRjaERyb3BwYWJsZU1hcChkcm9wcGFibGVzLCB1cGRhdGVkKTtcbn07XG52YXIgcmVjb21wdXRlUGxhY2Vob2xkZXJzID0gKHtcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkcm9wcGFibGVzLFxuICBwcmV2aW91c0ltcGFjdCxcbiAgaW1wYWN0XG59KSA9PiB7XG4gIGNvbnN0IGNsZWFuZWQgPSBjbGVhclVudXNlZFBsYWNlaG9sZGVyKHtcbiAgICBwcmV2aW91c0ltcGFjdCxcbiAgICBpbXBhY3QsXG4gICAgZHJvcHBhYmxlc1xuICB9KTtcbiAgY29uc3QgaXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcbiAgaWYgKCFpc092ZXIpIHtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuICBjb25zdCBkcm9wcGFibGUgPSBkcm9wcGFibGVzW2lzT3Zlcl07XG4gIGlmIChpc0hvbWVPZihkcmFnZ2FibGUsIGRyb3BwYWJsZSkpIHtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuICBpZiAoZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbiAgY29uc3QgcGF0Y2hlZCA9IGFkZFBsYWNlaG9sZGVyKGRyb3BwYWJsZSwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKTtcbiAgcmV0dXJuIHBhdGNoRHJvcHBhYmxlTWFwKGNsZWFuZWQsIHBhdGNoZWQpO1xufTtcblxudmFyIHVwZGF0ZSA9ICh7XG4gIHN0YXRlLFxuICBjbGllbnRTZWxlY3Rpb246IGZvcmNlZENsaWVudFNlbGVjdGlvbixcbiAgZGltZW5zaW9uczogZm9yY2VkRGltZW5zaW9ucyxcbiAgdmlld3BvcnQ6IGZvcmNlZFZpZXdwb3J0LFxuICBpbXBhY3Q6IGZvcmNlZEltcGFjdCxcbiAgc2Nyb2xsSnVtcFJlcXVlc3Rcbn0pID0+IHtcbiAgY29uc3Qgdmlld3BvcnQgPSBmb3JjZWRWaWV3cG9ydCB8fCBzdGF0ZS52aWV3cG9ydDtcbiAgY29uc3QgZGltZW5zaW9ucyA9IGZvcmNlZERpbWVuc2lvbnMgfHwgc3RhdGUuZGltZW5zaW9ucztcbiAgY29uc3QgY2xpZW50U2VsZWN0aW9uID0gZm9yY2VkQ2xpZW50U2VsZWN0aW9uIHx8IHN0YXRlLmN1cnJlbnQuY2xpZW50LnNlbGVjdGlvbjtcbiAgY29uc3Qgb2Zmc2V0ID0gc3VidHJhY3QoY2xpZW50U2VsZWN0aW9uLCBzdGF0ZS5pbml0aWFsLmNsaWVudC5zZWxlY3Rpb24pO1xuICBjb25zdCBjbGllbnQgPSB7XG4gICAgb2Zmc2V0LFxuICAgIHNlbGVjdGlvbjogY2xpZW50U2VsZWN0aW9uLFxuICAgIGJvcmRlckJveENlbnRlcjogYWRkKHN0YXRlLmluaXRpYWwuY2xpZW50LmJvcmRlckJveENlbnRlciwgb2Zmc2V0KVxuICB9O1xuICBjb25zdCBwYWdlID0ge1xuICAgIHNlbGVjdGlvbjogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50KSxcbiAgICBib3JkZXJCb3hDZW50ZXI6IGFkZChjbGllbnQuYm9yZGVyQm94Q2VudGVyLCB2aWV3cG9ydC5zY3JvbGwuY3VycmVudCksXG4gICAgb2Zmc2V0OiBhZGQoY2xpZW50Lm9mZnNldCwgdmlld3BvcnQuc2Nyb2xsLmRpZmYudmFsdWUpXG4gIH07XG4gIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgY2xpZW50LFxuICAgIHBhZ2VcbiAgfTtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBkaW1lbnNpb25zLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBjdXJyZW50XG4gICAgfTtcbiAgfVxuICBjb25zdCBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3QgbmV3SW1wYWN0ID0gZm9yY2VkSW1wYWN0IHx8IGdldERyYWdJbXBhY3Qoe1xuICAgIHBhZ2VPZmZzZXQ6IHBhZ2Uub2Zmc2V0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlczogZGltZW5zaW9ucy5kcm9wcGFibGVzLFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgY29uc3Qgd2l0aFVwZGF0ZWRQbGFjZWhvbGRlcnMgPSByZWNvbXB1dGVQbGFjZWhvbGRlcnMoe1xuICAgIGRyYWdnYWJsZSxcbiAgICBpbXBhY3Q6IG5ld0ltcGFjdCxcbiAgICBwcmV2aW91c0ltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXNcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBjdXJyZW50LFxuICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZXM6IHdpdGhVcGRhdGVkUGxhY2Vob2xkZXJzXG4gICAgfSxcbiAgICBpbXBhY3Q6IG5ld0ltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBzY3JvbGxKdW1wUmVxdWVzdDogc2Nyb2xsSnVtcFJlcXVlc3QgfHwgbnVsbCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IHNjcm9sbEp1bXBSZXF1ZXN0ID8gZmFsc2UgOiBudWxsXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBnZXREcmFnZ2FibGVzKGlkcywgZHJhZ2dhYmxlcykge1xuICByZXR1cm4gaWRzLm1hcChpZCA9PiBkcmFnZ2FibGVzW2lkXSk7XG59XG52YXIgcmVjb21wdXRlID0gKHtcbiAgaW1wYWN0LFxuICB2aWV3cG9ydCxcbiAgZHJhZ2dhYmxlcyxcbiAgZGVzdGluYXRpb24sXG4gIGZvcmNlU2hvdWxkQW5pbWF0ZVxufSkgPT4ge1xuICBjb25zdCBsYXN0ID0gaW1wYWN0LmRpc3BsYWNlZDtcbiAgY29uc3QgYWZ0ZXJEcmFnZ2luZyA9IGdldERyYWdnYWJsZXMobGFzdC5hbGwsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBkaXNwbGFjZWQgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmcsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlLFxuICAgIGxhc3RcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uaW1wYWN0LFxuICAgIGRpc3BsYWNlZFxuICB9O1xufTtcblxudmFyIGdldENsaWVudEJvcmRlckJveENlbnRlciA9ICh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkcm9wcGFibGUsXG4gIGRyYWdnYWJsZXMsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZSxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICByZXR1cm4gZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIoe1xuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIHZpZXdwb3J0XG4gIH0pO1xufTtcblxudmFyIHJlZnJlc2hTbmFwID0gKHtcbiAgc3RhdGUsXG4gIGRpbWVuc2lvbnM6IGZvcmNlZERpbWVuc2lvbnMsXG4gIHZpZXdwb3J0OiBmb3JjZWRWaWV3cG9ydFxufSkgPT4ge1xuICAhKHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCgpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IG5lZWRzVmlzaWJpbGl0eUNoZWNrID0gc3RhdGUuaW1wYWN0O1xuICBjb25zdCB2aWV3cG9ydCA9IGZvcmNlZFZpZXdwb3J0IHx8IHN0YXRlLnZpZXdwb3J0O1xuICBjb25zdCBkaW1lbnNpb25zID0gZm9yY2VkRGltZW5zaW9ucyB8fCBzdGF0ZS5kaW1lbnNpb25zO1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzXG4gIH0gPSBkaW1lbnNpb25zO1xuICBjb25zdCBkcmFnZ2FibGUgPSBkcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IGlzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKG5lZWRzVmlzaWJpbGl0eUNoZWNrKTtcbiAgIWlzT3ZlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgb3ZlciBhIGRlc3RpbmF0aW9uIGluIFNOQVAgbW92ZW1lbnQgbW9kZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZHJvcHBhYmxlc1tpc092ZXJdO1xuICBjb25zdCBpbXBhY3QgPSByZWNvbXB1dGUoe1xuICAgIGltcGFjdDogbmVlZHNWaXNpYmlsaXR5Q2hlY2ssXG4gICAgdmlld3BvcnQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlc1xuICB9KTtcbiAgY29uc3QgY2xpZW50U2VsZWN0aW9uID0gZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyKHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xuICByZXR1cm4gdXBkYXRlKHtcbiAgICBpbXBhY3QsXG4gICAgY2xpZW50U2VsZWN0aW9uLFxuICAgIHN0YXRlLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgdmlld3BvcnRcbiAgfSk7XG59O1xuXG52YXIgZ2V0SG9tZUxvY2F0aW9uID0gZGVzY3JpcHRvciA9PiAoe1xuICBpbmRleDogZGVzY3JpcHRvci5pbmRleCxcbiAgZHJvcHBhYmxlSWQ6IGRlc2NyaXB0b3IuZHJvcHBhYmxlSWRcbn0pO1xuXG52YXIgZ2V0TGlmdEVmZmVjdCA9ICh7XG4gIGRyYWdnYWJsZSxcbiAgaG9tZSxcbiAgZHJhZ2dhYmxlcyxcbiAgdmlld3BvcnRcbn0pID0+IHtcbiAgY29uc3QgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShob21lLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgY29uc3QgaW5zaWRlSG9tZSA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoaG9tZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgcmF3SW5kZXggPSBpbnNpZGVIb21lLmluZGV4T2YoZHJhZ2dhYmxlKTtcbiAgIShyYXdJbmRleCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZHJhZ2dhYmxlIHRvIGJlIGluc2lkZSBob21lIGxpc3QnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBhZnRlckRyYWdnaW5nID0gaW5zaWRlSG9tZS5zbGljZShyYXdJbmRleCArIDEpO1xuICBjb25zdCBlZmZlY3RlZCA9IGFmdGVyRHJhZ2dpbmcucmVkdWNlKChwcmV2aW91cywgaXRlbSkgPT4ge1xuICAgIHByZXZpb3VzW2l0ZW0uZGVzY3JpcHRvci5pZF0gPSB0cnVlO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfSwge30pO1xuICBjb25zdCBhZnRlckNyaXRpY2FsID0ge1xuICAgIGluVmlydHVhbExpc3Q6IGhvbWUuZGVzY3JpcHRvci5tb2RlID09PSAndmlydHVhbCcsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgZWZmZWN0ZWRcbiAgfTtcbiAgY29uc3QgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nLFxuICAgIGRlc3RpbmF0aW9uOiBob21lLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGxhc3Q6IG51bGwsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGltcGFjdCA9IHtcbiAgICBkaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgIGRlc3RpbmF0aW9uOiBnZXRIb21lTG9jYXRpb24oZHJhZ2dhYmxlLmRlc2NyaXB0b3IpXG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGltcGFjdCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH07XG59O1xuXG52YXIgcGF0Y2hEaW1lbnNpb25NYXAgPSAoZGltZW5zaW9ucywgdXBkYXRlZCkgPT4gKHtcbiAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICBkcm9wcGFibGVzOiBwYXRjaERyb3BwYWJsZU1hcChkaW1lbnNpb25zLmRyb3BwYWJsZXMsIHVwZGF0ZWQpXG59KTtcblxuY29uc3Qgc3RhcnQgPSBrZXkgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBmaW5pc2ggPSBrZXkgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBvZmZzZXREcmFnZ2FibGUgPSAoe1xuICBkcmFnZ2FibGUsXG4gIG9mZnNldDogb2Zmc2V0JDEsXG4gIGluaXRpYWxXaW5kb3dTY3JvbGxcbn0pID0+IHtcbiAgY29uc3QgY2xpZW50ID0gb2Zmc2V0KGRyYWdnYWJsZS5jbGllbnQsIG9mZnNldCQxKTtcbiAgY29uc3QgcGFnZSA9IHdpdGhTY3JvbGwoY2xpZW50LCBpbml0aWFsV2luZG93U2Nyb2xsKTtcbiAgY29uc3QgbW92ZWQgPSB7XG4gICAgLi4uZHJhZ2dhYmxlLFxuICAgIHBsYWNlaG9sZGVyOiB7XG4gICAgICAuLi5kcmFnZ2FibGUucGxhY2Vob2xkZXIsXG4gICAgICBjbGllbnRcbiAgICB9LFxuICAgIGNsaWVudCxcbiAgICBwYWdlXG4gIH07XG4gIHJldHVybiBtb3ZlZDtcbn07XG5cbnZhciBnZXRGcmFtZSA9IGRyb3BwYWJsZSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICAhZnJhbWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBEcm9wcGFibGUgdG8gaGF2ZSBhIGZyYW1lJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGZyYW1lO1xufTtcblxudmFyIGFkanVzdEFkZGl0aW9uc0ZvclNjcm9sbENoYW5nZXMgPSAoe1xuICBhZGRpdGlvbnMsXG4gIHVwZGF0ZWREcm9wcGFibGVzLFxuICB2aWV3cG9ydFxufSkgPT4ge1xuICBjb25zdCB3aW5kb3dTY3JvbGxDaGFuZ2UgPSB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZTtcbiAgcmV0dXJuIGFkZGl0aW9ucy5tYXAoZHJhZ2dhYmxlID0+IHtcbiAgICBjb25zdCBkcm9wcGFibGVJZCA9IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkO1xuICAgIGNvbnN0IG1vZGlmaWVkID0gdXBkYXRlZERyb3BwYWJsZXNbZHJvcHBhYmxlSWRdO1xuICAgIGNvbnN0IGZyYW1lID0gZ2V0RnJhbWUobW9kaWZpZWQpO1xuICAgIGNvbnN0IGRyb3BwYWJsZVNjcm9sbENoYW5nZSA9IGZyYW1lLnNjcm9sbC5kaWZmLnZhbHVlO1xuICAgIGNvbnN0IHRvdGFsQ2hhbmdlID0gYWRkKHdpbmRvd1Njcm9sbENoYW5nZSwgZHJvcHBhYmxlU2Nyb2xsQ2hhbmdlKTtcbiAgICBjb25zdCBtb3ZlZCA9IG9mZnNldERyYWdnYWJsZSh7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBvZmZzZXQ6IHRvdGFsQ2hhbmdlLFxuICAgICAgaW5pdGlhbFdpbmRvd1Njcm9sbDogdmlld3BvcnQuc2Nyb2xsLmluaXRpYWxcbiAgICB9KTtcbiAgICByZXR1cm4gbW92ZWQ7XG4gIH0pO1xufTtcblxudmFyIHB1Ymxpc2hXaGlsZURyYWdnaW5nSW5WaXJ0dWFsID0gKHtcbiAgc3RhdGUsXG4gIHB1Ymxpc2hlZFxufSkgPT4ge1xuICBzdGFydCgpO1xuICBjb25zdCB3aXRoU2Nyb2xsQ2hhbmdlID0gcHVibGlzaGVkLm1vZGlmaWVkLm1hcCh1cGRhdGUgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW3VwZGF0ZS5kcm9wcGFibGVJZF07XG4gICAgY29uc3Qgc2Nyb2xsZWQgPSBzY3JvbGxEcm9wcGFibGUoZXhpc3RpbmcsIHVwZGF0ZS5zY3JvbGwpO1xuICAgIHJldHVybiBzY3JvbGxlZDtcbiAgfSk7XG4gIGNvbnN0IGRyb3BwYWJsZXMgPSB7XG4gICAgLi4uc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzLFxuICAgIC4uLnRvRHJvcHBhYmxlTWFwKHdpdGhTY3JvbGxDaGFuZ2UpXG4gIH07XG4gIGNvbnN0IHVwZGF0ZWRBZGRpdGlvbnMgPSB0b0RyYWdnYWJsZU1hcChhZGp1c3RBZGRpdGlvbnNGb3JTY3JvbGxDaGFuZ2VzKHtcbiAgICBhZGRpdGlvbnM6IHB1Ymxpc2hlZC5hZGRpdGlvbnMsXG4gICAgdXBkYXRlZERyb3BwYWJsZXM6IGRyb3BwYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0XG4gIH0pKTtcbiAgY29uc3QgZHJhZ2dhYmxlcyA9IHtcbiAgICAuLi5zdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgLi4udXBkYXRlZEFkZGl0aW9uc1xuICB9O1xuICBwdWJsaXNoZWQucmVtb3ZhbHMuZm9yRWFjaChpZCA9PiB7XG4gICAgZGVsZXRlIGRyYWdnYWJsZXNbaWRdO1xuICB9KTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHtcbiAgICBkcm9wcGFibGVzLFxuICAgIGRyYWdnYWJsZXNcbiAgfTtcbiAgY29uc3Qgd2FzT3ZlcklkID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KTtcbiAgY29uc3Qgd2FzT3ZlciA9IHdhc092ZXJJZCA/IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1t3YXNPdmVySWRdIDogbnVsbDtcbiAgY29uc3QgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IGhvbWUgPSBkaW1lbnNpb25zLmRyb3BwYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJvcHBhYmxlLmlkXTtcbiAgY29uc3Qge1xuICAgIGltcGFjdDogb25MaWZ0SW1wYWN0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSA9IGdldExpZnRFZmZlY3Qoe1xuICAgIGRyYWdnYWJsZSxcbiAgICBob21lLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0XG4gIH0pO1xuICBjb25zdCBwcmV2aW91c0ltcGFjdCA9IHdhc092ZXIgJiYgd2FzT3Zlci5pc0NvbWJpbmVFbmFibGVkID8gc3RhdGUuaW1wYWN0IDogb25MaWZ0SW1wYWN0O1xuICBjb25zdCBpbXBhY3QgPSBnZXREcmFnSW1wYWN0KHtcbiAgICBwYWdlT2Zmc2V0OiBzdGF0ZS5jdXJyZW50LnBhZ2Uub2Zmc2V0LFxuICAgIGRyYWdnYWJsZTogZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF0sXG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRpbWVuc2lvbnMuZHJvcHBhYmxlcyxcbiAgICBwcmV2aW91c0ltcGFjdCxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgZmluaXNoKCk7XG4gIGNvbnN0IGRyYWdnaW5nU3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgcGhhc2U6ICdEUkFHR0lORycsXG4gICAgaW1wYWN0LFxuICAgIG9uTGlmdEltcGFjdCxcbiAgICBkaW1lbnNpb25zLFxuICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9O1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIHJldHVybiBkcmFnZ2luZ1N0YXRlO1xuICB9XG4gIGNvbnN0IGRyb3BQZW5kaW5nID0ge1xuICAgIC4uLmRyYWdnaW5nU3RhdGUsXG4gICAgcGhhc2U6ICdEUk9QX1BFTkRJTkcnLFxuICAgIHJlYXNvbjogc3RhdGUucmVhc29uLFxuICAgIGlzV2FpdGluZzogZmFsc2VcbiAgfTtcbiAgcmV0dXJuIGRyb3BQZW5kaW5nO1xufTtcblxuY29uc3QgaXNTbmFwcGluZyA9IHN0YXRlID0+IHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnO1xuY29uc3QgcG9zdERyb3BwYWJsZUNoYW5nZSA9IChzdGF0ZSwgdXBkYXRlZCwgaXNFbmFibGVkQ2hhbmdpbmcpID0+IHtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHBhdGNoRGltZW5zaW9uTWFwKHN0YXRlLmRpbWVuc2lvbnMsIHVwZGF0ZWQpO1xuICBpZiAoIWlzU25hcHBpbmcoc3RhdGUpIHx8IGlzRW5hYmxlZENoYW5naW5nKSB7XG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIGRpbWVuc2lvbnNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVmcmVzaFNuYXAoe1xuICAgIHN0YXRlLFxuICAgIGRpbWVuc2lvbnNcbiAgfSk7XG59O1xuZnVuY3Rpb24gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmlzRHJhZ2dpbmcgJiYgc3RhdGUubW92ZW1lbnRNb2RlID09PSAnU05BUCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuY29uc3QgaWRsZSQyID0ge1xuICBwaGFzZTogJ0lETEUnLFxuICBjb21wbGV0ZWQ6IG51bGwsXG4gIHNob3VsZEZsdXNoOiBmYWxzZVxufTtcbnZhciByZWR1Y2VyID0gKHN0YXRlID0gaWRsZSQyLCBhY3Rpb24pID0+IHtcbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRkxVU0gnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmlkbGUkMixcbiAgICAgIHNob3VsZEZsdXNoOiB0cnVlXG4gICAgfTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0lOSVRJQUxfUFVCTElTSCBtdXN0IGNvbWUgYWZ0ZXIgYSBJRExFIHBoYXNlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBjcml0aWNhbCxcbiAgICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIG1vdmVtZW50TW9kZVxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgICBjb25zdCBob21lID0gZGltZW5zaW9ucy5kcm9wcGFibGVzW2NyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gICAgY29uc3QgY2xpZW50ID0ge1xuICAgICAgc2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBib3JkZXJCb3hDZW50ZXI6IGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlcixcbiAgICAgIG9mZnNldDogb3JpZ2luXG4gICAgfTtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgY2xpZW50LFxuICAgICAgcGFnZToge1xuICAgICAgICBzZWxlY3Rpb246IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCksXG4gICAgICAgIGJvcmRlckJveENlbnRlcjogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsKSxcbiAgICAgICAgb2Zmc2V0OiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmRpZmYudmFsdWUpXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1dpbmRvd1Njcm9sbEFsbG93ZWQgPSB0b0Ryb3BwYWJsZUxpc3QoZGltZW5zaW9ucy5kcm9wcGFibGVzKS5ldmVyeShpdGVtID0+ICFpdGVtLmlzRml4ZWRPblBhZ2UpO1xuICAgIGNvbnN0IHtcbiAgICAgIGltcGFjdCxcbiAgICAgIGFmdGVyQ3JpdGljYWxcbiAgICB9ID0gZ2V0TGlmdEVmZmVjdCh7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBob21lLFxuICAgICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgdmlld3BvcnRcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwaGFzZTogJ0RSQUdHSU5HJyxcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWUsXG4gICAgICBjcml0aWNhbCxcbiAgICAgIG1vdmVtZW50TW9kZSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICBpbml0aWFsLFxuICAgICAgY3VycmVudDogaW5pdGlhbCxcbiAgICAgIGlzV2luZG93U2Nyb2xsQWxsb3dlZCxcbiAgICAgIGltcGFjdCxcbiAgICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgICBvbkxpZnRJbXBhY3Q6IGltcGFjdCxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGwsXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IG51bGxcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnQ09MTEVDVElPTl9TVEFSVElORycpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDb2xsZWN0aW9uIGNhbm5vdCBzdGFydCBmcm9tIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHBoYXNlOiAnQ09MTEVDVElORydcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnUFVCTElTSF9XSElMRV9EUkFHR0lORycpIHtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFVuZXhwZWN0ZWQgJHthY3Rpb24udHlwZX0gcmVjZWl2ZWQgaW4gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHJldHVybiBwdWJsaXNoV2hpbGVEcmFnZ2luZ0luVmlydHVhbCh7XG4gICAgICBzdGF0ZSxcbiAgICAgIHB1Ymxpc2hlZDogYWN0aW9uLnBheWxvYWRcbiAgICB9KTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdNT1ZFJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7YWN0aW9uLnR5cGV9IG5vdCBwZXJtaXR0ZWQgaW4gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGNsaWVudDogY2xpZW50U2VsZWN0aW9uXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGlmIChpc0VxdWFsJDEoY2xpZW50U2VsZWN0aW9uLCBzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBpbXBhY3Q6IGlzU25hcHBpbmcoc3RhdGUpID8gc3RhdGUuaW1wYWN0IDogbnVsbFxuICAgIH0pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9EUk9QUEFCTEVfU0NST0xMJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHthY3Rpb24udHlwZX0gbm90IHBlcm1pdHRlZCBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBuZXdTY3JvbGxcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2lkXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxlZCA9IHNjcm9sbERyb3BwYWJsZSh0YXJnZXQsIG5ld1Njcm9sbCk7XG4gICAgcmV0dXJuIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIHNjcm9sbGVkLCBmYWxzZSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX0RST1BQQUJMRV9JU19FTkFCTEVEJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYEF0dGVtcHRpbmcgdG8gbW92ZSBpbiBhbiB1bnN1cHBvcnRlZCBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBpc0VuYWJsZWRcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2lkXTtcbiAgICAhdGFyZ2V0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGZpbmQgRHJvcHBhYmxlW2lkOiAke2lkfV0gdG8gdG9nZ2xlIGl0cyBlbmFibGVkIHN0YXRlYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICAhKHRhcmdldC5pc0VuYWJsZWQgIT09IGlzRW5hYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBUcnlpbmcgdG8gc2V0IGRyb3BwYWJsZSBpc0VuYWJsZWQgdG8gJHtTdHJpbmcoaXNFbmFibGVkKX1cbiAgICAgIGJ1dCBpdCBpcyBhbHJlYWR5ICR7U3RyaW5nKHRhcmdldC5pc0VuYWJsZWQpfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgdXBkYXRlZCA9IHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH07XG4gICAgcmV0dXJuIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIHVwZGF0ZWQsIHRydWUpO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9EUk9QUEFCTEVfSVNfQ09NQklORV9FTkFCTEVEJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYEF0dGVtcHRpbmcgdG8gbW92ZSBpbiBhbiB1bnN1cHBvcnRlZCBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHRhcmdldCA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tpZF07XG4gICAgIXRhcmdldCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBmaW5kIERyb3BwYWJsZVtpZDogJHtpZH1dIHRvIHRvZ2dsZSBpdHMgaXNDb21iaW5lRW5hYmxlZCBzdGF0ZWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgISh0YXJnZXQuaXNDb21iaW5lRW5hYmxlZCAhPT0gaXNDb21iaW5lRW5hYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBUcnlpbmcgdG8gc2V0IGRyb3BwYWJsZSBpc0NvbWJpbmVFbmFibGVkIHRvICR7U3RyaW5nKGlzQ29tYmluZUVuYWJsZWQpfVxuICAgICAgYnV0IGl0IGlzIGFscmVhZHkgJHtTdHJpbmcodGFyZ2V0LmlzQ29tYmluZUVuYWJsZWQpfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgdXBkYXRlZCA9IHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWRcbiAgICB9O1xuICAgIHJldHVybiBwb3N0RHJvcHBhYmxlQ2hhbmdlKHN0YXRlLCB1cGRhdGVkLCB0cnVlKTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdNT1ZFX0JZX1dJTkRPV19TQ1JPTEwnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IG1vdmUgYnkgd2luZG93IGluIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICAhc3RhdGUuaXNXaW5kb3dTY3JvbGxBbGxvd2VkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnV2luZG93IHNjcm9sbGluZyBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBmb3IgZml4ZWQgbGlzdHMnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IG5ld1Njcm9sbCA9IGFjdGlvbi5wYXlsb2FkLm5ld1Njcm9sbDtcbiAgICBpZiAoaXNFcXVhbCQxKHN0YXRlLnZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LCBuZXdTY3JvbGwpKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCB2aWV3cG9ydCA9IHNjcm9sbFZpZXdwb3J0KHN0YXRlLnZpZXdwb3J0LCBuZXdTY3JvbGwpO1xuICAgIGlmIChpc1NuYXBwaW5nKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHJlZnJlc2hTbmFwKHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHZpZXdwb3J0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIHZpZXdwb3J0XG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX1ZJRVdQT1JUX01BWF9TQ1JPTEwnKSB7XG4gICAgaWYgKCFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3QgbWF4U2Nyb2xsID0gYWN0aW9uLnBheWxvYWQubWF4U2Nyb2xsO1xuICAgIGlmIChpc0VxdWFsJDEobWF4U2Nyb2xsLCBzdGF0ZS52aWV3cG9ydC5zY3JvbGwubWF4KSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCB3aXRoTWF4U2Nyb2xsID0ge1xuICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICBzY3JvbGw6IHtcbiAgICAgICAgLi4uc3RhdGUudmlld3BvcnQuc2Nyb2xsLFxuICAgICAgICBtYXg6IG1heFNjcm9sbFxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgdmlld3BvcnQ6IHdpdGhNYXhTY3JvbGxcbiAgICB9O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkVfVVAnIHx8IGFjdGlvbi50eXBlID09PSAnTU9WRV9ET1dOJyB8fCBhY3Rpb24udHlwZSA9PT0gJ01PVkVfTEVGVCcgfHwgYWN0aW9uLnR5cGUgPT09ICdNT1ZFX1JJR0hUJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7YWN0aW9uLnR5cGV9IHJlY2VpdmVkIHdoaWxlIG5vdCBpbiBEUkFHR0lORyBwaGFzZWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzdWx0ID0gbW92ZUluRGlyZWN0aW9uKHtcbiAgICAgIHN0YXRlLFxuICAgICAgdHlwZTogYWN0aW9uLnR5cGVcbiAgICB9KTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlLFxuICAgICAgaW1wYWN0OiByZXN1bHQuaW1wYWN0LFxuICAgICAgY2xpZW50U2VsZWN0aW9uOiByZXN1bHQuY2xpZW50U2VsZWN0aW9uLFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IHJlc3VsdC5zY3JvbGxKdW1wUmVxdWVzdFxuICAgIH0pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICBjb25zdCByZWFzb24gPSBhY3Rpb24ucGF5bG9hZC5yZWFzb247XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IG1vdmUgaW50byB0aGUgRFJPUF9QRU5ESU5HIHBoYXNlIGZyb20gdGhlIENPTExFQ1RJTkcgcGhhc2UnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBwaGFzZTogJ0RST1BfUEVORElORycsXG4gICAgICBpc1dhaXRpbmc6IHRydWUsXG4gICAgICByZWFzb25cbiAgICB9O1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0FOSU1BVEUnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tcGxldGVkLFxuICAgICAgZHJvcER1cmF0aW9uLFxuICAgICAgbmV3SG9tZUNsaWVudE9mZnNldFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgYW5pbWF0ZSBkcm9wIGZyb20gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHBoYXNlOiAnRFJPUF9BTklNQVRJTkcnLFxuICAgICAgY29tcGxldGVkLFxuICAgICAgZHJvcER1cmF0aW9uLFxuICAgICAgbmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgIGRpbWVuc2lvbnM6IHN0YXRlLmRpbWVuc2lvbnNcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21wbGV0ZWRcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBoYXNlOiAnSURMRScsXG4gICAgICBjb21wbGV0ZWQsXG4gICAgICBzaG91bGRGbHVzaDogZmFsc2VcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn07XG5cbmZ1bmN0aW9uIGd1YXJkKGFjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHJldHVybiBhY3Rpb24gaW5zdGFuY2VvZiBPYmplY3QgJiYgJ3R5cGUnIGluIGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gcHJlZGljYXRlO1xufVxuY29uc3QgYmVmb3JlSW5pdGlhbENhcHR1cmUgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdCRUZPUkVfSU5JVElBTF9DQVBUVVJFJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBsaWZ0JDEgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdMSUZUJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBpbml0aWFsUHVibGlzaCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0lOSVRJQUxfUFVCTElTSCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgcHVibGlzaFdoaWxlRHJhZ2dpbmcgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdQVUJMSVNIX1dISUxFX0RSQUdHSU5HJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBjb2xsZWN0aW9uU3RhcnRpbmcgPSAoKSA9PiAoe1xuICB0eXBlOiAnQ09MTEVDVElPTl9TVEFSVElORycsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9TQ1JPTEwnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1VQREFURV9EUk9QUEFCTEVfSVNfRU5BQkxFRCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1VQREFURV9EUk9QUEFCTEVfSVNfQ09NQklORV9FTkFCTEVEJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBtb3ZlID0gYXJncyA9PiAoe1xuICB0eXBlOiAnTU9WRScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgbW92ZUJ5V2luZG93U2Nyb2xsID0gYXJncyA9PiAoe1xuICB0eXBlOiAnTU9WRV9CWV9XSU5ET1dfU0NST0xMJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1VQREFURV9WSUVXUE9SVF9NQVhfU0NST0xMJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBtb3ZlVXAgPSAoKSA9PiAoe1xuICB0eXBlOiAnTU9WRV9VUCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgbW92ZURvd24gPSAoKSA9PiAoe1xuICB0eXBlOiAnTU9WRV9ET1dOJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBtb3ZlUmlnaHQgPSAoKSA9PiAoe1xuICB0eXBlOiAnTU9WRV9SSUdIVCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgbW92ZUxlZnQgPSAoKSA9PiAoe1xuICB0eXBlOiAnTU9WRV9MRUZUJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBmbHVzaCA9ICgpID0+ICh7XG4gIHR5cGU6ICdGTFVTSCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgYW5pbWF0ZURyb3AgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdEUk9QX0FOSU1BVEUnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGNvbXBsZXRlRHJvcCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0RST1BfQ09NUExFVEUnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGRyb3AgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdEUk9QJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBkcm9wUGVuZGluZyA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0RST1BfUEVORElORycsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgZHJvcEFuaW1hdGlvbkZpbmlzaGVkID0gKCkgPT4gKHtcbiAgdHlwZTogJ0RST1BfQU5JTUFUSU9OX0ZJTklTSEVEJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5cbmZ1bmN0aW9uIGNoZWNrSW5kZXhlcyhpbnNpZGVEZXN0aW5hdGlvbikge1xuICBpZiAoaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5kZXhlcyA9IGluc2lkZURlc3RpbmF0aW9uLm1hcChkID0+IGQuZGVzY3JpcHRvci5pbmRleCk7XG4gIGNvbnN0IGVycm9ycyA9IHt9O1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50ID0gaW5kZXhlc1tpXTtcbiAgICBjb25zdCBwcmV2aW91cyA9IGluZGV4ZXNbaSAtIDFdO1xuICAgIGlmIChjdXJyZW50ICE9PSBwcmV2aW91cyArIDEpIHtcbiAgICAgIGVycm9yc1tjdXJyZW50XSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICghT2JqZWN0LmtleXMoZXJyb3JzKS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZm9ybWF0dGVkID0gaW5kZXhlcy5tYXAoaW5kZXggPT4ge1xuICAgIGNvbnN0IGhhc0Vycm9yID0gQm9vbGVhbihlcnJvcnNbaW5kZXhdKTtcbiAgICByZXR1cm4gaGFzRXJyb3IgPyBgW/CflKUke2luZGV4fV1gIDogYCR7aW5kZXh9YDtcbiAgfSkuam9pbignLCAnKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgRGV0ZWN0ZWQgbm9uLWNvbnNlY3V0aXZlIDxEcmFnZ2FibGUgLz4gaW5kZXhlcy5cblxuICAgIChUaGlzIGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJ1Z3MpXG5cbiAgICAke2Zvcm1hdHRlZH1cbiAgYCkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZURpbWVuc2lvbnMoY3JpdGljYWwsIGRpbWVuc2lvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoY3JpdGljYWwuZHJvcHBhYmxlLmlkLCBkaW1lbnNpb25zLmRyYWdnYWJsZXMpO1xuICAgIGNoZWNrSW5kZXhlcyhpbnNpZGVEZXN0aW5hdGlvbik7XG4gIH1cbn1cblxudmFyIGxpZnQgPSBtYXJzaGFsID0+ICh7XG4gIGdldFN0YXRlLFxuICBkaXNwYXRjaFxufSkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoIWd1YXJkKGFjdGlvbiwgJ0xJRlQnKSkge1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge1xuICAgIGlkLFxuICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICBtb3ZlbWVudE1vZGVcbiAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICBjb25zdCBpbml0aWFsID0gZ2V0U3RhdGUoKTtcbiAgaWYgKGluaXRpYWwucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICBkaXNwYXRjaChjb21wbGV0ZURyb3Aoe1xuICAgICAgY29tcGxldGVkOiBpbml0aWFsLmNvbXBsZXRlZFxuICAgIH0pKTtcbiAgfVxuICAhKGdldFN0YXRlKCkucGhhc2UgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIHBoYXNlIHRvIHN0YXJ0IGEgZHJhZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGRpc3BhdGNoKGZsdXNoKCkpO1xuICBkaXNwYXRjaChiZWZvcmVJbml0aWFsQ2FwdHVyZSh7XG4gICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgIG1vdmVtZW50TW9kZVxuICB9KSk7XG4gIGNvbnN0IHNjcm9sbE9wdGlvbnMgPSB7XG4gICAgc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5OiBtb3ZlbWVudE1vZGUgPT09ICdTTkFQJ1xuICB9O1xuICBjb25zdCByZXF1ZXN0ID0ge1xuICAgIGRyYWdnYWJsZUlkOiBpZCxcbiAgICBzY3JvbGxPcHRpb25zXG4gIH07XG4gIGNvbnN0IHtcbiAgICBjcml0aWNhbCxcbiAgICBkaW1lbnNpb25zLFxuICAgIHZpZXdwb3J0XG4gIH0gPSBtYXJzaGFsLnN0YXJ0UHVibGlzaGluZyhyZXF1ZXN0KTtcbiAgdmFsaWRhdGVEaW1lbnNpb25zKGNyaXRpY2FsLCBkaW1lbnNpb25zKTtcbiAgZGlzcGF0Y2goaW5pdGlhbFB1Ymxpc2goe1xuICAgIGNyaXRpY2FsLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgY2xpZW50U2VsZWN0aW9uLFxuICAgIG1vdmVtZW50TW9kZSxcbiAgICB2aWV3cG9ydFxuICB9KSk7XG59O1xuXG52YXIgc3R5bGUgPSBtYXJzaGFsID0+ICgpID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKGd1YXJkKGFjdGlvbiwgJ0lOSVRJQUxfUFVCTElTSCcpKSB7XG4gICAgbWFyc2hhbC5kcmFnZ2luZygpO1xuICB9XG4gIGlmIChndWFyZChhY3Rpb24sICdEUk9QX0FOSU1BVEUnKSkge1xuICAgIG1hcnNoYWwuZHJvcHBpbmcoYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdC5yZWFzb24pO1xuICB9XG4gIGlmIChndWFyZChhY3Rpb24sICdGTFVTSCcpIHx8IGd1YXJkKGFjdGlvbiwgJ0RST1BfQ09NUExFVEUnKSkge1xuICAgIG1hcnNoYWwucmVzdGluZygpO1xuICB9XG4gIG5leHQoYWN0aW9uKTtcbn07XG5cbmNvbnN0IGN1cnZlcyA9IHtcbiAgb3V0T2ZUaGVXYXk6ICdjdWJpYy1iZXppZXIoMC4yLCAwLCAwLCAxKScsXG4gIGRyb3A6ICdjdWJpYy1iZXppZXIoLjIsMSwuMSwxKSdcbn07XG5jb25zdCBjb21iaW5lID0ge1xuICBvcGFjaXR5OiB7XG4gICAgZHJvcDogMCxcbiAgICBjb21iaW5pbmc6IDAuN1xuICB9LFxuICBzY2FsZToge1xuICAgIGRyb3A6IDAuNzVcbiAgfVxufTtcbmNvbnN0IHRpbWluZ3MgPSB7XG4gIG91dE9mVGhlV2F5OiAwLjIsXG4gIG1pbkRyb3BUaW1lOiAwLjMzLFxuICBtYXhEcm9wVGltZTogMC41NVxufTtcbmNvbnN0IG91dE9mVGhlV2F5VGltaW5nID0gYCR7dGltaW5ncy5vdXRPZlRoZVdheX1zICR7Y3VydmVzLm91dE9mVGhlV2F5fWA7XG5jb25zdCB0cmFuc2l0aW9ucyA9IHtcbiAgZmx1aWQ6IGBvcGFjaXR5ICR7b3V0T2ZUaGVXYXlUaW1pbmd9YCxcbiAgc25hcDogYHRyYW5zZm9ybSAke291dE9mVGhlV2F5VGltaW5nfSwgb3BhY2l0eSAke291dE9mVGhlV2F5VGltaW5nfWAsXG4gIGRyb3A6IGR1cmF0aW9uID0+IHtcbiAgICBjb25zdCB0aW1pbmcgPSBgJHtkdXJhdGlvbn1zICR7Y3VydmVzLmRyb3B9YDtcbiAgICByZXR1cm4gYHRyYW5zZm9ybSAke3RpbWluZ30sIG9wYWNpdHkgJHt0aW1pbmd9YDtcbiAgfSxcbiAgb3V0T2ZUaGVXYXk6IGB0cmFuc2Zvcm0gJHtvdXRPZlRoZVdheVRpbWluZ31gLFxuICBwbGFjZWhvbGRlcjogYGhlaWdodCAke291dE9mVGhlV2F5VGltaW5nfSwgd2lkdGggJHtvdXRPZlRoZVdheVRpbWluZ30sIG1hcmdpbiAke291dE9mVGhlV2F5VGltaW5nfWBcbn07XG5jb25zdCBtb3ZlVG8gPSBvZmZzZXQgPT4gaXNFcXVhbCQxKG9mZnNldCwgb3JpZ2luKSA/IHVuZGVmaW5lZCA6IGB0cmFuc2xhdGUoJHtvZmZzZXQueH1weCwgJHtvZmZzZXQueX1weClgO1xuY29uc3QgdHJhbnNmb3JtcyA9IHtcbiAgbW92ZVRvLFxuICBkcm9wOiAob2Zmc2V0LCBpc0NvbWJpbmluZykgPT4ge1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG1vdmVUbyhvZmZzZXQpO1xuICAgIGlmICghdHJhbnNsYXRlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWlzQ29tYmluaW5nKSB7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dHJhbnNsYXRlfSBzY2FsZSgke2NvbWJpbmUuc2NhbGUuZHJvcH0pYDtcbiAgfVxufTtcblxuY29uc3Qge1xuICBtaW5Ecm9wVGltZSxcbiAgbWF4RHJvcFRpbWVcbn0gPSB0aW1pbmdzO1xuY29uc3QgZHJvcFRpbWVSYW5nZSA9IG1heERyb3BUaW1lIC0gbWluRHJvcFRpbWU7XG5jb25zdCBtYXhEcm9wVGltZUF0RGlzdGFuY2UgPSAxNTAwO1xuY29uc3QgY2FuY2VsRHJvcE1vZGlmaWVyID0gMC42O1xudmFyIGdldERyb3BEdXJhdGlvbiA9ICh7XG4gIGN1cnJlbnQsXG4gIGRlc3RpbmF0aW9uLFxuICByZWFzb25cbn0pID0+IHtcbiAgY29uc3QgZGlzdGFuY2UkMSA9IGRpc3RhbmNlKGN1cnJlbnQsIGRlc3RpbmF0aW9uKTtcbiAgaWYgKGRpc3RhbmNlJDEgPD0gMCkge1xuICAgIHJldHVybiBtaW5Ecm9wVGltZTtcbiAgfVxuICBpZiAoZGlzdGFuY2UkMSA+PSBtYXhEcm9wVGltZUF0RGlzdGFuY2UpIHtcbiAgICByZXR1cm4gbWF4RHJvcFRpbWU7XG4gIH1cbiAgY29uc3QgcGVyY2VudGFnZSA9IGRpc3RhbmNlJDEgLyBtYXhEcm9wVGltZUF0RGlzdGFuY2U7XG4gIGNvbnN0IGR1cmF0aW9uID0gbWluRHJvcFRpbWUgKyBkcm9wVGltZVJhbmdlICogcGVyY2VudGFnZTtcbiAgY29uc3Qgd2l0aER1cmF0aW9uID0gcmVhc29uID09PSAnQ0FOQ0VMJyA/IGR1cmF0aW9uICogY2FuY2VsRHJvcE1vZGlmaWVyIDogZHVyYXRpb247XG4gIHJldHVybiBOdW1iZXIod2l0aER1cmF0aW9uLnRvRml4ZWQoMikpO1xufTtcblxudmFyIGdldE5ld0hvbWVDbGllbnRPZmZzZXQgPSAoe1xuICBpbXBhY3QsXG4gIGRyYWdnYWJsZSxcbiAgZGltZW5zaW9ucyxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlc1xuICB9ID0gZGltZW5zaW9ucztcbiAgY29uc3QgZHJvcHBhYmxlSWQgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICBjb25zdCBkZXN0aW5hdGlvbiA9IGRyb3BwYWJsZUlkID8gZHJvcHBhYmxlc1tkcm9wcGFibGVJZF0gOiBudWxsO1xuICBjb25zdCBob21lID0gZHJvcHBhYmxlc1tkcmFnZ2FibGUuZGVzY3JpcHRvci5kcm9wcGFibGVJZF07XG4gIGNvbnN0IG5ld0NsaWVudENlbnRlciA9IGdldENsaWVudEJvcmRlckJveENlbnRlcih7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbiB8fCBob21lLFxuICAgIHZpZXdwb3J0XG4gIH0pO1xuICBjb25zdCBvZmZzZXQgPSBzdWJ0cmFjdChuZXdDbGllbnRDZW50ZXIsIGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlcik7XG4gIHJldHVybiBvZmZzZXQ7XG59O1xuXG52YXIgZ2V0RHJvcEltcGFjdCA9ICh7XG4gIGRyYWdnYWJsZXMsXG4gIHJlYXNvbixcbiAgbGFzdEltcGFjdCxcbiAgaG9tZSxcbiAgdmlld3BvcnQsXG4gIG9uTGlmdEltcGFjdFxufSkgPT4ge1xuICBpZiAoIWxhc3RJbXBhY3QuYXQgfHwgcmVhc29uICE9PSAnRFJPUCcpIHtcbiAgICBjb25zdCByZWNvbXB1dGVkSG9tZUltcGFjdCA9IHJlY29tcHV0ZSh7XG4gICAgICBkcmFnZ2FibGVzLFxuICAgICAgaW1wYWN0OiBvbkxpZnRJbXBhY3QsXG4gICAgICBkZXN0aW5hdGlvbjogaG9tZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGltcGFjdDogcmVjb21wdXRlZEhvbWVJbXBhY3QsXG4gICAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgaWYgKGxhc3RJbXBhY3QuYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGltcGFjdDogbGFzdEltcGFjdCxcbiAgICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGU6IHRydWVcbiAgICB9O1xuICB9XG4gIGNvbnN0IHdpdGhvdXRNb3ZlbWVudCA9IHtcbiAgICAuLi5sYXN0SW1wYWN0LFxuICAgIGRpc3BsYWNlZDogZW1wdHlHcm91cHNcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpbXBhY3Q6IHdpdGhvdXRNb3ZlbWVudCxcbiAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlOiB0cnVlXG4gIH07XG59O1xuXG5jb25zdCBkcm9wTWlkZGxld2FyZSA9ICh7XG4gIGdldFN0YXRlLFxuICBkaXNwYXRjaFxufSkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoIWd1YXJkKGFjdGlvbiwgJ0RST1AnKSkge1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICBjb25zdCByZWFzb24gPSBhY3Rpb24ucGF5bG9hZC5yZWFzb247XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgZGlzcGF0Y2goZHJvcFBlbmRpbmcoe1xuICAgICAgcmVhc29uXG4gICAgfSkpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpc1dhaXRpbmdGb3JEcm9wID0gc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnICYmIHN0YXRlLmlzV2FpdGluZztcbiAgISFpc1dhaXRpbmdGb3JEcm9wID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQSBEUk9QIGFjdGlvbiBvY2N1cnJlZCB3aGlsZSBEUk9QX1BFTkRJTkcgYW5kIHN0aWxsIHdhaXRpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZHJvcCBpbiBwaGFzZTogJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBjcml0aWNhbCA9IHN0YXRlLmNyaXRpY2FsO1xuICBjb25zdCBkaW1lbnNpb25zID0gc3RhdGUuZGltZW5zaW9ucztcbiAgY29uc3QgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IHtcbiAgICBpbXBhY3QsXG4gICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZVxuICB9ID0gZ2V0RHJvcEltcGFjdCh7XG4gICAgcmVhc29uLFxuICAgIGxhc3RJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsLFxuICAgIG9uTGlmdEltcGFjdDogc3RhdGUub25MaWZ0SW1wYWN0LFxuICAgIGhvbWU6IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcm9wcGFibGUuaWRdLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBkcmFnZ2FibGVzOiBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNcbiAgfSk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZGlkRHJvcEluc2lkZURyb3BwYWJsZSA/IHRyeUdldERlc3RpbmF0aW9uKGltcGFjdCkgOiBudWxsO1xuICBjb25zdCBjb21iaW5lID0gZGlkRHJvcEluc2lkZURyb3BwYWJsZSA/IHRyeUdldENvbWJpbmUoaW1wYWN0KSA6IG51bGw7XG4gIGNvbnN0IHNvdXJjZSA9IHtcbiAgICBpbmRleDogY3JpdGljYWwuZHJhZ2dhYmxlLmluZGV4LFxuICAgIGRyb3BwYWJsZUlkOiBjcml0aWNhbC5kcm9wcGFibGUuaWRcbiAgfTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCxcbiAgICB0eXBlOiBkcmFnZ2FibGUuZGVzY3JpcHRvci50eXBlLFxuICAgIHNvdXJjZSxcbiAgICByZWFzb24sXG4gICAgbW9kZTogc3RhdGUubW92ZW1lbnRNb2RlLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGNvbWJpbmVcbiAgfTtcbiAgY29uc3QgbmV3SG9tZUNsaWVudE9mZnNldCA9IGdldE5ld0hvbWVDbGllbnRPZmZzZXQoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGltZW5zaW9ucyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgY29uc3QgY29tcGxldGVkID0ge1xuICAgIGNyaXRpY2FsOiBzdGF0ZS5jcml0aWNhbCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsLFxuICAgIHJlc3VsdCxcbiAgICBpbXBhY3RcbiAgfTtcbiAgY29uc3QgaXNBbmltYXRpb25SZXF1aXJlZCA9ICFpc0VxdWFsJDEoc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0LCBuZXdIb21lQ2xpZW50T2Zmc2V0KSB8fCBCb29sZWFuKHJlc3VsdC5jb21iaW5lKTtcbiAgaWYgKCFpc0FuaW1hdGlvblJlcXVpcmVkKSB7XG4gICAgZGlzcGF0Y2goY29tcGxldGVEcm9wKHtcbiAgICAgIGNvbXBsZXRlZFxuICAgIH0pKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZHJvcER1cmF0aW9uID0gZ2V0RHJvcER1cmF0aW9uKHtcbiAgICBjdXJyZW50OiBzdGF0ZS5jdXJyZW50LmNsaWVudC5vZmZzZXQsXG4gICAgZGVzdGluYXRpb246IG5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgcmVhc29uXG4gIH0pO1xuICBjb25zdCBhcmdzID0ge1xuICAgIG5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgZHJvcER1cmF0aW9uLFxuICAgIGNvbXBsZXRlZFxuICB9O1xuICBkaXNwYXRjaChhbmltYXRlRHJvcChhcmdzKSk7XG59O1xuXG52YXIgZ2V0V2luZG93U2Nyb2xsID0gKCkgPT4gKHtcbiAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbn0pO1xuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCaW5kaW5nKHVwZGF0ZSkge1xuICByZXR1cm4ge1xuICAgIGV2ZW50TmFtZTogJ3Njcm9sbCcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gd2luZG93ICYmIGV2ZW50LnRhcmdldCAhPT0gd2luZG93LmRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbExpc3RlbmVyKHtcbiAgb25XaW5kb3dTY3JvbGxcbn0pIHtcbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsKCkge1xuICAgIG9uV2luZG93U2Nyb2xsKGdldFdpbmRvd1Njcm9sbCgpKTtcbiAgfVxuICBjb25zdCBzY2hlZHVsZWQgPSByYWZTY2hkKHVwZGF0ZVNjcm9sbCk7XG4gIGNvbnN0IGJpbmRpbmcgPSBnZXRXaW5kb3dTY3JvbGxCaW5kaW5nKHNjaGVkdWxlZCk7XG4gIGxldCB1bmJpbmQgPSBub29wJDI7XG4gIGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB1bmJpbmQgIT09IG5vb3AkMjtcbiAgfVxuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAhIWlzQWN0aXZlKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RhcnQgc2Nyb2xsIGxpc3RlbmVyIHdoZW4gYWxyZWFkeSBhY3RpdmUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbYmluZGluZ10pO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgIWlzQWN0aXZlKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBzY3JvbGwgbGlzdGVuZXIgd2hlbiBub3QgYWN0aXZlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBzY2hlZHVsZWQuY2FuY2VsKCk7XG4gICAgdW5iaW5kKCk7XG4gICAgdW5iaW5kID0gbm9vcCQyO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICBpc0FjdGl2ZVxuICB9O1xufVxuXG5jb25zdCBzaG91bGRTdG9wJDEgPSBhY3Rpb24gPT4gZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpIHx8IGd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFURScpIHx8IGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJyk7XG5jb25zdCBzY3JvbGxMaXN0ZW5lciA9IHN0b3JlID0+IHtcbiAgY29uc3QgbGlzdGVuZXIgPSBnZXRTY3JvbGxMaXN0ZW5lcih7XG4gICAgb25XaW5kb3dTY3JvbGw6IG5ld1Njcm9sbCA9PiB7XG4gICAgICBzdG9yZS5kaXNwYXRjaChtb3ZlQnlXaW5kb3dTY3JvbGwoe1xuICAgICAgICBuZXdTY3JvbGxcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICAgIGlmICghbGlzdGVuZXIuaXNBY3RpdmUoKSAmJiBndWFyZChhY3Rpb24sICdJTklUSUFMX1BVQkxJU0gnKSkge1xuICAgICAgbGlzdGVuZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVyLmlzQWN0aXZlKCkgJiYgc2hvdWxkU3RvcCQxKGFjdGlvbikpIHtcbiAgICAgIGxpc3RlbmVyLnN0b3AoKTtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICB9O1xufTtcblxudmFyIGdldEV4cGlyaW5nQW5ub3VuY2UgPSBhbm5vdW5jZSA9PiB7XG4gIGxldCB3YXNDYWxsZWQgPSBmYWxzZTtcbiAgbGV0IGlzRXhwaXJlZCA9IGZhbHNlO1xuICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpc0V4cGlyZWQgPSB0cnVlO1xuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0gbWVzc2FnZSA9PiB7XG4gICAgaWYgKHdhc0NhbGxlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnQW5ub3VuY2VtZW50IGFscmVhZHkgbWFkZS4gTm90IG1ha2luZyBhIHNlY29uZCBhbm5vdW5jZW1lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRXhwaXJlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICAgIEFubm91bmNlbWVudHMgY2Fubm90IGJlIG1hZGUgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgIERlZmF1bHQgbWVzc2FnZSBoYXMgYWxyZWFkeSBiZWVuIGFubm91bmNlZC5cbiAgICAgIGApIDogdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXNDYWxsZWQgPSB0cnVlO1xuICAgIGFubm91bmNlKG1lc3NhZ2UpO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICB9O1xuICByZXN1bHQud2FzQ2FsbGVkID0gKCkgPT4gd2FzQ2FsbGVkO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGdldEFzeW5jTWFyc2hhbCA9ICgpID0+IHtcbiAgY29uc3QgZW50cmllcyA9IFtdO1xuICBjb25zdCBleGVjdXRlID0gdGltZXJJZCA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleChpdGVtID0+IGl0ZW0udGltZXJJZCA9PT0gdGltZXJJZCk7XG4gICAgIShpbmRleCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgdGltZXInKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IFtlbnRyeV0gPSBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgZW50cnkuY2FsbGJhY2soKTtcbiAgfTtcbiAgY29uc3QgYWRkID0gZm4gPT4ge1xuICAgIGNvbnN0IHRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IGV4ZWN1dGUodGltZXJJZCkpO1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgdGltZXJJZCxcbiAgICAgIGNhbGxiYWNrOiBmblxuICAgIH07XG4gICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfTtcbiAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaGFsbG93ID0gWy4uLmVudHJpZXNdO1xuICAgIGVudHJpZXMubGVuZ3RoID0gMDtcbiAgICBzaGFsbG93LmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KGVudHJ5LnRpbWVySWQpO1xuICAgICAgZW50cnkuY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhZGQsXG4gICAgZmx1c2hcbiAgfTtcbn07XG5cbmNvbnN0IGFyZUxvY2F0aW9uc0VxdWFsID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgaWYgKGZpcnN0ID09IG51bGwgJiYgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZmlyc3QgPT0gbnVsbCB8fCBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZmlyc3QuZHJvcHBhYmxlSWQgPT09IHNlY29uZC5kcm9wcGFibGVJZCAmJiBmaXJzdC5pbmRleCA9PT0gc2Vjb25kLmluZGV4O1xufTtcbmNvbnN0IGlzQ29tYmluZUVxdWFsID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgaWYgKGZpcnN0ID09IG51bGwgJiYgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZmlyc3QgPT0gbnVsbCB8fCBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZmlyc3QuZHJhZ2dhYmxlSWQgPT09IHNlY29uZC5kcmFnZ2FibGVJZCAmJiBmaXJzdC5kcm9wcGFibGVJZCA9PT0gc2Vjb25kLmRyb3BwYWJsZUlkO1xufTtcbmNvbnN0IGlzQ3JpdGljYWxFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gIGlmIChmaXJzdCA9PT0gc2Vjb25kKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgaXNEcmFnZ2FibGVFcXVhbCA9IGZpcnN0LmRyYWdnYWJsZS5pZCA9PT0gc2Vjb25kLmRyYWdnYWJsZS5pZCAmJiBmaXJzdC5kcmFnZ2FibGUuZHJvcHBhYmxlSWQgPT09IHNlY29uZC5kcmFnZ2FibGUuZHJvcHBhYmxlSWQgJiYgZmlyc3QuZHJhZ2dhYmxlLnR5cGUgPT09IHNlY29uZC5kcmFnZ2FibGUudHlwZSAmJiBmaXJzdC5kcmFnZ2FibGUuaW5kZXggPT09IHNlY29uZC5kcmFnZ2FibGUuaW5kZXg7XG4gIGNvbnN0IGlzRHJvcHBhYmxlRXF1YWwgPSBmaXJzdC5kcm9wcGFibGUuaWQgPT09IHNlY29uZC5kcm9wcGFibGUuaWQgJiYgZmlyc3QuZHJvcHBhYmxlLnR5cGUgPT09IHNlY29uZC5kcm9wcGFibGUudHlwZTtcbiAgcmV0dXJuIGlzRHJhZ2dhYmxlRXF1YWwgJiYgaXNEcm9wcGFibGVFcXVhbDtcbn07XG5cbmNvbnN0IHdpdGhUaW1pbmdzID0gKGtleSwgZm4pID0+IHtcbiAgc3RhcnQoKTtcbiAgZm4oKTtcbiAgZmluaXNoKCk7XG59O1xuY29uc3QgZ2V0RHJhZ1N0YXJ0ID0gKGNyaXRpY2FsLCBtb2RlKSA9PiAoe1xuICBkcmFnZ2FibGVJZDogY3JpdGljYWwuZHJhZ2dhYmxlLmlkLFxuICB0eXBlOiBjcml0aWNhbC5kcm9wcGFibGUudHlwZSxcbiAgc291cmNlOiB7XG4gICAgZHJvcHBhYmxlSWQ6IGNyaXRpY2FsLmRyb3BwYWJsZS5pZCxcbiAgICBpbmRleDogY3JpdGljYWwuZHJhZ2dhYmxlLmluZGV4XG4gIH0sXG4gIG1vZGVcbn0pO1xuZnVuY3Rpb24gZXhlY3V0ZShyZXNwb25kZXIsIGRhdGEsIGFubm91bmNlLCBnZXREZWZhdWx0TWVzc2FnZSkge1xuICBpZiAoIXJlc3BvbmRlcikge1xuICAgIGFubm91bmNlKGdldERlZmF1bHRNZXNzYWdlKGRhdGEpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgd2lsbEV4cGlyZSA9IGdldEV4cGlyaW5nQW5ub3VuY2UoYW5ub3VuY2UpO1xuICBjb25zdCBwcm92aWRlZCA9IHtcbiAgICBhbm5vdW5jZTogd2lsbEV4cGlyZVxuICB9O1xuICByZXNwb25kZXIoZGF0YSwgcHJvdmlkZWQpO1xuICBpZiAoIXdpbGxFeHBpcmUud2FzQ2FsbGVkKCkpIHtcbiAgICBhbm5vdW5jZShnZXREZWZhdWx0TWVzc2FnZShkYXRhKSk7XG4gIH1cbn1cbnZhciBnZXRQdWJsaXNoZXIgPSAoZ2V0UmVzcG9uZGVycywgYW5ub3VuY2UpID0+IHtcbiAgY29uc3QgYXN5bmNNYXJzaGFsID0gZ2V0QXN5bmNNYXJzaGFsKCk7XG4gIGxldCBkcmFnZ2luZyA9IG51bGw7XG4gIGNvbnN0IGJlZm9yZUNhcHR1cmUgPSAoZHJhZ2dhYmxlSWQsIG1vZGUpID0+IHtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25CZWZvcmVDYXB0dXJlIGFzIGEgZHJhZyBzdGFydCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgd2l0aFRpbWluZ3MoJ29uQmVmb3JlQ2FwdHVyZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGZuID0gZ2V0UmVzcG9uZGVycygpLm9uQmVmb3JlQ2FwdHVyZTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBjb25zdCBiZWZvcmUgPSB7XG4gICAgICAgICAgZHJhZ2dhYmxlSWQsXG4gICAgICAgICAgbW9kZVxuICAgICAgICB9O1xuICAgICAgICBmbihiZWZvcmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBiZWZvcmVTdGFydCA9IChjcml0aWNhbCwgbW9kZSkgPT4ge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZURyYWdTdGFydCBhcyBhIGRyYWcgc3RhcnQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHdpdGhUaW1pbmdzKCdvbkJlZm9yZURyYWdTdGFydCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGZuID0gZ2V0UmVzcG9uZGVycygpLm9uQmVmb3JlRHJhZ1N0YXJ0O1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKGdldERyYWdTdGFydChjcml0aWNhbCwgbW9kZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBzdGFydCA9IChjcml0aWNhbCwgbW9kZSkgPT4ge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZURyYWdTdGFydCBhcyBhIGRyYWcgc3RhcnQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGRhdGEgPSBnZXREcmFnU3RhcnQoY3JpdGljYWwsIG1vZGUpO1xuICAgIGRyYWdnaW5nID0ge1xuICAgICAgbW9kZSxcbiAgICAgIGxhc3RDcml0aWNhbDogY3JpdGljYWwsXG4gICAgICBsYXN0TG9jYXRpb246IGRhdGEuc291cmNlLFxuICAgICAgbGFzdENvbWJpbmU6IG51bGxcbiAgICB9O1xuICAgIGFzeW5jTWFyc2hhbC5hZGQoKCkgPT4ge1xuICAgICAgd2l0aFRpbWluZ3MoJ29uRHJhZ1N0YXJ0JywgKCkgPT4gZXhlY3V0ZShnZXRSZXNwb25kZXJzKCkub25EcmFnU3RhcnQsIGRhdGEsIGFubm91bmNlLCBwcmVzZXQub25EcmFnU3RhcnQpKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlID0gKGNyaXRpY2FsLCBpbXBhY3QpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHRyeUdldERlc3RpbmF0aW9uKGltcGFjdCk7XG4gICAgY29uc3QgY29tYmluZSA9IHRyeUdldENvbWJpbmUoaW1wYWN0KTtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkRyYWdNb3ZlIHdoZW4gb25EcmFnU3RhcnQgaGFzIG5vdCBiZWVuIGNhbGxlZCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgaGFzQ3JpdGljYWxDaGFuZ2VkID0gIWlzQ3JpdGljYWxFcXVhbChjcml0aWNhbCwgZHJhZ2dpbmcubGFzdENyaXRpY2FsKTtcbiAgICBpZiAoaGFzQ3JpdGljYWxDaGFuZ2VkKSB7XG4gICAgICBkcmFnZ2luZy5sYXN0Q3JpdGljYWwgPSBjcml0aWNhbDtcbiAgICB9XG4gICAgY29uc3QgaGFzTG9jYXRpb25DaGFuZ2VkID0gIWFyZUxvY2F0aW9uc0VxdWFsKGRyYWdnaW5nLmxhc3RMb2NhdGlvbiwgbG9jYXRpb24pO1xuICAgIGlmIChoYXNMb2NhdGlvbkNoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIH1cbiAgICBjb25zdCBoYXNHcm91cGluZ0NoYW5nZWQgPSAhaXNDb21iaW5lRXF1YWwoZHJhZ2dpbmcubGFzdENvbWJpbmUsIGNvbWJpbmUpO1xuICAgIGlmIChoYXNHcm91cGluZ0NoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RDb21iaW5lID0gY29tYmluZTtcbiAgICB9XG4gICAgaWYgKCFoYXNDcml0aWNhbENoYW5nZWQgJiYgIWhhc0xvY2F0aW9uQ2hhbmdlZCAmJiAhaGFzR3JvdXBpbmdDaGFuZ2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAuLi5nZXREcmFnU3RhcnQoY3JpdGljYWwsIGRyYWdnaW5nLm1vZGUpLFxuICAgICAgY29tYmluZSxcbiAgICAgIGRlc3RpbmF0aW9uOiBsb2NhdGlvblxuICAgIH07XG4gICAgYXN5bmNNYXJzaGFsLmFkZCgoKSA9PiB7XG4gICAgICB3aXRoVGltaW5ncygnb25EcmFnVXBkYXRlJywgKCkgPT4gZXhlY3V0ZShnZXRSZXNwb25kZXJzKCkub25EcmFnVXBkYXRlLCBkYXRhLCBhbm5vdW5jZSwgcHJlc2V0Lm9uRHJhZ1VwZGF0ZSkpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBmbHVzaCByZXNwb25kZXJzIHdoaWxlIGRyYWdnaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBhc3luY01hcnNoYWwuZmx1c2goKTtcbiAgfTtcbiAgY29uc3QgZHJvcCA9IHJlc3VsdCA9PiB7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25EcmFnRW5kIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgb25EcmFnU3RhcnQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGRyYWdnaW5nID0gbnVsbDtcbiAgICB3aXRoVGltaW5ncygnb25EcmFnRW5kJywgKCkgPT4gZXhlY3V0ZShnZXRSZXNwb25kZXJzKCkub25EcmFnRW5kLCByZXN1bHQsIGFubm91bmNlLCBwcmVzZXQub25EcmFnRW5kKSk7XG4gIH07XG4gIGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgLi4uZ2V0RHJhZ1N0YXJ0KGRyYWdnaW5nLmxhc3RDcml0aWNhbCwgZHJhZ2dpbmcubW9kZSksXG4gICAgICBjb21iaW5lOiBudWxsLFxuICAgICAgZGVzdGluYXRpb246IG51bGwsXG4gICAgICByZWFzb246ICdDQU5DRUwnXG4gICAgfTtcbiAgICBkcm9wKHJlc3VsdCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgYmVmb3JlQ2FwdHVyZSxcbiAgICBiZWZvcmVTdGFydCxcbiAgICBzdGFydCxcbiAgICB1cGRhdGUsXG4gICAgZmx1c2gsXG4gICAgZHJvcCxcbiAgICBhYm9ydFxuICB9O1xufTtcblxudmFyIHJlc3BvbmRlcnMgPSAoZ2V0UmVzcG9uZGVycywgYW5ub3VuY2UpID0+IHtcbiAgY29uc3QgcHVibGlzaGVyID0gZ2V0UHVibGlzaGVyKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKTtcbiAgcmV0dXJuIHN0b3JlID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnQkVGT1JFX0lOSVRJQUxfQ0FQVFVSRScpKSB7XG4gICAgICBwdWJsaXNoZXIuYmVmb3JlQ2FwdHVyZShhY3Rpb24ucGF5bG9hZC5kcmFnZ2FibGVJZCwgYWN0aW9uLnBheWxvYWQubW92ZW1lbnRNb2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0lOSVRJQUxfUFVCTElTSCcpKSB7XG4gICAgICBjb25zdCBjcml0aWNhbCA9IGFjdGlvbi5wYXlsb2FkLmNyaXRpY2FsO1xuICAgICAgcHVibGlzaGVyLmJlZm9yZVN0YXJ0KGNyaXRpY2FsLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgcHVibGlzaGVyLnN0YXJ0KGNyaXRpY2FsLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhY3Rpb24ucGF5bG9hZC5jb21wbGV0ZWQucmVzdWx0O1xuICAgICAgcHVibGlzaGVyLmZsdXNoKCk7XG4gICAgICBuZXh0KGFjdGlvbik7XG4gICAgICBwdWJsaXNoZXIuZHJvcChyZXN1bHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBuZXh0KGFjdGlvbik7XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJykpIHtcbiAgICAgIHB1Ymxpc2hlci5hYm9ydCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICBwdWJsaXNoZXIudXBkYXRlKHN0YXRlLmNyaXRpY2FsLCBzdGF0ZS5pbXBhY3QpO1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IGRyb3BBbmltYXRpb25GaW5pc2hNaWRkbGV3YXJlID0gc3RvcmUgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoIWd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFUSU9OX0ZJTklTSEVEJykpIHtcbiAgICBuZXh0KGFjdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgIShzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluaXNoIGEgZHJvcCBhbmltYXRpbmcgd2hlbiBubyBkcm9wIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHN0b3JlLmRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgY29tcGxldGVkOiBzdGF0ZS5jb21wbGV0ZWRcbiAgfSkpO1xufTtcblxuY29uc3QgZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGxNaWRkbGV3YXJlID0gc3RvcmUgPT4ge1xuICBsZXQgdW5iaW5kID0gbnVsbDtcbiAgbGV0IGZyYW1lSWQgPSBudWxsO1xuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgICBmcmFtZUlkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHVuYmluZCkge1xuICAgICAgdW5iaW5kKCk7XG4gICAgICB1bmJpbmQgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICAgIGlmIChndWFyZChhY3Rpb24sICdGTFVTSCcpIHx8IGd1YXJkKGFjdGlvbiwgJ0RST1BfQ09NUExFVEUnKSB8fCBndWFyZChhY3Rpb24sICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcpKSB7XG4gICAgICBjbGVhcigpO1xuICAgIH1cbiAgICBuZXh0KGFjdGlvbik7XG4gICAgaWYgKCFndWFyZChhY3Rpb24sICdEUk9QX0FOSU1BVEUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiaW5kaW5nID0ge1xuICAgICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0sXG4gICAgICBmbjogZnVuY3Rpb24gZmx1c2hEcm9wQW5pbWF0aW9uKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKGRyb3BBbmltYXRpb25GaW5pc2hlZCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBmcmFtZUlkID0gbnVsbDtcbiAgICAgIHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbYmluZGluZ10pO1xuICAgIH0pO1xuICB9O1xufTtcblxudmFyIGRpbWVuc2lvbk1hcnNoYWxTdG9wcGVyID0gbWFyc2hhbCA9PiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykgfHwgZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKSB8fCBndWFyZChhY3Rpb24sICdEUk9QX0FOSU1BVEUnKSkge1xuICAgIG1hcnNoYWwuc3RvcFB1Ymxpc2hpbmcoKTtcbiAgfVxuICBuZXh0KGFjdGlvbik7XG59O1xuXG52YXIgZm9jdXMgPSBtYXJzaGFsID0+IHtcbiAgbGV0IGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgcmV0dXJuICgpID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnSU5JVElBTF9QVUJMSVNIJykpIHtcbiAgICAgIGlzV2F0Y2hpbmcgPSB0cnVlO1xuICAgICAgbWFyc2hhbC50cnlSZWNvcmRGb2N1cyhhY3Rpb24ucGF5bG9hZC5jcml0aWNhbC5kcmFnZ2FibGUuaWQpO1xuICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgbWFyc2hhbC50cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBuZXh0KGFjdGlvbik7XG4gICAgaWYgKCFpc1dhdGNoaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChndWFyZChhY3Rpb24sICdGTFVTSCcpKSB7XG4gICAgICBpc1dhdGNoaW5nID0gZmFsc2U7XG4gICAgICBtYXJzaGFsLnRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykpIHtcbiAgICAgIGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFjdGlvbi5wYXlsb2FkLmNvbXBsZXRlZC5yZXN1bHQ7XG4gICAgICBpZiAocmVzdWx0LmNvbWJpbmUpIHtcbiAgICAgICAgbWFyc2hhbC50cnlTaGlmdFJlY29yZChyZXN1bHQuZHJhZ2dhYmxlSWQsIHJlc3VsdC5jb21iaW5lLmRyYWdnYWJsZUlkKTtcbiAgICAgIH1cbiAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBzaG91bGRTdG9wID0gYWN0aW9uID0+IGd1YXJkKGFjdGlvbiwgJ0RST1BfQ09NUExFVEUnKSB8fCBndWFyZChhY3Rpb24sICdEUk9QX0FOSU1BVEUnKSB8fCBndWFyZChhY3Rpb24sICdGTFVTSCcpO1xudmFyIGF1dG9TY3JvbGwgPSBhdXRvU2Nyb2xsZXIgPT4gc3RvcmUgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoc2hvdWxkU3RvcChhY3Rpb24pKSB7XG4gICAgYXV0b1Njcm9sbGVyLnN0b3AoKTtcbiAgICBuZXh0KGFjdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChndWFyZChhY3Rpb24sICdJTklUSUFMX1BVQkxJU0gnKSkge1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwaGFzZSB0byBiZSBEUkFHR0lORyBhZnRlciBJTklUSUFMX1BVQkxJU0gnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGF1dG9TY3JvbGxlci5zdGFydChzdGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIG5leHQoYWN0aW9uKTtcbiAgYXV0b1Njcm9sbGVyLnNjcm9sbChzdG9yZS5nZXRTdGF0ZSgpKTtcbn07XG5cbmNvbnN0IHBlbmRpbmdEcm9wID0gc3RvcmUgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBuZXh0KGFjdGlvbik7XG4gIGlmICghZ3VhcmQoYWN0aW9uLCAnUFVCTElTSF9XSElMRV9EUkFHR0lORycpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBvc3RBY3Rpb25TdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGlmIChwb3N0QWN0aW9uU3RhdGUucGhhc2UgIT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwb3N0QWN0aW9uU3RhdGUuaXNXYWl0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0b3JlLmRpc3BhdGNoKGRyb3Aoe1xuICAgIHJlYXNvbjogcG9zdEFjdGlvblN0YXRlLnJlYXNvblxuICB9KSk7XG59O1xuXG5jb25zdCBjb21wb3NlRW5oYW5jZXJzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyh7XG4gIG5hbWU6ICdAaGVsbG8tcGFuZ2VhL2RuZCdcbn0pIDogY29tcG9zZTtcbnZhciBjcmVhdGVTdG9yZSA9ICh7XG4gIGRpbWVuc2lvbk1hcnNoYWwsXG4gIGZvY3VzTWFyc2hhbCxcbiAgc3R5bGVNYXJzaGFsLFxuICBnZXRSZXNwb25kZXJzLFxuICBhbm5vdW5jZSxcbiAgYXV0b1Njcm9sbGVyXG59KSA9PiBjcmVhdGVTdG9yZSQxKHJlZHVjZXIsIGNvbXBvc2VFbmhhbmNlcnMoYXBwbHlNaWRkbGV3YXJlKHN0eWxlKHN0eWxlTWFyc2hhbCksIGRpbWVuc2lvbk1hcnNoYWxTdG9wcGVyKGRpbWVuc2lvbk1hcnNoYWwpLCBsaWZ0KGRpbWVuc2lvbk1hcnNoYWwpLCBkcm9wTWlkZGxld2FyZSwgZHJvcEFuaW1hdGlvbkZpbmlzaE1pZGRsZXdhcmUsIGRyb3BBbmltYXRpb25GbHVzaE9uU2Nyb2xsTWlkZGxld2FyZSwgcGVuZGluZ0Ryb3AsIGF1dG9TY3JvbGwoYXV0b1Njcm9sbGVyKSwgc2Nyb2xsTGlzdGVuZXIsIGZvY3VzKGZvY3VzTWFyc2hhbCksIHJlc3BvbmRlcnMoZ2V0UmVzcG9uZGVycywgYW5ub3VuY2UpKSkpO1xuXG5jb25zdCBjbGVhbiQxID0gKCkgPT4gKHtcbiAgYWRkaXRpb25zOiB7fSxcbiAgcmVtb3ZhbHM6IHt9LFxuICBtb2RpZmllZDoge31cbn0pO1xuZnVuY3Rpb24gY3JlYXRlUHVibGlzaGVyKHtcbiAgcmVnaXN0cnksXG4gIGNhbGxiYWNrc1xufSkge1xuICBsZXQgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgbGV0IGZyYW1lSWQgPSBudWxsO1xuICBjb25zdCBjb2xsZWN0ID0gKCkgPT4ge1xuICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrcy5jb2xsZWN0aW9uU3RhcnRpbmcoKTtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgc3RhcnQoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWRkaXRpb25zLFxuICAgICAgICByZW1vdmFscyxcbiAgICAgICAgbW9kaWZpZWRcbiAgICAgIH0gPSBzdGFnaW5nO1xuICAgICAgY29uc3QgYWRkZWQgPSBPYmplY3Qua2V5cyhhZGRpdGlvbnMpLm1hcChpZCA9PiByZWdpc3RyeS5kcmFnZ2FibGUuZ2V0QnlJZChpZCkuZ2V0RGltZW5zaW9uKG9yaWdpbikpLnNvcnQoKGEsIGIpID0+IGEuZGVzY3JpcHRvci5pbmRleCAtIGIuZGVzY3JpcHRvci5pbmRleCk7XG4gICAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMobW9kaWZpZWQpLm1hcChpZCA9PiB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJvcHBhYmxlLmdldEJ5SWQoaWQpO1xuICAgICAgICBjb25zdCBzY3JvbGwgPSBlbnRyeS5jYWxsYmFja3MuZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRyb3BwYWJsZUlkOiBpZCxcbiAgICAgICAgICBzY3JvbGxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBhZGRpdGlvbnM6IGFkZGVkLFxuICAgICAgICByZW1vdmFsczogT2JqZWN0LmtleXMocmVtb3ZhbHMpLFxuICAgICAgICBtb2RpZmllZDogdXBkYXRlZFxuICAgICAgfTtcbiAgICAgIHN0YWdpbmcgPSBjbGVhbiQxKCk7XG4gICAgICBmaW5pc2goKTtcbiAgICAgIGNhbGxiYWNrcy5wdWJsaXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGFkZCA9IGVudHJ5ID0+IHtcbiAgICBjb25zdCBpZCA9IGVudHJ5LmRlc2NyaXB0b3IuaWQ7XG4gICAgc3RhZ2luZy5hZGRpdGlvbnNbaWRdID0gZW50cnk7XG4gICAgc3RhZ2luZy5tb2RpZmllZFtlbnRyeS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkXSA9IHRydWU7XG4gICAgaWYgKHN0YWdpbmcucmVtb3ZhbHNbaWRdKSB7XG4gICAgICBkZWxldGUgc3RhZ2luZy5yZW1vdmFsc1tpZF07XG4gICAgfVxuICAgIGNvbGxlY3QoKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBlbnRyeS5kZXNjcmlwdG9yO1xuICAgIHN0YWdpbmcucmVtb3ZhbHNbZGVzY3JpcHRvci5pZF0gPSB0cnVlO1xuICAgIHN0YWdpbmcubW9kaWZpZWRbZGVzY3JpcHRvci5kcm9wcGFibGVJZF0gPSB0cnVlO1xuICAgIGlmIChzdGFnaW5nLmFkZGl0aW9uc1tkZXNjcmlwdG9yLmlkXSkge1xuICAgICAgZGVsZXRlIHN0YWdpbmcuYWRkaXRpb25zW2Rlc2NyaXB0b3IuaWRdO1xuICAgIH1cbiAgICBjb2xsZWN0KCk7XG4gIH07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgaWYgKCFmcmFtZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgIGZyYW1lSWQgPSBudWxsO1xuICAgIHN0YWdpbmcgPSBjbGVhbiQxKCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgYWRkLFxuICAgIHJlbW92ZSxcbiAgICBzdG9wXG4gIH07XG59XG5cbnZhciBnZXRNYXhTY3JvbGwgPSAoe1xuICBzY3JvbGxIZWlnaHQsXG4gIHNjcm9sbFdpZHRoLFxuICBoZWlnaHQsXG4gIHdpZHRoXG59KSA9PiB7XG4gIGNvbnN0IG1heFNjcm9sbCA9IHN1YnRyYWN0KHtcbiAgICB4OiBzY3JvbGxXaWR0aCxcbiAgICB5OiBzY3JvbGxIZWlnaHRcbiAgfSwge1xuICAgIHg6IHdpZHRoLFxuICAgIHk6IGhlaWdodFxuICB9KTtcbiAgY29uc3QgYWRqdXN0ZWRNYXhTY3JvbGwgPSB7XG4gICAgeDogTWF0aC5tYXgoMCwgbWF4U2Nyb2xsLngpLFxuICAgIHk6IE1hdGgubWF4KDAsIG1heFNjcm9sbC55KVxuICB9O1xuICByZXR1cm4gYWRqdXN0ZWRNYXhTY3JvbGw7XG59O1xuXG52YXIgZ2V0RG9jdW1lbnRFbGVtZW50ID0gKCkgPT4ge1xuICBjb25zdCBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICFkb2MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gZG9jO1xufTtcblxudmFyIGdldE1heFdpbmRvd1Njcm9sbCA9ICgpID0+IHtcbiAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnRFbGVtZW50KCk7XG4gIGNvbnN0IG1heFNjcm9sbCA9IGdldE1heFNjcm9sbCh7XG4gICAgc2Nyb2xsSGVpZ2h0OiBkb2Muc2Nyb2xsSGVpZ2h0LFxuICAgIHNjcm9sbFdpZHRoOiBkb2Muc2Nyb2xsV2lkdGgsXG4gICAgd2lkdGg6IGRvYy5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGRvYy5jbGllbnRIZWlnaHRcbiAgfSk7XG4gIHJldHVybiBtYXhTY3JvbGw7XG59O1xuXG52YXIgZ2V0Vmlld3BvcnQgPSAoKSA9PiB7XG4gIGNvbnN0IHNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbCgpO1xuICBjb25zdCBtYXhTY3JvbGwgPSBnZXRNYXhXaW5kb3dTY3JvbGwoKTtcbiAgY29uc3QgdG9wID0gc2Nyb2xsLnk7XG4gIGNvbnN0IGxlZnQgPSBzY3JvbGwueDtcbiAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnRFbGVtZW50KCk7XG4gIGNvbnN0IHdpZHRoID0gZG9jLmNsaWVudFdpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBkb2MuY2xpZW50SGVpZ2h0O1xuICBjb25zdCByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBjb25zdCBmcmFtZSA9IGdldFJlY3Qoe1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbVxuICB9KTtcbiAgY29uc3Qgdmlld3BvcnQgPSB7XG4gICAgZnJhbWUsXG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiBzY3JvbGwsXG4gICAgICBjdXJyZW50OiBzY3JvbGwsXG4gICAgICBtYXg6IG1heFNjcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IG9yaWdpbixcbiAgICAgICAgZGlzcGxhY2VtZW50OiBvcmlnaW5cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB2aWV3cG9ydDtcbn07XG5cbnZhciBnZXRJbml0aWFsUHVibGlzaCA9ICh7XG4gIGNyaXRpY2FsLFxuICBzY3JvbGxPcHRpb25zLFxuICByZWdpc3RyeVxufSkgPT4ge1xuICBzdGFydCgpO1xuICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0KCk7XG4gIGNvbnN0IHdpbmRvd1Njcm9sbCA9IHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50O1xuICBjb25zdCBob21lID0gY3JpdGljYWwuZHJvcHBhYmxlO1xuICBjb25zdCBkcm9wcGFibGVzID0gcmVnaXN0cnkuZHJvcHBhYmxlLmdldEFsbEJ5VHlwZShob21lLnR5cGUpLm1hcChlbnRyeSA9PiBlbnRyeS5jYWxsYmFja3MuZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwod2luZG93U2Nyb2xsLCBzY3JvbGxPcHRpb25zKSk7XG4gIGNvbnN0IGRyYWdnYWJsZXMgPSByZWdpc3RyeS5kcmFnZ2FibGUuZ2V0QWxsQnlUeXBlKGNyaXRpY2FsLmRyYWdnYWJsZS50eXBlKS5tYXAoZW50cnkgPT4gZW50cnkuZ2V0RGltZW5zaW9uKHdpbmRvd1Njcm9sbCkpO1xuICBjb25zdCBkaW1lbnNpb25zID0ge1xuICAgIGRyYWdnYWJsZXM6IHRvRHJhZ2dhYmxlTWFwKGRyYWdnYWJsZXMpLFxuICAgIGRyb3BwYWJsZXM6IHRvRHJvcHBhYmxlTWFwKGRyb3BwYWJsZXMpXG4gIH07XG4gIGZpbmlzaCgpO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgZGltZW5zaW9ucyxcbiAgICBjcml0aWNhbCxcbiAgICB2aWV3cG9ydFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGVudHJ5KSB7XG4gIGlmIChlbnRyeS5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2luZy5pZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZW50cnkuZGVzY3JpcHRvci50eXBlICE9PSBkcmFnZ2luZy50eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhvbWUgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChlbnRyeS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkKTtcbiAgaWYgKGhvbWUuZGVzY3JpcHRvci5tb2RlICE9PSAndmlydHVhbCcpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIFlvdSBhcmUgYXR0ZW1wdGluZyB0byBhZGQgb3IgcmVtb3ZlIGEgRHJhZ2dhYmxlIFtpZDogJHtlbnRyeS5kZXNjcmlwdG9yLmlkfV1cbiAgICAgIHdoaWxlIGEgZHJhZyBpcyBvY2N1cnJpbmcuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIHZpcnR1YWwgbGlzdHMuXG5cbiAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9wYXR0ZXJucy92aXJ0dWFsLWxpc3RzLm1kXG4gICAgYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxudmFyIGNyZWF0ZURpbWVuc2lvbk1hcnNoYWwgPSAocmVnaXN0cnksIGNhbGxiYWNrcykgPT4ge1xuICBsZXQgY29sbGVjdGlvbiA9IG51bGw7XG4gIGNvbnN0IHB1Ymxpc2hlciA9IGNyZWF0ZVB1Ymxpc2hlcih7XG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBwdWJsaXNoOiBjYWxsYmFja3MucHVibGlzaFdoaWxlRHJhZ2dpbmcsXG4gICAgICBjb2xsZWN0aW9uU3RhcnRpbmc6IGNhbGxiYWNrcy5jb2xsZWN0aW9uU3RhcnRpbmdcbiAgICB9LFxuICAgIHJlZ2lzdHJ5XG4gIH0pO1xuICBjb25zdCB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQgPSAoaWQsIGlzRW5hYmxlZCkgPT4ge1xuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCB1cGRhdGUgaXMgZW5hYmxlZCBmbGFnIG9mIERyb3BwYWJsZSAke2lkfSBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZGApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrcy51cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQoe1xuICAgICAgaWQsXG4gICAgICBpc0VuYWJsZWRcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCA9IChpZCwgaXNDb21iaW5lRW5hYmxlZCkgPT4ge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAhcmVnaXN0cnkuZHJvcHBhYmxlLmV4aXN0cyhpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgdXBkYXRlIGlzQ29tYmluZUVuYWJsZWQgZmxhZyBvZiBEcm9wcGFibGUgJHtpZH0gYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNhbGxiYWNrcy51cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkKHtcbiAgICAgIGlkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZFxuICAgIH0pO1xuICB9O1xuICBjb25zdCB1cGRhdGVEcm9wcGFibGVTY3JvbGwgPSAoaWQsIG5ld1Njcm9sbCkgPT4ge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAhcmVnaXN0cnkuZHJvcHBhYmxlLmV4aXN0cyhpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgdXBkYXRlIHRoZSBzY3JvbGwgb24gRHJvcHBhYmxlICR7aWR9IGFzIGl0IGlzIG5vdCByZWdpc3RlcmVkYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjYWxsYmFja3MudXBkYXRlRHJvcHBhYmxlU2Nyb2xsKHtcbiAgICAgIGlkLFxuICAgICAgbmV3U2Nyb2xsXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHNjcm9sbERyb3BwYWJsZSA9IChpZCwgY2hhbmdlKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGlkKS5jYWxsYmFja3Muc2Nyb2xsKGNoYW5nZSk7XG4gIH07XG4gIGNvbnN0IHN0b3BQdWJsaXNoaW5nID0gKCkgPT4ge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwdWJsaXNoZXIuc3RvcCgpO1xuICAgIGNvbnN0IGhvbWUgPSBjb2xsZWN0aW9uLmNyaXRpY2FsLmRyb3BwYWJsZTtcbiAgICByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QWxsQnlUeXBlKGhvbWUudHlwZSkuZm9yRWFjaChlbnRyeSA9PiBlbnRyeS5jYWxsYmFja3MuZHJhZ1N0b3BwZWQoKSk7XG4gICAgY29sbGVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIGNvbGxlY3Rpb24gPSBudWxsO1xuICB9O1xuICBjb25zdCBzdWJzY3JpYmVyID0gZXZlbnQgPT4ge1xuICAgICFjb2xsZWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIG9ubHkgYmUgc3Vic2NyaWJlZCB3aGVuIGEgY29sbGVjdGlvbiBpcyBvY2N1cnJpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGRyYWdnaW5nID0gY29sbGVjdGlvbi5jcml0aWNhbC5kcmFnZ2FibGU7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdBRERJVElPTicpIHtcbiAgICAgIGlmIChzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZXZlbnQudmFsdWUpKSB7XG4gICAgICAgIHB1Ymxpc2hlci5hZGQoZXZlbnQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ1JFTU9WQUwnKSB7XG4gICAgICBpZiAoc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGV2ZW50LnZhbHVlKSkge1xuICAgICAgICBwdWJsaXNoZXIucmVtb3ZlKGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0YXJ0UHVibGlzaGluZyA9IHJlcXVlc3QgPT4ge1xuICAgICEhY29sbGVjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdGFydCBjYXB0dXJpbmcgY3JpdGljYWwgZGltZW5zaW9ucyBhcyB0aGVyZSBpcyBhbHJlYWR5IGEgY29sbGVjdGlvbicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZ2V0QnlJZChyZXF1ZXN0LmRyYWdnYWJsZUlkKTtcbiAgICBjb25zdCBob21lID0gcmVnaXN0cnkuZHJvcHBhYmxlLmdldEJ5SWQoZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZCk7XG4gICAgY29uc3QgY3JpdGljYWwgPSB7XG4gICAgICBkcmFnZ2FibGU6IGVudHJ5LmRlc2NyaXB0b3IsXG4gICAgICBkcm9wcGFibGU6IGhvbWUuZGVzY3JpcHRvclxuICAgIH07XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSByZWdpc3RyeS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgY29sbGVjdGlvbiA9IHtcbiAgICAgIGNyaXRpY2FsLFxuICAgICAgdW5zdWJzY3JpYmVcbiAgICB9O1xuICAgIHJldHVybiBnZXRJbml0aWFsUHVibGlzaCh7XG4gICAgICBjcml0aWNhbCxcbiAgICAgIHJlZ2lzdHJ5LFxuICAgICAgc2Nyb2xsT3B0aW9uczogcmVxdWVzdC5zY3JvbGxPcHRpb25zXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IG1hcnNoYWwgPSB7XG4gICAgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkLFxuICAgIHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQsXG4gICAgc2Nyb2xsRHJvcHBhYmxlLFxuICAgIHVwZGF0ZURyb3BwYWJsZVNjcm9sbCxcbiAgICBzdGFydFB1Ymxpc2hpbmcsXG4gICAgc3RvcFB1Ymxpc2hpbmdcbiAgfTtcbiAgcmV0dXJuIG1hcnNoYWw7XG59O1xuXG52YXIgY2FuU3RhcnREcmFnID0gKHN0YXRlLCBpZCkgPT4ge1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChzdGF0ZS5waGFzZSAhPT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc3RhdGUuY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCA9PT0gaWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmNvbXBsZXRlZC5yZXN1bHQucmVhc29uID09PSAnRFJPUCc7XG59O1xuXG52YXIgc2Nyb2xsV2luZG93ID0gY2hhbmdlID0+IHtcbiAgd2luZG93LnNjcm9sbEJ5KGNoYW5nZS54LCBjaGFuZ2UueSk7XG59O1xuXG5jb25zdCBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlcyA9IG1lbW9pemVPbmUoZHJvcHBhYmxlcyA9PiB0b0Ryb3BwYWJsZUxpc3QoZHJvcHBhYmxlcykuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gIGlmICghZHJvcHBhYmxlLmlzRW5hYmxlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWRyb3BwYWJsZS5mcmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pKTtcbmNvbnN0IGdldFNjcm9sbGFibGVEcm9wcGFibGVPdmVyID0gKHRhcmdldCwgZHJvcHBhYmxlcykgPT4ge1xuICBjb25zdCBtYXliZSA9IGdldFNjcm9sbGFibGVEcm9wcGFibGVzKGRyb3BwYWJsZXMpLmZpbmQoZHJvcHBhYmxlID0+IHtcbiAgICAhZHJvcHBhYmxlLmZyYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCByZXN1bHQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHJldHVybiBpc1Bvc2l0aW9uSW5GcmFtZShkcm9wcGFibGUuZnJhbWUucGFnZU1hcmdpbkJveCkodGFyZ2V0KTtcbiAgfSkgfHwgbnVsbDtcbiAgcmV0dXJuIG1heWJlO1xufTtcbnZhciBnZXRCZXN0U2Nyb2xsYWJsZURyb3BwYWJsZSA9ICh7XG4gIGNlbnRlcixcbiAgZGVzdGluYXRpb24sXG4gIGRyb3BwYWJsZXNcbn0pID0+IHtcbiAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgY29uc3QgZGltZW5zaW9uID0gZHJvcHBhYmxlc1tkZXN0aW5hdGlvbl07XG4gICAgaWYgKCFkaW1lbnNpb24uZnJhbWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGltZW5zaW9uO1xuICB9XG4gIGNvbnN0IGRpbWVuc2lvbiA9IGdldFNjcm9sbGFibGVEcm9wcGFibGVPdmVyKGNlbnRlciwgZHJvcHBhYmxlcyk7XG4gIHJldHVybiBkaW1lbnNpb247XG59O1xuXG5jb25zdCBkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucyA9IHtcbiAgc3RhcnRGcm9tUGVyY2VudGFnZTogMC4yNSxcbiAgbWF4U2Nyb2xsQXRQZXJjZW50YWdlOiAwLjA1LFxuICBtYXhQaXhlbFNjcm9sbDogMjgsXG4gIGVhc2U6IHBlcmNlbnRhZ2UgPT4gcGVyY2VudGFnZSAqKiAyLFxuICBkdXJhdGlvbkRhbXBlbmluZzoge1xuICAgIHN0b3BEYW1wZW5pbmdBdDogMTIwMCxcbiAgICBhY2NlbGVyYXRlQXQ6IDM2MFxuICB9LFxuICBkaXNhYmxlZDogZmFsc2Vcbn07XG5cbnZhciBnZXREaXN0YW5jZVRocmVzaG9sZHMgPSAoY29udGFpbmVyLCBheGlzLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zID0gKCkgPT4gZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgYXV0b1Njcm9sbGVyT3B0aW9ucyA9IGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKTtcbiAgY29uc3Qgc3RhcnRTY3JvbGxpbmdGcm9tID0gY29udGFpbmVyW2F4aXMuc2l6ZV0gKiBhdXRvU2Nyb2xsZXJPcHRpb25zLnN0YXJ0RnJvbVBlcmNlbnRhZ2U7XG4gIGNvbnN0IG1heFNjcm9sbFZhbHVlQXQgPSBjb250YWluZXJbYXhpcy5zaXplXSAqIGF1dG9TY3JvbGxlck9wdGlvbnMubWF4U2Nyb2xsQXRQZXJjZW50YWdlO1xuICBjb25zdCB0aHJlc2hvbGRzID0ge1xuICAgIHN0YXJ0U2Nyb2xsaW5nRnJvbSxcbiAgICBtYXhTY3JvbGxWYWx1ZUF0XG4gIH07XG4gIHJldHVybiB0aHJlc2hvbGRzO1xufTtcblxudmFyIGdldFBlcmNlbnRhZ2UgPSAoe1xuICBzdGFydE9mUmFuZ2UsXG4gIGVuZE9mUmFuZ2UsXG4gIGN1cnJlbnRcbn0pID0+IHtcbiAgY29uc3QgcmFuZ2UgPSBlbmRPZlJhbmdlIC0gc3RhcnRPZlJhbmdlO1xuICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIERldGVjdGVkIGRpc3RhbmNlIHJhbmdlIG9mIDAgaW4gdGhlIGZsdWlkIGF1dG8gc2Nyb2xsZXJcbiAgICAgIFRoaXMgaXMgdW5leHBlY3RlZCBhbmQgd291bGQgY2F1c2UgYSBkaXZpZGUgYnkgMCBpc3N1ZS5cbiAgICAgIE5vdCBhbGxvd2luZyBhbiBhdXRvIHNjcm9sbFxuICAgIGApIDogdm9pZCAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRJblJhbmdlID0gY3VycmVudCAtIHN0YXJ0T2ZSYW5nZTtcbiAgY29uc3QgcGVyY2VudGFnZSA9IGN1cnJlbnRJblJhbmdlIC8gcmFuZ2U7XG4gIHJldHVybiBwZXJjZW50YWdlO1xufTtcblxudmFyIG1pblNjcm9sbCA9IDE7XG5cbnZhciBnZXRWYWx1ZUZyb21EaXN0YW5jZSA9IChkaXN0YW5jZVRvRWRnZSwgdGhyZXNob2xkcywgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9ICgpID0+IGRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGF1dG9TY3JvbGxlck9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gIGlmIChkaXN0YW5jZVRvRWRnZSA+IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGRpc3RhbmNlVG9FZGdlIDw9IHRocmVzaG9sZHMubWF4U2Nyb2xsVmFsdWVBdCkge1xuICAgIHJldHVybiBhdXRvU2Nyb2xsZXJPcHRpb25zLm1heFBpeGVsU2Nyb2xsO1xuICB9XG4gIGlmIChkaXN0YW5jZVRvRWRnZSA9PT0gdGhyZXNob2xkcy5zdGFydFNjcm9sbGluZ0Zyb20pIHtcbiAgICByZXR1cm4gbWluU2Nyb2xsO1xuICB9XG4gIGNvbnN0IHBlcmNlbnRhZ2VGcm9tTWF4U2Nyb2xsVmFsdWVBdCA9IGdldFBlcmNlbnRhZ2Uoe1xuICAgIHN0YXJ0T2ZSYW5nZTogdGhyZXNob2xkcy5tYXhTY3JvbGxWYWx1ZUF0LFxuICAgIGVuZE9mUmFuZ2U6IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tLFxuICAgIGN1cnJlbnQ6IGRpc3RhbmNlVG9FZGdlXG4gIH0pO1xuICBjb25zdCBwZXJjZW50YWdlRnJvbVN0YXJ0U2Nyb2xsaW5nRnJvbSA9IDEgLSBwZXJjZW50YWdlRnJvbU1heFNjcm9sbFZhbHVlQXQ7XG4gIGNvbnN0IHNjcm9sbCA9IGF1dG9TY3JvbGxlck9wdGlvbnMubWF4UGl4ZWxTY3JvbGwgKiBhdXRvU2Nyb2xsZXJPcHRpb25zLmVhc2UocGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20pO1xuICByZXR1cm4gTWF0aC5jZWlsKHNjcm9sbCk7XG59O1xuXG52YXIgZGFtcGVuVmFsdWVCeVRpbWUgPSAocHJvcG9zZWRTY3JvbGwsIGRyYWdTdGFydFRpbWUsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgYXV0b1Njcm9sbGVyT3B0aW9ucyA9IGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKTtcbiAgY29uc3QgYWNjZWxlcmF0ZUF0ID0gYXV0b1Njcm9sbGVyT3B0aW9ucy5kdXJhdGlvbkRhbXBlbmluZy5hY2NlbGVyYXRlQXQ7XG4gIGNvbnN0IHN0b3BBdCA9IGF1dG9TY3JvbGxlck9wdGlvbnMuZHVyYXRpb25EYW1wZW5pbmcuc3RvcERhbXBlbmluZ0F0O1xuICBjb25zdCBzdGFydE9mUmFuZ2UgPSBkcmFnU3RhcnRUaW1lO1xuICBjb25zdCBlbmRPZlJhbmdlID0gc3RvcEF0O1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICBjb25zdCBydW5UaW1lID0gbm93IC0gc3RhcnRPZlJhbmdlO1xuICBpZiAocnVuVGltZSA+PSBzdG9wQXQpIHtcbiAgICByZXR1cm4gcHJvcG9zZWRTY3JvbGw7XG4gIH1cbiAgaWYgKHJ1blRpbWUgPCBhY2NlbGVyYXRlQXQpIHtcbiAgICByZXR1cm4gbWluU2Nyb2xsO1xuICB9XG4gIGNvbnN0IGJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlID0gZ2V0UGVyY2VudGFnZSh7XG4gICAgc3RhcnRPZlJhbmdlOiBhY2NlbGVyYXRlQXQsXG4gICAgZW5kT2ZSYW5nZSxcbiAgICBjdXJyZW50OiBydW5UaW1lXG4gIH0pO1xuICBjb25zdCBzY3JvbGwgPSBwcm9wb3NlZFNjcm9sbCAqIGF1dG9TY3JvbGxlck9wdGlvbnMuZWFzZShiZXR3ZWVuQWNjZWxlcmF0ZUF0QW5kU3RvcEF0UGVyY2VudGFnZSk7XG4gIHJldHVybiBNYXRoLmNlaWwoc2Nyb2xsKTtcbn07XG5cbnZhciBnZXRWYWx1ZSA9ICh7XG4gIGRpc3RhbmNlVG9FZGdlLFxuICB0aHJlc2hvbGRzLFxuICBkcmFnU3RhcnRUaW1lLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IHNjcm9sbCA9IGdldFZhbHVlRnJvbURpc3RhbmNlKGRpc3RhbmNlVG9FZGdlLCB0aHJlc2hvbGRzLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKTtcbiAgaWYgKHNjcm9sbCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICghc2hvdWxkVXNlVGltZURhbXBlbmluZykge1xuICAgIHJldHVybiBzY3JvbGw7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KGRhbXBlblZhbHVlQnlUaW1lKHNjcm9sbCwgZHJhZ1N0YXJ0VGltZSwgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyksIG1pblNjcm9sbCk7XG59O1xuXG52YXIgZ2V0U2Nyb2xsT25BeGlzID0gKHtcbiAgY29udGFpbmVyLFxuICBkaXN0YW5jZVRvRWRnZXMsXG4gIGRyYWdTdGFydFRpbWUsXG4gIGF4aXMsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgdGhyZXNob2xkcyA9IGdldERpc3RhbmNlVGhyZXNob2xkcyhjb250YWluZXIsIGF4aXMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpO1xuICBjb25zdCBpc0Nsb3NlclRvRW5kID0gZGlzdGFuY2VUb0VkZ2VzW2F4aXMuZW5kXSA8IGRpc3RhbmNlVG9FZGdlc1theGlzLnN0YXJ0XTtcbiAgaWYgKGlzQ2xvc2VyVG9FbmQpIHtcbiAgICByZXR1cm4gZ2V0VmFsdWUoe1xuICAgICAgZGlzdGFuY2VUb0VkZ2U6IGRpc3RhbmNlVG9FZGdlc1theGlzLmVuZF0sXG4gICAgICB0aHJlc2hvbGRzLFxuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC0xICogZ2V0VmFsdWUoe1xuICAgIGRpc3RhbmNlVG9FZGdlOiBkaXN0YW5jZVRvRWRnZXNbYXhpcy5zdGFydF0sXG4gICAgdGhyZXNob2xkcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbn07XG5cbnZhciBhZGp1c3RGb3JTaXplTGltaXRzID0gKHtcbiAgY29udGFpbmVyLFxuICBzdWJqZWN0LFxuICBwcm9wb3NlZFNjcm9sbFxufSkgPT4ge1xuICBjb25zdCBpc1Rvb0JpZ1ZlcnRpY2FsbHkgPSBzdWJqZWN0LmhlaWdodCA+IGNvbnRhaW5lci5oZWlnaHQ7XG4gIGNvbnN0IGlzVG9vQmlnSG9yaXpvbnRhbGx5ID0gc3ViamVjdC53aWR0aCA+IGNvbnRhaW5lci53aWR0aDtcbiAgaWYgKCFpc1Rvb0JpZ0hvcml6b250YWxseSAmJiAhaXNUb29CaWdWZXJ0aWNhbGx5KSB7XG4gICAgcmV0dXJuIHByb3Bvc2VkU2Nyb2xsO1xuICB9XG4gIGlmIChpc1Rvb0JpZ0hvcml6b250YWxseSAmJiBpc1Rvb0JpZ1ZlcnRpY2FsbHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IGlzVG9vQmlnSG9yaXpvbnRhbGx5ID8gMCA6IHByb3Bvc2VkU2Nyb2xsLngsXG4gICAgeTogaXNUb29CaWdWZXJ0aWNhbGx5ID8gMCA6IHByb3Bvc2VkU2Nyb2xsLnlcbiAgfTtcbn07XG5cbmNvbnN0IGNsZWFuID0gYXBwbHkodmFsdWUgPT4gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUpO1xudmFyIGdldFNjcm9sbCQxID0gKHtcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgY29udGFpbmVyLFxuICBzdWJqZWN0LFxuICBjZW50ZXIsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgZGlzdGFuY2VUb0VkZ2VzID0ge1xuICAgIHRvcDogY2VudGVyLnkgLSBjb250YWluZXIudG9wLFxuICAgIHJpZ2h0OiBjb250YWluZXIucmlnaHQgLSBjZW50ZXIueCxcbiAgICBib3R0b206IGNvbnRhaW5lci5ib3R0b20gLSBjZW50ZXIueSxcbiAgICBsZWZ0OiBjZW50ZXIueCAtIGNvbnRhaW5lci5sZWZ0XG4gIH07XG4gIGNvbnN0IHkgPSBnZXRTY3JvbGxPbkF4aXMoe1xuICAgIGNvbnRhaW5lcixcbiAgICBkaXN0YW5jZVRvRWRnZXMsXG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBheGlzOiB2ZXJ0aWNhbCxcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IHggPSBnZXRTY3JvbGxPbkF4aXMoe1xuICAgIGNvbnRhaW5lcixcbiAgICBkaXN0YW5jZVRvRWRnZXMsXG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBheGlzOiBob3Jpem9udGFsLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgY29uc3QgcmVxdWlyZWQgPSBjbGVhbih7XG4gICAgeCxcbiAgICB5XG4gIH0pO1xuICBpZiAoaXNFcXVhbCQxKHJlcXVpcmVkLCBvcmlnaW4pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbGltaXRlZCA9IGFkanVzdEZvclNpemVMaW1pdHMoe1xuICAgIGNvbnRhaW5lcixcbiAgICBzdWJqZWN0LFxuICAgIHByb3Bvc2VkU2Nyb2xsOiByZXF1aXJlZFxuICB9KTtcbiAgaWYgKCFsaW1pdGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGlzRXF1YWwkMShsaW1pdGVkLCBvcmlnaW4pID8gbnVsbCA6IGxpbWl0ZWQ7XG59O1xuXG5jb25zdCBzbWFsbGVzdFNpZ25lZCA9IGFwcGx5KHZhbHVlID0+IHtcbiAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID4gMCA/IDEgOiAtMTtcbn0pO1xuY29uc3QgZ2V0T3ZlcmxhcCA9ICgoKSA9PiB7XG4gIGNvbnN0IGdldFJlbWFpbmRlciA9ICh0YXJnZXQsIG1heCkgPT4ge1xuICAgIGlmICh0YXJnZXQgPCAwKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID4gbWF4KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0IC0gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgcmV0dXJuICh7XG4gICAgY3VycmVudCxcbiAgICBtYXgsXG4gICAgY2hhbmdlXG4gIH0pID0+IHtcbiAgICBjb25zdCB0YXJnZXRTY3JvbGwgPSBhZGQoY3VycmVudCwgY2hhbmdlKTtcbiAgICBjb25zdCBvdmVybGFwID0ge1xuICAgICAgeDogZ2V0UmVtYWluZGVyKHRhcmdldFNjcm9sbC54LCBtYXgueCksXG4gICAgICB5OiBnZXRSZW1haW5kZXIodGFyZ2V0U2Nyb2xsLnksIG1heC55KVxuICAgIH07XG4gICAgaWYgKGlzRXF1YWwkMShvdmVybGFwLCBvcmlnaW4pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJsYXA7XG4gIH07XG59KSgpO1xuY29uc3QgY2FuUGFydGlhbGx5U2Nyb2xsID0gKHtcbiAgbWF4OiByYXdNYXgsXG4gIGN1cnJlbnQsXG4gIGNoYW5nZVxufSkgPT4ge1xuICBjb25zdCBtYXggPSB7XG4gICAgeDogTWF0aC5tYXgoY3VycmVudC54LCByYXdNYXgueCksXG4gICAgeTogTWF0aC5tYXgoY3VycmVudC55LCByYXdNYXgueSlcbiAgfTtcbiAgY29uc3Qgc21hbGxlc3RDaGFuZ2UgPSBzbWFsbGVzdFNpZ25lZChjaGFuZ2UpO1xuICBjb25zdCBvdmVybGFwID0gZ2V0T3ZlcmxhcCh7XG4gICAgbWF4LFxuICAgIGN1cnJlbnQsXG4gICAgY2hhbmdlOiBzbWFsbGVzdENoYW5nZVxuICB9KTtcbiAgaWYgKCFvdmVybGFwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNtYWxsZXN0Q2hhbmdlLnggIT09IDAgJiYgb3ZlcmxhcC54ID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNtYWxsZXN0Q2hhbmdlLnkgIT09IDAgJiYgb3ZlcmxhcC55ID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGNhblNjcm9sbFdpbmRvdyA9ICh2aWV3cG9ydCwgY2hhbmdlKSA9PiBjYW5QYXJ0aWFsbHlTY3JvbGwoe1xuICBjdXJyZW50OiB2aWV3cG9ydC5zY3JvbGwuY3VycmVudCxcbiAgbWF4OiB2aWV3cG9ydC5zY3JvbGwubWF4LFxuICBjaGFuZ2Vcbn0pO1xuY29uc3QgZ2V0V2luZG93T3ZlcmxhcCA9ICh2aWV3cG9ydCwgY2hhbmdlKSA9PiB7XG4gIGlmICghY2FuU2Nyb2xsV2luZG93KHZpZXdwb3J0LCBjaGFuZ2UpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbWF4ID0gdmlld3BvcnQuc2Nyb2xsLm1heDtcbiAgY29uc3QgY3VycmVudCA9IHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50O1xuICByZXR1cm4gZ2V0T3ZlcmxhcCh7XG4gICAgY3VycmVudCxcbiAgICBtYXgsXG4gICAgY2hhbmdlXG4gIH0pO1xufTtcbmNvbnN0IGNhblNjcm9sbERyb3BwYWJsZSA9IChkcm9wcGFibGUsIGNoYW5nZSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gY2FuUGFydGlhbGx5U2Nyb2xsKHtcbiAgICBjdXJyZW50OiBmcmFtZS5zY3JvbGwuY3VycmVudCxcbiAgICBtYXg6IGZyYW1lLnNjcm9sbC5tYXgsXG4gICAgY2hhbmdlXG4gIH0pO1xufTtcbmNvbnN0IGdldERyb3BwYWJsZU92ZXJsYXAgPSAoZHJvcHBhYmxlLCBjaGFuZ2UpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIGNoYW5nZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZ2V0T3ZlcmxhcCh7XG4gICAgY3VycmVudDogZnJhbWUuc2Nyb2xsLmN1cnJlbnQsXG4gICAgbWF4OiBmcmFtZS5zY3JvbGwubWF4LFxuICAgIGNoYW5nZVxuICB9KTtcbn07XG5cbnZhciBnZXRXaW5kb3dTY3JvbGxDaGFuZ2UgPSAoe1xuICB2aWV3cG9ydCxcbiAgc3ViamVjdCxcbiAgY2VudGVyLFxuICBkcmFnU3RhcnRUaW1lLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IHNjcm9sbCA9IGdldFNjcm9sbCQxKHtcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGNvbnRhaW5lcjogdmlld3BvcnQuZnJhbWUsXG4gICAgc3ViamVjdCxcbiAgICBjZW50ZXIsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICByZXR1cm4gc2Nyb2xsICYmIGNhblNjcm9sbFdpbmRvdyh2aWV3cG9ydCwgc2Nyb2xsKSA/IHNjcm9sbCA6IG51bGw7XG59O1xuXG52YXIgZ2V0RHJvcHBhYmxlU2Nyb2xsQ2hhbmdlID0gKHtcbiAgZHJvcHBhYmxlLFxuICBzdWJqZWN0LFxuICBjZW50ZXIsXG4gIGRyYWdTdGFydFRpbWUsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzY3JvbGwgPSBnZXRTY3JvbGwkMSh7XG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBjb250YWluZXI6IGZyYW1lLnBhZ2VNYXJnaW5Cb3gsXG4gICAgc3ViamVjdCxcbiAgICBjZW50ZXIsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICByZXR1cm4gc2Nyb2xsICYmIGNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIHNjcm9sbCkgPyBzY3JvbGwgOiBudWxsO1xufTtcblxudmFyIHNjcm9sbCA9ICh7XG4gIHN0YXRlLFxuICBkcmFnU3RhcnRUaW1lLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBzY3JvbGxXaW5kb3csXG4gIHNjcm9sbERyb3BwYWJsZSxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBjZW50ZXIgPSBzdGF0ZS5jdXJyZW50LnBhZ2UuYm9yZGVyQm94Q2VudGVyO1xuICBjb25zdCBkcmFnZ2FibGUgPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3Qgc3ViamVjdCA9IGRyYWdnYWJsZS5wYWdlLm1hcmdpbkJveDtcbiAgaWYgKHN0YXRlLmlzV2luZG93U2Nyb2xsQWxsb3dlZCkge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gc3RhdGUudmlld3BvcnQ7XG4gICAgY29uc3QgY2hhbmdlID0gZ2V0V2luZG93U2Nyb2xsQ2hhbmdlKHtcbiAgICAgIGRyYWdTdGFydFRpbWUsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHN1YmplY3QsXG4gICAgICBjZW50ZXIsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgIHNjcm9sbFdpbmRvdyhjaGFuZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCBkcm9wcGFibGUgPSBnZXRCZXN0U2Nyb2xsYWJsZURyb3BwYWJsZSh7XG4gICAgY2VudGVyLFxuICAgIGRlc3RpbmF0aW9uOiB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpLFxuICAgIGRyb3BwYWJsZXM6IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1xuICB9KTtcbiAgaWYgKCFkcm9wcGFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY2hhbmdlID0gZ2V0RHJvcHBhYmxlU2Nyb2xsQ2hhbmdlKHtcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGRyb3BwYWJsZSxcbiAgICBzdWJqZWN0LFxuICAgIGNlbnRlcixcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIGlmIChjaGFuZ2UpIHtcbiAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGNoYW5nZSk7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVGbHVpZFNjcm9sbGVyID0gKHtcbiAgc2Nyb2xsV2luZG93LFxuICBzY3JvbGxEcm9wcGFibGUsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnMgPSAoKSA9PiBkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBzY2hlZHVsZVdpbmRvd1Njcm9sbCA9IHJhZlNjaGQoc2Nyb2xsV2luZG93KTtcbiAgY29uc3Qgc2NoZWR1bGVEcm9wcGFibGVTY3JvbGwgPSByYWZTY2hkKHNjcm9sbERyb3BwYWJsZSk7XG4gIGxldCBkcmFnZ2luZyA9IG51bGw7XG4gIGNvbnN0IHRyeVNjcm9sbCA9IHN0YXRlID0+IHtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmx1aWQgc2Nyb2xsIGlmIG5vdCBkcmFnZ2luZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICAgIGRyYWdTdGFydFRpbWVcbiAgICB9ID0gZHJhZ2dpbmc7XG4gICAgc2Nyb2xsKHtcbiAgICAgIHN0YXRlLFxuICAgICAgc2Nyb2xsV2luZG93OiBzY2hlZHVsZVdpbmRvd1Njcm9sbCxcbiAgICAgIHNjcm9sbERyb3BwYWJsZTogc2NoZWR1bGVEcm9wcGFibGVTY3JvbGwsXG4gICAgICBkcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc3RhcnQkMSA9IHN0YXRlID0+IHtcbiAgICBzdGFydCgpO1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RhcnQgYXV0byBzY3JvbGxpbmcgd2hlbiBhbHJlYWR5IHN0YXJ0ZWQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGRyYWdTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCB3YXNTY3JvbGxOZWVkZWQgPSBmYWxzZTtcbiAgICBjb25zdCBmYWtlU2Nyb2xsQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB3YXNTY3JvbGxOZWVkZWQgPSB0cnVlO1xuICAgIH07XG4gICAgc2Nyb2xsKHtcbiAgICAgIHN0YXRlLFxuICAgICAgZHJhZ1N0YXJ0VGltZTogMCxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IGZhbHNlLFxuICAgICAgc2Nyb2xsV2luZG93OiBmYWtlU2Nyb2xsQ2FsbGJhY2ssXG4gICAgICBzY3JvbGxEcm9wcGFibGU6IGZha2VTY3JvbGxDYWxsYmFjayxcbiAgICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgICB9KTtcbiAgICBkcmFnZ2luZyA9IHtcbiAgICAgIGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiB3YXNTY3JvbGxOZWVkZWRcbiAgICB9O1xuICAgIGZpbmlzaCgpO1xuICAgIGlmICh3YXNTY3JvbGxOZWVkZWQpIHtcbiAgICAgIHRyeVNjcm9sbChzdGF0ZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGVXaW5kb3dTY3JvbGwuY2FuY2VsKCk7XG4gICAgc2NoZWR1bGVEcm9wcGFibGVTY3JvbGwuY2FuY2VsKCk7XG4gICAgZHJhZ2dpbmcgPSBudWxsO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCQxLFxuICAgIHN0b3AsXG4gICAgc2Nyb2xsOiB0cnlTY3JvbGxcbiAgfTtcbn07XG5cbnZhciBjcmVhdGVKdW1wU2Nyb2xsZXIgPSAoe1xuICBtb3ZlLFxuICBzY3JvbGxEcm9wcGFibGUsXG4gIHNjcm9sbFdpbmRvd1xufSkgPT4ge1xuICBjb25zdCBtb3ZlQnlPZmZzZXQgPSAoc3RhdGUsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IGFkZChzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb24sIG9mZnNldCk7XG4gICAgbW92ZSh7XG4gICAgICBjbGllbnRcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc2Nyb2xsRHJvcHBhYmxlQXNNdWNoQXNJdENhbiA9IChkcm9wcGFibGUsIGNoYW5nZSkgPT4ge1xuICAgIGlmICghY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgY2hhbmdlKSkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgY29uc3Qgb3ZlcmxhcCA9IGdldERyb3BwYWJsZU92ZXJsYXAoZHJvcHBhYmxlLCBjaGFuZ2UpO1xuICAgIGlmICghb3ZlcmxhcCkge1xuICAgICAgc2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBjaGFuZ2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHdoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwgPSBzdWJ0cmFjdChjaGFuZ2UsIG92ZXJsYXApO1xuICAgIHNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgd2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCk7XG4gICAgY29uc3QgcmVtYWluZGVyID0gc3VidHJhY3QoY2hhbmdlLCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsKTtcbiAgICByZXR1cm4gcmVtYWluZGVyO1xuICB9O1xuICBjb25zdCBzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuID0gKGlzV2luZG93U2Nyb2xsQWxsb3dlZCwgdmlld3BvcnQsIGNoYW5nZSkgPT4ge1xuICAgIGlmICghaXNXaW5kb3dTY3JvbGxBbGxvd2VkKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBpZiAoIWNhblNjcm9sbFdpbmRvdyh2aWV3cG9ydCwgY2hhbmdlKSkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgY29uc3Qgb3ZlcmxhcCA9IGdldFdpbmRvd092ZXJsYXAodmlld3BvcnQsIGNoYW5nZSk7XG4gICAgaWYgKCFvdmVybGFwKSB7XG4gICAgICBzY3JvbGxXaW5kb3coY2hhbmdlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB3aGF0VGhlV2luZG93Q2FuU2Nyb2xsID0gc3VidHJhY3QoY2hhbmdlLCBvdmVybGFwKTtcbiAgICBzY3JvbGxXaW5kb3cod2hhdFRoZVdpbmRvd0NhblNjcm9sbCk7XG4gICAgY29uc3QgcmVtYWluZGVyID0gc3VidHJhY3QoY2hhbmdlLCB3aGF0VGhlV2luZG93Q2FuU2Nyb2xsKTtcbiAgICByZXR1cm4gcmVtYWluZGVyO1xuICB9O1xuICBjb25zdCBqdW1wU2Nyb2xsZXIgPSBzdGF0ZSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHN0YXRlLnNjcm9sbEp1bXBSZXF1ZXN0O1xuICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCk7XG4gICAgIWRlc3RpbmF0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHBlcmZvcm0gYSBqdW1wIHNjcm9sbCB3aGVuIHRoZXJlIGlzIG5vIGRlc3RpbmF0aW9uJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBkcm9wcGFibGVSZW1haW5kZXIgPSBzY3JvbGxEcm9wcGFibGVBc011Y2hBc0l0Q2FuKHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tkZXN0aW5hdGlvbl0sIHJlcXVlc3QpO1xuICAgIGlmICghZHJvcHBhYmxlUmVtYWluZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZXdwb3J0ID0gc3RhdGUudmlld3BvcnQ7XG4gICAgY29uc3Qgd2luZG93UmVtYWluZGVyID0gc2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbihzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQsIHZpZXdwb3J0LCBkcm9wcGFibGVSZW1haW5kZXIpO1xuICAgIGlmICghd2luZG93UmVtYWluZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1vdmVCeU9mZnNldChzdGF0ZSwgd2luZG93UmVtYWluZGVyKTtcbiAgfTtcbiAgcmV0dXJuIGp1bXBTY3JvbGxlcjtcbn07XG5cbnZhciBjcmVhdGVBdXRvU2Nyb2xsZXIgPSAoe1xuICBzY3JvbGxEcm9wcGFibGUsXG4gIHNjcm9sbFdpbmRvdyxcbiAgbW92ZSxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBmbHVpZFNjcm9sbGVyID0gY3JlYXRlRmx1aWRTY3JvbGxlcih7XG4gICAgc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZSxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBjb25zdCBqdW1wU2Nyb2xsID0gY3JlYXRlSnVtcFNjcm9sbGVyKHtcbiAgICBtb3ZlLFxuICAgIHNjcm9sbFdpbmRvdyxcbiAgICBzY3JvbGxEcm9wcGFibGVcbiAgfSk7XG4gIGNvbnN0IHNjcm9sbCA9IHN0YXRlID0+IHtcbiAgICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICAgIGlmIChhdXRvU2Nyb2xsZXJPcHRpb25zLmRpc2FibGVkIHx8IHN0YXRlLnBoYXNlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdGTFVJRCcpIHtcbiAgICAgIGZsdWlkU2Nyb2xsZXIuc2Nyb2xsKHN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5zY3JvbGxKdW1wUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBqdW1wU2Nyb2xsKHN0YXRlKTtcbiAgfTtcbiAgY29uc3Qgc2Nyb2xsZXIgPSB7XG4gICAgc2Nyb2xsLFxuICAgIHN0YXJ0OiBmbHVpZFNjcm9sbGVyLnN0YXJ0LFxuICAgIHN0b3A6IGZsdWlkU2Nyb2xsZXIuc3RvcFxuICB9O1xuICByZXR1cm4gc2Nyb2xsZXI7XG59O1xuXG5jb25zdCBwcmVmaXggPSAnZGF0YS1yZmQnO1xuY29uc3QgZHJhZ0hhbmRsZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBgJHtwcmVmaXh9LWRyYWctaGFuZGxlYDtcbiAgcmV0dXJuIHtcbiAgICBiYXNlLFxuICAgIGRyYWdnYWJsZUlkOiBgJHtiYXNlfS1kcmFnZ2FibGUtaWRgLFxuICAgIGNvbnRleHRJZDogYCR7YmFzZX0tY29udGV4dC1pZGBcbiAgfTtcbn0pKCk7XG5jb25zdCBkcmFnZ2FibGUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gYCR7cHJlZml4fS1kcmFnZ2FibGVgO1xuICByZXR1cm4ge1xuICAgIGJhc2UsXG4gICAgY29udGV4dElkOiBgJHtiYXNlfS1jb250ZXh0LWlkYCxcbiAgICBpZDogYCR7YmFzZX0taWRgXG4gIH07XG59KSgpO1xuY29uc3QgZHJvcHBhYmxlID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9IGAke3ByZWZpeH0tZHJvcHBhYmxlYDtcbiAgcmV0dXJuIHtcbiAgICBiYXNlLFxuICAgIGNvbnRleHRJZDogYCR7YmFzZX0tY29udGV4dC1pZGAsXG4gICAgaWQ6IGAke2Jhc2V9LWlkYFxuICB9O1xufSkoKTtcbmNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHtcbiAgY29udGV4dElkOiBgJHtwcmVmaXh9LXNjcm9sbC1jb250YWluZXItY29udGV4dC1pZGBcbn07XG5cbmNvbnN0IG1ha2VHZXRTZWxlY3RvciA9IGNvbnRleHQgPT4gYXR0cmlidXRlID0+IGBbJHthdHRyaWJ1dGV9PVwiJHtjb250ZXh0fVwiXWA7XG5jb25zdCBnZXRTdHlsZXMgPSAocnVsZXMsIHByb3BlcnR5KSA9PiBydWxlcy5tYXAocnVsZSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gcnVsZS5zdHlsZXNbcHJvcGVydHldO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBgJHtydWxlLnNlbGVjdG9yfSB7ICR7dmFsdWV9IH1gO1xufSkuam9pbignICcpO1xuY29uc3Qgbm9Qb2ludGVyRXZlbnRzID0gJ3BvaW50ZXItZXZlbnRzOiBub25lOyc7XG52YXIgZ2V0U3R5bGVzJDEgPSBjb250ZXh0SWQgPT4ge1xuICBjb25zdCBnZXRTZWxlY3RvciA9IG1ha2VHZXRTZWxlY3Rvcihjb250ZXh0SWQpO1xuICBjb25zdCBkcmFnSGFuZGxlJDEgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGdyYWJDdXJzb3IgPSBgXG4gICAgICBjdXJzb3I6IC13ZWJraXQtZ3JhYjtcbiAgICAgIGN1cnNvcjogZ3JhYjtcbiAgICBgO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RvcjogZ2V0U2VsZWN0b3IoZHJhZ0hhbmRsZS5jb250ZXh0SWQpLFxuICAgICAgc3R5bGVzOiB7XG4gICAgICAgIGFsd2F5czogYFxuICAgICAgICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcbiAgICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwwLDAsMCk7XG4gICAgICAgICAgdG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb247XG4gICAgICAgIGAsXG4gICAgICAgIHJlc3Rpbmc6IGdyYWJDdXJzb3IsXG4gICAgICAgIGRyYWdnaW5nOiBub1BvaW50ZXJFdmVudHMsXG4gICAgICAgIGRyb3BBbmltYXRpbmc6IGdyYWJDdXJzb3JcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuICBjb25zdCBkcmFnZ2FibGUkMSA9ICgoKSA9PiB7XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IGBcbiAgICAgIHRyYW5zaXRpb246ICR7dHJhbnNpdGlvbnMub3V0T2ZUaGVXYXl9O1xuICAgIGA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdG9yOiBnZXRTZWxlY3RvcihkcmFnZ2FibGUuY29udGV4dElkKSxcbiAgICAgIHN0eWxlczoge1xuICAgICAgICBkcmFnZ2luZzogdHJhbnNpdGlvbixcbiAgICAgICAgZHJvcEFuaW1hdGluZzogdHJhbnNpdGlvbixcbiAgICAgICAgdXNlckNhbmNlbDogdHJhbnNpdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGRyb3BwYWJsZSQxID0ge1xuICAgIHNlbGVjdG9yOiBnZXRTZWxlY3Rvcihkcm9wcGFibGUuY29udGV4dElkKSxcbiAgICBzdHlsZXM6IHtcbiAgICAgIGFsd2F5czogYG92ZXJmbG93LWFuY2hvcjogbm9uZTtgXG4gICAgfVxuICB9O1xuICBjb25zdCBib2R5ID0ge1xuICAgIHNlbGVjdG9yOiAnYm9keScsXG4gICAgc3R5bGVzOiB7XG4gICAgICBkcmFnZ2luZzogYFxuICAgICAgICBjdXJzb3I6IGdyYWJiaW5nO1xuICAgICAgICBjdXJzb3I6IC13ZWJraXQtZ3JhYmJpbmc7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIG92ZXJmbG93LWFuY2hvcjogbm9uZTtcbiAgICAgIGBcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJ1bGVzID0gW2RyYWdnYWJsZSQxLCBkcmFnSGFuZGxlJDEsIGRyb3BwYWJsZSQxLCBib2R5XTtcbiAgcmV0dXJuIHtcbiAgICBhbHdheXM6IGdldFN0eWxlcyhydWxlcywgJ2Fsd2F5cycpLFxuICAgIHJlc3Rpbmc6IGdldFN0eWxlcyhydWxlcywgJ3Jlc3RpbmcnKSxcbiAgICBkcmFnZ2luZzogZ2V0U3R5bGVzKHJ1bGVzLCAnZHJhZ2dpbmcnKSxcbiAgICBkcm9wQW5pbWF0aW5nOiBnZXRTdHlsZXMocnVsZXMsICdkcm9wQW5pbWF0aW5nJyksXG4gICAgdXNlckNhbmNlbDogZ2V0U3R5bGVzKHJ1bGVzLCAndXNlckNhbmNlbCcpXG4gIH07XG59O1xuXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuY29uc3QgZ2V0SGVhZCA9ICgpID0+IHtcbiAgY29uc3QgaGVhZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbiAgIWhlYWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCB0aGUgaGVhZCB0byBhcHBlbmQgYSBzdHlsZSB0bycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiBoZWFkO1xufTtcbmNvbnN0IGNyZWF0ZVN0eWxlRWwgPSBub25jZSA9PiB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgaWYgKG5vbmNlKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgfVxuICBlbC50eXBlID0gJ3RleHQvY3NzJztcbiAgcmV0dXJuIGVsO1xufTtcbmZ1bmN0aW9uIHVzZVN0eWxlTWFyc2hhbChjb250ZXh0SWQsIG5vbmNlKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZU1lbW8oKCkgPT4gZ2V0U3R5bGVzJDEoY29udGV4dElkKSwgW2NvbnRleHRJZF0pO1xuICBjb25zdCBhbHdheXNSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGR5bmFtaWNSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldER5bmFtaWNTdHlsZSA9IHVzZUNhbGxiYWNrKG1lbW9pemVPbmUocHJvcG9zZWQgPT4ge1xuICAgIGNvbnN0IGVsID0gZHluYW1pY1JlZi5jdXJyZW50O1xuICAgICFlbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzZXQgZHluYW1pYyBzdHlsZSBlbGVtZW50IGlmIGl0IGlzIG5vdCBzZXQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGVsLnRleHRDb250ZW50ID0gcHJvcG9zZWQ7XG4gIH0pLCBbXSk7XG4gIGNvbnN0IHNldEFsd2F5c1N0eWxlID0gdXNlQ2FsbGJhY2socHJvcG9zZWQgPT4ge1xuICAgIGNvbnN0IGVsID0gYWx3YXlzUmVmLmN1cnJlbnQ7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNldCBkeW5hbWljIHN0eWxlIGVsZW1lbnQgaWYgaXQgaXMgbm90IHNldCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgZWwudGV4dENvbnRlbnQgPSBwcm9wb3NlZDtcbiAgfSwgW10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAhKCFhbHdheXNSZWYuY3VycmVudCAmJiAhZHluYW1pY1JlZi5jdXJyZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ3N0eWxlIGVsZW1lbnRzIGFscmVhZHkgbW91bnRlZCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgYWx3YXlzID0gY3JlYXRlU3R5bGVFbChub25jZSk7XG4gICAgY29uc3QgZHluYW1pYyA9IGNyZWF0ZVN0eWxlRWwobm9uY2UpO1xuICAgIGFsd2F5c1JlZi5jdXJyZW50ID0gYWx3YXlzO1xuICAgIGR5bmFtaWNSZWYuY3VycmVudCA9IGR5bmFtaWM7XG4gICAgYWx3YXlzLnNldEF0dHJpYnV0ZShgJHtwcmVmaXh9LWFsd2F5c2AsIGNvbnRleHRJZCk7XG4gICAgZHluYW1pYy5zZXRBdHRyaWJ1dGUoYCR7cHJlZml4fS1keW5hbWljYCwgY29udGV4dElkKTtcbiAgICBnZXRIZWFkKCkuYXBwZW5kQ2hpbGQoYWx3YXlzKTtcbiAgICBnZXRIZWFkKCkuYXBwZW5kQ2hpbGQoZHluYW1pYyk7XG4gICAgc2V0QWx3YXlzU3R5bGUoc3R5bGVzLmFsd2F5cyk7XG4gICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5yZXN0aW5nKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgcmVtb3ZlID0gcmVmID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAhY3VycmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCB1bm1vdW50IHJlZiBhcyBpdCBpcyBub3Qgc2V0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICAgICAgZ2V0SGVhZCgpLnJlbW92ZUNoaWxkKGN1cnJlbnQpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgcmVtb3ZlKGFsd2F5c1JlZik7XG4gICAgICByZW1vdmUoZHluYW1pY1JlZik7XG4gICAgfTtcbiAgfSwgW25vbmNlLCBzZXRBbHdheXNTdHlsZSwgc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuYWx3YXlzLCBzdHlsZXMucmVzdGluZywgY29udGV4dElkXSk7XG4gIGNvbnN0IGRyYWdnaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5kcmFnZ2luZyksIFtzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5kcmFnZ2luZ10pO1xuICBjb25zdCBkcm9wcGluZyA9IHVzZUNhbGxiYWNrKHJlYXNvbiA9PiB7XG4gICAgaWYgKHJlYXNvbiA9PT0gJ0RST1AnKSB7XG4gICAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLmRyb3BBbmltYXRpbmcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnVzZXJDYW5jZWwpO1xuICB9LCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuZHJvcEFuaW1hdGluZywgc3R5bGVzLnVzZXJDYW5jZWxdKTtcbiAgY29uc3QgcmVzdGluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWR5bmFtaWNSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnJlc3RpbmcpO1xuICB9LCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMucmVzdGluZ10pO1xuICBjb25zdCBtYXJzaGFsID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGRyYWdnaW5nLFxuICAgIGRyb3BwaW5nLFxuICAgIHJlc3RpbmdcbiAgfSksIFtkcmFnZ2luZywgZHJvcHBpbmcsIHJlc3RpbmddKTtcbiAgcmV0dXJuIG1hcnNoYWw7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwocGFyZW50Tm9kZSwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5cbnZhciBnZXRXaW5kb3dGcm9tRWwgPSBlbCA9PiB7XG4gIGlmIChlbCAmJiBlbC5vd25lckRvY3VtZW50ICYmIGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcbiAgICByZXR1cm4gZWwub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgfVxuICByZXR1cm4gd2luZG93O1xufTtcblxuZnVuY3Rpb24gaXNIdG1sRWxlbWVudChlbCkge1xuICByZXR1cm4gZWwgaW5zdGFuY2VvZiBnZXRXaW5kb3dGcm9tRWwoZWwpLkhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBmaW5kRHJhZ0hhbmRsZShjb250ZXh0SWQsIGRyYWdnYWJsZUlkKSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gYFske2RyYWdIYW5kbGUuY29udGV4dElkfT1cIiR7Y29udGV4dElkfVwiXWA7XG4gIGNvbnN0IHBvc3NpYmxlID0gcXVlcnlTZWxlY3RvckFsbChkb2N1bWVudCwgc2VsZWN0b3IpO1xuICBpZiAoIXBvc3NpYmxlLmxlbmd0aCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFVuYWJsZSB0byBmaW5kIGFueSBkcmFnIGhhbmRsZXMgaW4gdGhlIGNvbnRleHQgXCIke2NvbnRleHRJZH1cImApIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGhhbmRsZSA9IHBvc3NpYmxlLmZpbmQoZWwgPT4ge1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoZHJhZ0hhbmRsZS5kcmFnZ2FibGVJZCkgPT09IGRyYWdnYWJsZUlkO1xuICB9KTtcbiAgaWYgKCFoYW5kbGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBVbmFibGUgdG8gZmluZCBkcmFnIGhhbmRsZSB3aXRoIGlkIFwiJHtkcmFnZ2FibGVJZH1cIiBhcyBubyBoYW5kbGUgd2l0aCBhIG1hdGNoaW5nIGlkIHdhcyBmb3VuZGApIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaXNIdG1sRWxlbWVudChoYW5kbGUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZHJhZyBoYW5kbGUgbmVlZHMgdG8gYmUgYSBIVE1MRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBoYW5kbGU7XG59XG5cbmZ1bmN0aW9uIHVzZUZvY3VzTWFyc2hhbChjb250ZXh0SWQpIHtcbiAgY29uc3QgZW50cmllc1JlZiA9IHVzZVJlZih7fSk7XG4gIGNvbnN0IHJlY29yZFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcmVzdG9yZUZvY3VzRnJhbWVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGlzTW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHJlZ2lzdGVyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gcmVnaXN0ZXIoaWQsIGZvY3VzKSB7XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICBpZCxcbiAgICAgIGZvY3VzXG4gICAgfTtcbiAgICBlbnRyaWVzUmVmLmN1cnJlbnRbaWRdID0gZW50cnk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVucmVnaXN0ZXIoKSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gZW50cmllc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgY3VycmVudCA9IGVudHJpZXNbaWRdO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IGVudHJ5KSB7XG4gICAgICAgIGRlbGV0ZSBlbnRyaWVzW2lkXTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IHRyeUdpdmVGb2N1cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeUdpdmVGb2N1cyh0cnlHaXZlRm9jdXNUbykge1xuICAgIGNvbnN0IGhhbmRsZSA9IGZpbmREcmFnSGFuZGxlKGNvbnRleHRJZCwgdHJ5R2l2ZUZvY3VzVG8pO1xuICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICBoYW5kbGUuZm9jdXMoKTtcbiAgICB9XG4gIH0sIFtjb250ZXh0SWRdKTtcbiAgY29uc3QgdHJ5U2hpZnRSZWNvcmQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlTaGlmdFJlY29yZChwcmV2aW91cywgcmVkaXJlY3RUbykge1xuICAgIGlmIChyZWNvcmRSZWYuY3VycmVudCA9PT0gcHJldmlvdXMpIHtcbiAgICAgIHJlY29yZFJlZi5jdXJyZW50ID0gcmVkaXJlY3RUbztcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpIHtcbiAgICBpZiAocmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBjb25zdCByZWNvcmQgPSByZWNvcmRSZWYuY3VycmVudDtcbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgdHJ5R2l2ZUZvY3VzKHJlY29yZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFt0cnlHaXZlRm9jdXNdKTtcbiAgY29uc3QgdHJ5UmVjb3JkRm9jdXMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlSZWNvcmRGb2N1cyhpZCkge1xuICAgIHJlY29yZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICBjb25zdCBmb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoIWZvY3VzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZvY3VzZWQuZ2V0QXR0cmlidXRlKGRyYWdIYW5kbGUuZHJhZ2dhYmxlSWQpICE9PSBpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWNvcmRSZWYuY3VycmVudCA9IGlkO1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJGcmFtZU9uVW5tb3VudCgpIHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBjb25zdCBmcmFtZUlkID0gcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudDtcbiAgICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbWFyc2hhbCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWdpc3RlcixcbiAgICB0cnlSZWNvcmRGb2N1cyxcbiAgICB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCxcbiAgICB0cnlTaGlmdFJlY29yZFxuICB9KSwgW3JlZ2lzdGVyLCB0cnlSZWNvcmRGb2N1cywgdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQsIHRyeVNoaWZ0UmVjb3JkXSk7XG4gIHJldHVybiBtYXJzaGFsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZWdpc3RyeSgpIHtcbiAgY29uc3QgZW50cmllcyA9IHtcbiAgICBkcmFnZ2FibGVzOiB7fSxcbiAgICBkcm9wcGFibGVzOiB7fVxuICB9O1xuICBjb25zdCBzdWJzY3JpYmVycyA9IFtdO1xuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2IpIHtcbiAgICBzdWJzY3JpYmVycy5wdXNoKGNiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoY2IpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdWJzY3JpYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KGV2ZW50KSB7XG4gICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCkge1xuICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaChjYiA9PiBjYihldmVudCkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmaW5kRHJhZ2dhYmxlQnlJZChpZCkge1xuICAgIHJldHVybiBlbnRyaWVzLmRyYWdnYWJsZXNbaWRdIHx8IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlQnlJZChpZCkge1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZERyYWdnYWJsZUJ5SWQoaWQpO1xuICAgICFlbnRyeSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBmaW5kIGRyYWdnYWJsZSBlbnRyeSB3aXRoIGlkIFske2lkfV1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuICBjb25zdCBkcmFnZ2FibGVBUEkgPSB7XG4gICAgcmVnaXN0ZXI6IGVudHJ5ID0+IHtcbiAgICAgIGVudHJpZXMuZHJhZ2dhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgICAgbm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ0FERElUSU9OJyxcbiAgICAgICAgdmFsdWU6IGVudHJ5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZTogKGVudHJ5LCBsYXN0KSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZW50cmllcy5kcmFnZ2FibGVzW2xhc3QuZGVzY3JpcHRvci5pZF07XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQudW5pcXVlSWQgIT09IGVudHJ5LnVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBlbnRyaWVzLmRyYWdnYWJsZXNbbGFzdC5kZXNjcmlwdG9yLmlkXTtcbiAgICAgIGVudHJpZXMuZHJhZ2dhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgIH0sXG4gICAgdW5yZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBlbnRyeS5kZXNjcmlwdG9yLmlkO1xuICAgICAgY29uc3QgY3VycmVudCA9IGZpbmREcmFnZ2FibGVCeUlkKGRyYWdnYWJsZUlkKTtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZW50cnkudW5pcXVlSWQgIT09IGN1cnJlbnQudW5pcXVlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGVudHJpZXMuZHJhZ2dhYmxlc1tkcmFnZ2FibGVJZF07XG4gICAgICBpZiAoZW50cmllcy5kcm9wcGFibGVzW2VudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdKSB7XG4gICAgICAgIG5vdGlmeSh7XG4gICAgICAgICAgdHlwZTogJ1JFTU9WQUwnLFxuICAgICAgICAgIHZhbHVlOiBlbnRyeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEJ5SWQ6IGdldERyYWdnYWJsZUJ5SWQsXG4gICAgZmluZEJ5SWQ6IGZpbmREcmFnZ2FibGVCeUlkLFxuICAgIGV4aXN0czogaWQgPT4gQm9vbGVhbihmaW5kRHJhZ2dhYmxlQnlJZChpZCkpLFxuICAgIGdldEFsbEJ5VHlwZTogdHlwZSA9PiBPYmplY3QudmFsdWVzKGVudHJpZXMuZHJhZ2dhYmxlcykuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LmRlc2NyaXB0b3IudHlwZSA9PT0gdHlwZSlcbiAgfTtcbiAgZnVuY3Rpb24gZmluZERyb3BwYWJsZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZW50cmllcy5kcm9wcGFibGVzW2lkXSB8fCBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldERyb3BwYWJsZUJ5SWQoaWQpIHtcbiAgICBjb25zdCBlbnRyeSA9IGZpbmREcm9wcGFibGVCeUlkKGlkKTtcbiAgICAhZW50cnkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBkcm9wcGFibGUgZW50cnkgd2l0aCBpZCBbJHtpZH1dYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW50cnk7XG4gIH1cbiAgY29uc3QgZHJvcHBhYmxlQVBJID0ge1xuICAgIHJlZ2lzdGVyOiBlbnRyeSA9PiB7XG4gICAgICBlbnRyaWVzLmRyb3BwYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF0gPSBlbnRyeTtcbiAgICB9LFxuICAgIHVucmVnaXN0ZXI6IGVudHJ5ID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBmaW5kRHJvcHBhYmxlQnlJZChlbnRyeS5kZXNjcmlwdG9yLmlkKTtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZW50cnkudW5pcXVlSWQgIT09IGN1cnJlbnQudW5pcXVlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGVudHJpZXMuZHJvcHBhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXTtcbiAgICB9LFxuICAgIGdldEJ5SWQ6IGdldERyb3BwYWJsZUJ5SWQsXG4gICAgZmluZEJ5SWQ6IGZpbmREcm9wcGFibGVCeUlkLFxuICAgIGV4aXN0czogaWQgPT4gQm9vbGVhbihmaW5kRHJvcHBhYmxlQnlJZChpZCkpLFxuICAgIGdldEFsbEJ5VHlwZTogdHlwZSA9PiBPYmplY3QudmFsdWVzKGVudHJpZXMuZHJvcHBhYmxlcykuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LmRlc2NyaXB0b3IudHlwZSA9PT0gdHlwZSlcbiAgfTtcbiAgZnVuY3Rpb24gY2xlYW4oKSB7XG4gICAgZW50cmllcy5kcmFnZ2FibGVzID0ge307XG4gICAgZW50cmllcy5kcm9wcGFibGVzID0ge307XG4gICAgc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlQVBJLFxuICAgIGRyb3BwYWJsZTogZHJvcHBhYmxlQVBJLFxuICAgIHN1YnNjcmliZSxcbiAgICBjbGVhblxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VSZWdpc3RyeSgpIHtcbiAgY29uc3QgcmVnaXN0cnkgPSB1c2VNZW1vKGNyZWF0ZVJlZ2lzdHJ5LCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICByZWdpc3RyeS5jbGVhbigpO1xuICAgIH07XG4gIH0sIFtyZWdpc3RyeV0pO1xuICByZXR1cm4gcmVnaXN0cnk7XG59XG5cbnZhciBTdG9yZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG52YXIgZ2V0Qm9keUVsZW1lbnQgPSAoKSA9PiB7XG4gIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAhYm9keSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5kIGRvY3VtZW50LmJvZHknKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gYm9keTtcbn07XG5cbmNvbnN0IHZpc3VhbGx5SGlkZGVuID0ge1xuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgd2lkdGg6ICcxcHgnLFxuICBoZWlnaHQ6ICcxcHgnLFxuICBtYXJnaW46ICctMXB4JyxcbiAgYm9yZGVyOiAnMCcsXG4gIHBhZGRpbmc6ICcwJyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gICdjbGlwLXBhdGgnOiAnaW5zZXQoMTAwJSknXG59O1xuXG5jb25zdCBnZXRJZCA9IGNvbnRleHRJZCA9PiBgcmZkLWFubm91bmNlbWVudC0ke2NvbnRleHRJZH1gO1xuZnVuY3Rpb24gdXNlQW5ub3VuY2VyKGNvbnRleHRJZCkge1xuICBjb25zdCBpZCA9IHVzZU1lbW8oKCkgPT4gZ2V0SWQoY29udGV4dElkKSwgW2NvbnRleHRJZF0pO1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJlZi5jdXJyZW50ID0gZWw7XG4gICAgZWwuaWQgPSBpZDtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdhc3NlcnRpdmUnKTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYXRvbWljJywgJ3RydWUnKTtcbiAgICBfZXh0ZW5kcyhlbC5zdHlsZSwgdmlzdWFsbHlIaWRkZW4pO1xuICAgIGdldEJvZHlFbGVtZW50KCkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBnZXRCb2R5RWxlbWVudCgpO1xuICAgICAgICBpZiAoYm9keS5jb250YWlucyhlbCkpIHtcbiAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwgPT09IHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbaWRdKTtcbiAgY29uc3QgYW5ub3VuY2UgPSB1c2VDYWxsYmFjayhtZXNzYWdlID0+IHtcbiAgICBjb25zdCBlbCA9IHJlZi5jdXJyZW50O1xuICAgIGlmIChlbCkge1xuICAgICAgZWwudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIEEgc2NyZWVuIHJlYWRlciBtZXNzYWdlIHdhcyB0cnlpbmcgdG8gYmUgYW5ub3VuY2VkIGJ1dCBpdCB3YXMgdW5hYmxlIHRvIGRvIHNvLlxuICAgICAgVGhpcyBjYW4gb2NjdXIgaWYgeW91IHVubW91bnQgeW91ciA8RHJhZ0Ryb3BDb250ZXh0IC8+IGluIHlvdXIgb25EcmFnRW5kLlxuICAgICAgQ29uc2lkZXIgY2FsbGluZyBwcm92aWRlZC5hbm5vdW5jZSgpIGJlZm9yZSB0aGUgdW5tb3VudCBzbyB0aGF0IHRoZSBpbnN0cnVjdGlvbiB3aWxsXG4gICAgICBub3QgYmUgbG9zdCBmb3IgdXNlcnMgcmVseWluZyBvbiBhIHNjcmVlbiByZWFkZXIuXG5cbiAgICAgIE1lc3NhZ2Ugbm90IHBhc3NlZCB0byBzY3JlZW4gcmVhZGVyOlxuXG4gICAgICBcIiR7bWVzc2FnZX1cIlxuICAgIGApIDogdm9pZCAwO1xuICB9LCBbXSk7XG4gIHJldHVybiBhbm5vdW5jZTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIHNlcGFyYXRvcjogJzo6J1xufTtcbmZ1bmN0aW9uIHVzZVVuaXF1ZUlkKHByZWZpeCwgb3B0aW9ucyA9IGRlZmF1bHRzKSB7XG4gIGNvbnN0IGlkID0gUmVhY3QudXNlSWQoKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gYCR7cHJlZml4fSR7b3B0aW9ucy5zZXBhcmF0b3J9JHtpZH1gLCBbb3B0aW9ucy5zZXBhcmF0b3IsIHByZWZpeCwgaWRdKTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudElkKHtcbiAgY29udGV4dElkLFxuICB1bmlxdWVJZFxufSkge1xuICByZXR1cm4gYHJmZC1oaWRkZW4tdGV4dC0ke2NvbnRleHRJZH0tJHt1bmlxdWVJZH1gO1xufVxuZnVuY3Rpb24gdXNlSGlkZGVuVGV4dEVsZW1lbnQoe1xuICBjb250ZXh0SWQsXG4gIHRleHRcbn0pIHtcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VVbmlxdWVJZCgnaGlkZGVuLXRleHQnLCB7XG4gICAgc2VwYXJhdG9yOiAnLSdcbiAgfSk7XG4gIGNvbnN0IGlkID0gdXNlTWVtbygoKSA9PiBnZXRFbGVtZW50SWQoe1xuICAgIGNvbnRleHRJZCxcbiAgICB1bmlxdWVJZFxuICB9KSwgW3VuaXF1ZUlkLCBjb250ZXh0SWRdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuaWQgPSBpZDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBnZXRCb2R5RWxlbWVudCgpLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnZXRCb2R5RWxlbWVudCgpO1xuICAgICAgaWYgKGJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtpZCwgdGV4dF0pO1xuICByZXR1cm4gaWQ7XG59XG5cbnZhciBBcHBDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxudmFyIHBlZXJEZXBlbmRlbmNpZXMgPSB7XG5cdHJlYWN0OiBcIl4xOC4wLjAgfHwgXjE5LjAuMFwifTtcblxuY29uc3Qgc2VtdmVyID0gLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKS87XG5jb25zdCBnZXRWZXJzaW9uID0gdmFsdWUgPT4ge1xuICBjb25zdCByZXN1bHQgPSBzZW12ZXIuZXhlYyh2YWx1ZSk7XG4gICEocmVzdWx0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVW5hYmxlIHRvIHBhcnNlIFJlYWN0IHZlcnNpb24gJHt2YWx1ZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBtYWpvciA9IE51bWJlcihyZXN1bHRbMV0pO1xuICBjb25zdCBtaW5vciA9IE51bWJlcihyZXN1bHRbMl0pO1xuICBjb25zdCBwYXRjaCA9IE51bWJlcihyZXN1bHRbM10pO1xuICByZXR1cm4ge1xuICAgIG1ham9yLFxuICAgIG1pbm9yLFxuICAgIHBhdGNoLFxuICAgIHJhdzogdmFsdWVcbiAgfTtcbn07XG5jb25zdCBpc1NhdGlzZmllZCA9IChleHBlY3RlZCwgYWN0dWFsKSA9PiB7XG4gIGlmIChhY3R1YWwubWFqb3IgPiBleHBlY3RlZC5tYWpvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhY3R1YWwubWFqb3IgPCBleHBlY3RlZC5tYWpvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYWN0dWFsLm1pbm9yID4gZXhwZWN0ZWQubWlub3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYWN0dWFsLm1pbm9yIDwgZXhwZWN0ZWQubWlub3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGFjdHVhbC5wYXRjaCA+PSBleHBlY3RlZC5wYXRjaDtcbn07XG52YXIgY2hlY2tSZWFjdFZlcnNpb24gPSAocGVlckRlcFZhbHVlLCBhY3R1YWxWYWx1ZSkgPT4ge1xuICBjb25zdCBwZWVyRGVwID0gZ2V0VmVyc2lvbihwZWVyRGVwVmFsdWUpO1xuICBjb25zdCBhY3R1YWwgPSBnZXRWZXJzaW9uKGFjdHVhbFZhbHVlKTtcbiAgaWYgKGlzU2F0aXNmaWVkKHBlZXJEZXAsIGFjdHVhbCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgUmVhY3QgdmVyc2lvbjogWyR7YWN0dWFsLnJhd31dXG4gICAgZG9lcyBub3Qgc2F0aXNmeSBleHBlY3RlZCBwZWVyIGRlcGVuZGVuY3kgdmVyc2lvbjogWyR7cGVlckRlcC5yYXd9XVxuXG4gICAgVGhpcyBjYW4gcmVzdWx0IGluIHJ1biB0aW1lIGJ1Z3MsIGFuZCBldmVuIGZhdGFsIGNyYXNoZXNcbiAgYCkgOiB2b2lkIDA7XG59O1xuXG5jb25zdCBzdWZmaXggPSBgXG4gIFdlIGV4cGVjdCBhIGh0bWw1IGRvY3R5cGU6IDwhZG9jdHlwZSBodG1sPlxuICBUaGlzIGlzIHRvIGVuc3VyZSBjb25zaXN0ZW50IGJyb3dzZXIgbGF5b3V0IGFuZCBtZWFzdXJlbWVudFxuXG4gIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2d1aWRlcy9kb2N0eXBlLm1kXG5gO1xudmFyIGNoZWNrRG9jdHlwZSA9IGRvYyA9PiB7XG4gIGNvbnN0IGRvY3R5cGUgPSBkb2MuZG9jdHlwZTtcbiAgaWYgKCFkb2N0eXBlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBObyA8IWRvY3R5cGUgaHRtbD4gZm91bmQuXG5cbiAgICAgICR7c3VmZml4fVxuICAgIGApIDogdm9pZCAwO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZG9jdHlwZS5uYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgVW5leHBlY3RlZCA8IWRvY3R5cGU+IGZvdW5kOiAoJHtkb2N0eXBlLm5hbWV9KVxuXG4gICAgICAke3N1ZmZpeH1cbiAgICBgKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAoZG9jdHlwZS5wdWJsaWNJZCAhPT0gJycpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIFVuZXhwZWN0ZWQgPCFkb2N0eXBlPiBwdWJsaWNJZCBmb3VuZDogKCR7ZG9jdHlwZS5wdWJsaWNJZH0pXG4gICAgICBBIGh0bWw1IGRvY3R5cGUgZG9lcyBub3QgaGF2ZSBhIHB1YmxpY0lkXG5cbiAgICAgICR7c3VmZml4fVxuICAgIGApIDogdm9pZCAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1c2VEZXYodXNlSG9vaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVzZUhvb2soKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VEZXZTZXR1cFdhcm5pbmcoZm4sIGlucHV0cykge1xuICB1c2VEZXYoKCkgPT4ge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcihgXG4gICAgICAgICAgQSBzZXR1cCBwcm9ibGVtIHdhcyBlbmNvdW50ZXJlZC5cblxuICAgICAgICAgID4gJHtlLm1lc3NhZ2V9XG4gICAgICAgIGApO1xuICAgICAgfVxuICAgIH0sIGlucHV0cyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VTdGFydHVwVmFsaWRhdGlvbigpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICBjaGVja1JlYWN0VmVyc2lvbihwZWVyRGVwZW5kZW5jaWVzLnJlYWN0LCBSZWFjdC52ZXJzaW9uKTtcbiAgICBjaGVja0RvY3R5cGUoZG9jdW1lbnQpO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKGN1cnJlbnQpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKGN1cnJlbnQpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gY3VycmVudDtcbiAgfSk7XG4gIHJldHVybiByZWY7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IGxvY2sgPSBudWxsO1xuICBmdW5jdGlvbiBpc0NsYWltZWQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obG9jayk7XG4gIH1cbiAgZnVuY3Rpb24gaXNBY3RpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxvY2s7XG4gIH1cbiAgZnVuY3Rpb24gY2xhaW0oYWJhbmRvbikge1xuICAgICEhbG9jayA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjbGFpbSBsb2NrIGFzIGl0IGlzIGFscmVhZHkgY2xhaW1lZCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgbmV3TG9jayA9IHtcbiAgICAgIGFiYW5kb25cbiAgICB9O1xuICAgIGxvY2sgPSBuZXdMb2NrO1xuICAgIHJldHVybiBuZXdMb2NrO1xuICB9XG4gIGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgIWxvY2sgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcmVsZWFzZSBsb2NrIHdoZW4gdGhlcmUgaXMgbm8gbG9jaycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgbG9jayA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gdHJ5QWJhbmRvbigpIHtcbiAgICBpZiAobG9jaykge1xuICAgICAgbG9jay5hYmFuZG9uKCk7XG4gICAgICByZWxlYXNlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgaXNDbGFpbWVkLFxuICAgIGlzQWN0aXZlLFxuICAgIGNsYWltLFxuICAgIHJlbGVhc2UsXG4gICAgdHJ5QWJhbmRvblxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0RyYWdnaW5nKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBzdGF0ZS5pc0RyYWdnaW5nO1xufVxuXG5jb25zdCB0YWIgPSA5O1xuY29uc3QgZW50ZXIgPSAxMztcbmNvbnN0IGVzY2FwZSA9IDI3O1xuY29uc3Qgc3BhY2UgPSAzMjtcbmNvbnN0IHBhZ2VVcCA9IDMzO1xuY29uc3QgcGFnZURvd24gPSAzNDtcbmNvbnN0IGVuZCA9IDM1O1xuY29uc3QgaG9tZSA9IDM2O1xuY29uc3QgYXJyb3dMZWZ0ID0gMzc7XG5jb25zdCBhcnJvd1VwID0gMzg7XG5jb25zdCBhcnJvd1JpZ2h0ID0gMzk7XG5jb25zdCBhcnJvd0Rvd24gPSA0MDtcblxuY29uc3QgcHJldmVudGVkS2V5cyA9IHtcbiAgW2VudGVyXTogdHJ1ZSxcbiAgW3RhYl06IHRydWVcbn07XG52YXIgcHJldmVudFN0YW5kYXJkS2V5RXZlbnRzID0gZXZlbnQgPT4ge1xuICBpZiAocHJldmVudGVkS2V5c1tldmVudC5rZXlDb2RlXSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn07XG5cbmNvbnN0IHN1cHBvcnRlZEV2ZW50TmFtZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgY29uc3QgY2FuZGlkYXRlcyA9IFtiYXNlLCBgbXMke2Jhc2V9YCwgYHdlYmtpdCR7YmFzZX1gLCBgbW96JHtiYXNlfWAsIGBvJHtiYXNlfWBdO1xuICBjb25zdCBzdXBwb3J0ZWQgPSBjYW5kaWRhdGVzLmZpbmQoZXZlbnROYW1lID0+IGBvbiR7ZXZlbnROYW1lfWAgaW4gZG9jdW1lbnQpO1xuICByZXR1cm4gc3VwcG9ydGVkIHx8IGJhc2U7XG59KSgpO1xuXG5jb25zdCBwcmltYXJ5QnV0dG9uID0gMDtcbmNvbnN0IHNsb3BweUNsaWNrVGhyZXNob2xkID0gNTtcbmZ1bmN0aW9uIGlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZChvcmlnaW5hbCwgY3VycmVudCkge1xuICByZXR1cm4gTWF0aC5hYnMoY3VycmVudC54IC0gb3JpZ2luYWwueCkgPj0gc2xvcHB5Q2xpY2tUaHJlc2hvbGQgfHwgTWF0aC5hYnMoY3VycmVudC55IC0gb3JpZ2luYWwueSkgPj0gc2xvcHB5Q2xpY2tUaHJlc2hvbGQ7XG59XG5jb25zdCBpZGxlJDEgPSB7XG4gIHR5cGU6ICdJRExFJ1xufTtcbmZ1bmN0aW9uIGdldENhcHR1cmVCaW5kaW5ncyh7XG4gIGNhbmNlbCxcbiAgY29tcGxldGVkLFxuICBnZXRQaGFzZSxcbiAgc2V0UGhhc2Vcbn0pIHtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vtb3ZlJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBidXR0b24sXG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGlmIChidXR0b24gIT09IHByaW1hcnlCdXR0b24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBwaGFzZS5hY3Rpb25zLm1vdmUocG9pbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAhKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgYmUgSURMRScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgICBjb25zdCBwZW5kaW5nID0gcGhhc2UucG9pbnQ7XG4gICAgICBpZiAoIWlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZChwZW5kaW5nLCBwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBwaGFzZS5hY3Rpb25zLmZsdWlkTGlmdChwb2ludCk7XG4gICAgICBzZXRQaGFzZSh7XG4gICAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICAgIGFjdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNldXAnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMuZHJvcCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNlZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMoZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiAoKSA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnd2Via2l0bW91c2Vmb3JjZWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICAhKHBoYXNlLnR5cGUgIT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIHBoYXNlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICAgIGlmIChwaGFzZS5hY3Rpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKCkpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cbmZ1bmN0aW9uIHVzZU1vdXNlU2Vuc29yKGFwaSkge1xuICBjb25zdCBwaGFzZVJlZiA9IHVzZVJlZihpZGxlJDEpO1xuICBjb25zdCB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCQyKTtcbiAgY29uc3Qgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICdtb3VzZWRvd24nLFxuICAgIGZuOiBmdW5jdGlvbiBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gcHJpbWFyeUJ1dHRvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aW9ucyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICB9O1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpO1xuICAgIH1cbiAgfSksIFthcGldKTtcbiAgY29uc3QgcHJldmVudEZvcmNlUHJlc3NCaW5kaW5nID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGV2ZW50TmFtZTogJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IGFwaS5maW5kT3B0aW9uc0ZvckRyYWdnYWJsZShpZCk7XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFhcGkuY2FuR2V0TG9jayhpZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBsaXN0ZW5Gb3JDYXB0dXJlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmcsIHN0YXJ0Q2FwdHVyZUJpbmRpbmddLCBvcHRpb25zKTtcbiAgfSwgW3ByZXZlbnRGb3JjZVByZXNzQmluZGluZywgc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwaGFzZVJlZi5jdXJyZW50ID0gaWRsZSQxO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZV0pO1xuICBjb25zdCBjYW5jZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgcGhhc2UgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgIHN0b3AoKTtcbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5jYW5jZWwoe1xuICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuYWJvcnQoKTtcbiAgICB9XG4gIH0sIFtzdG9wXSk7XG4gIGNvbnN0IGJpbmRDYXB0dXJpbmdFdmVudHMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBiaW5kQ2FwdHVyaW5nRXZlbnRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGJpbmRpbmdzID0gZ2V0Q2FwdHVyZUJpbmRpbmdzKHtcbiAgICAgIGNhbmNlbCxcbiAgICAgIGNvbXBsZXRlZDogc3RvcCxcbiAgICAgIGdldFBoYXNlOiAoKSA9PiBwaGFzZVJlZi5jdXJyZW50LFxuICAgICAgc2V0UGhhc2U6IHBoYXNlID0+IHtcbiAgICAgICAgcGhhc2VSZWYuY3VycmVudCA9IHBoYXNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIGJpbmRpbmdzLCBvcHRpb25zKTtcbiAgfSwgW2NhbmNlbCwgc3RvcF0pO1xuICBjb25zdCBzdGFydFBlbmRpbmdEcmFnID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCkge1xuICAgICEocGhhc2VSZWYuY3VycmVudC50eXBlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gbW92ZSBmcm9tIElETEUgdG8gUEVORElORyBkcmFnJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBwaGFzZVJlZi5jdXJyZW50ID0ge1xuICAgICAgdHlwZTogJ1BFTkRJTkcnLFxuICAgICAgcG9pbnQsXG4gICAgICBhY3Rpb25zXG4gICAgfTtcbiAgICBiaW5kQ2FwdHVyaW5nRXZlbnRzKCk7XG4gIH0sIFtiaW5kQ2FwdHVyaW5nRXZlbnRzXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICB9O1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZV0pO1xufVxuXG5mdW5jdGlvbiBub29wJDEoKSB7fVxuY29uc3Qgc2Nyb2xsSnVtcEtleXMgPSB7XG4gIFtwYWdlRG93bl06IHRydWUsXG4gIFtwYWdlVXBdOiB0cnVlLFxuICBbaG9tZV06IHRydWUsXG4gIFtlbmRdOiB0cnVlXG59O1xuZnVuY3Rpb24gZ2V0RHJhZ2dpbmdCaW5kaW5ncyhhY3Rpb25zLCBzdG9wKSB7XG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBzdG9wKCk7XG4gICAgYWN0aW9ucy5jYW5jZWwoKTtcbiAgfVxuICBmdW5jdGlvbiBkcm9wKCkge1xuICAgIHN0b3AoKTtcbiAgICBhY3Rpb25zLmRyb3AoKTtcbiAgfVxuICByZXR1cm4gW3tcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGVzY2FwZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IHNwYWNlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRyb3AoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93RG93bikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVEb3duKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd1VwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZVVwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd1JpZ2h0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZVJpZ2h0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd0xlZnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlTGVmdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2Nyb2xsSnVtcEtleXNbZXZlbnQua2V5Q29kZV0pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHJldmVudFN0YW5kYXJkS2V5RXZlbnRzKGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZWRvd24nLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNldXAnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2NsaWNrJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaHN0YXJ0JyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdyZXNpemUnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3doZWVsJyxcbiAgICBmbjogY2FuY2VsLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZEV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuZnVuY3Rpb24gdXNlS2V5Ym9hcmRTZW5zb3IoYXBpKSB7XG4gIGNvbnN0IHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wJDEpO1xuICBjb25zdCBzdGFydENhcHR1cmVCaW5kaW5nID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlICE9PSBzcGFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJlRHJhZyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgICBpZiAoIXByZURyYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGxldCBpc0NhcHR1cmluZyA9IHRydWU7XG4gICAgICBjb25zdCBhY3Rpb25zID0gcHJlRHJhZy5zbmFwTGlmdCgpO1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICFpc0NhcHR1cmluZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdG9wIGNhcHR1cmluZyBhIGtleWJvYXJkIGRyYWcgd2hlbiBub3QgY2FwdHVyaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICAgICAgaXNDYXB0dXJpbmcgPSBmYWxzZTtcbiAgICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgICAgfVxuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgZ2V0RHJhZ2dpbmdCaW5kaW5ncyhhY3Rpb25zLCBzdG9wKSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5U3RhcnRDYXB0dXJlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICB9O1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZV0pO1xufVxuXG5jb25zdCBpZGxlID0ge1xuICB0eXBlOiAnSURMRSdcbn07XG5jb25zdCB0aW1lRm9yTG9uZ1ByZXNzID0gMTIwO1xuY29uc3QgZm9yY2VQcmVzc1RocmVzaG9sZCA9IDAuMTU7XG5mdW5jdGlvbiBnZXRXaW5kb3dCaW5kaW5ncyh7XG4gIGNhbmNlbCxcbiAgZ2V0UGhhc2Vcbn0pIHtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAnb3JpZW50YXRpb25jaGFuZ2UnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnY29udGV4dG1lbnUnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBjYW5jZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZEV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlQmluZGluZ3Moe1xuICBjYW5jZWwsXG4gIGNvbXBsZXRlZCxcbiAgZ2V0UGhhc2Vcbn0pIHtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAndG91Y2htb3ZlJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwaGFzZS5oYXNNb3ZlZCA9IHRydWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5tb3ZlKHBvaW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaGVuZCcsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5kcm9wKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hjYW5jZWwnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hmb3JjZWNoYW5nZScsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgICEocGhhc2UudHlwZSAhPT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCgpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICBpZiAoIXRvdWNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzRm9yY2VQcmVzcyA9IHRvdWNoLmZvcmNlID49IGZvcmNlUHJlc3NUaHJlc2hvbGQ7XG4gICAgICBpZiAoIWlzRm9yY2VQcmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaG91bGRSZXNwZWN0ID0gcGhhc2UuYWN0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcygpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgICBpZiAoc2hvdWxkUmVzcGVjdCkge1xuICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZXNwZWN0KSB7XG4gICAgICAgIGlmIChwaGFzZS5oYXNNb3ZlZCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkRXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5mdW5jdGlvbiB1c2VUb3VjaFNlbnNvcihhcGkpIHtcbiAgY29uc3QgcGhhc2VSZWYgPSB1c2VSZWYoaWRsZSk7XG4gIGNvbnN0IHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wJDIpO1xuICBjb25zdCBnZXRQaGFzZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGdldFBoYXNlKCkge1xuICAgIHJldHVybiBwaGFzZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIGNvbnN0IHNldFBoYXNlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc2V0UGhhc2UocGhhc2UpIHtcbiAgICBwaGFzZVJlZi5jdXJyZW50ID0gcGhhc2U7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICd0b3VjaHN0YXJ0JyxcbiAgICBmbjogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aW9ucyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gdG91Y2g7XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBsaXN0ZW5Gb3JDYXB0dXJlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ0lETEUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnQubG9uZ1ByZXNzVGltZXJJZCk7XG4gICAgfVxuICAgIHNldFBoYXNlKGlkbGUpO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZSwgc2V0UGhhc2VdKTtcbiAgY29uc3QgY2FuY2VsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHBoYXNlID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBzdG9wKCk7XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuY2FuY2VsKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmFib3J0KCk7XG4gICAgfVxuICB9LCBbc3RvcF0pO1xuICBjb25zdCBiaW5kQ2FwdHVyaW5nRXZlbnRzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gYmluZENhcHR1cmluZ0V2ZW50cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgY2FuY2VsLFxuICAgICAgY29tcGxldGVkOiBzdG9wLFxuICAgICAgZ2V0UGhhc2VcbiAgICB9O1xuICAgIGNvbnN0IHVuYmluZFRhcmdldCA9IGJpbmRFdmVudHMod2luZG93LCBnZXRIYW5kbGVCaW5kaW5ncyhhcmdzKSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5iaW5kV2luZG93ID0gYmluZEV2ZW50cyh3aW5kb3csIGdldFdpbmRvd0JpbmRpbmdzKGFyZ3MpLCBvcHRpb25zKTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGZ1bmN0aW9uIHVuYmluZEFsbCgpIHtcbiAgICAgIHVuYmluZFRhcmdldCgpO1xuICAgICAgdW5iaW5kV2luZG93KCk7XG4gICAgfTtcbiAgfSwgW2NhbmNlbCwgZ2V0UGhhc2UsIHN0b3BdKTtcbiAgY29uc3Qgc3RhcnREcmFnZ2luZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0RHJhZ2dpbmcoKSB7XG4gICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICEocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBzdGFydCBkcmFnZ2luZyBmcm9tIHBoYXNlICR7cGhhc2UudHlwZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGFjdGlvbnMgPSBwaGFzZS5hY3Rpb25zLmZsdWlkTGlmdChwaGFzZS5wb2ludCk7XG4gICAgc2V0UGhhc2Uoe1xuICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgIGFjdGlvbnMsXG4gICAgICBoYXNNb3ZlZDogZmFsc2VcbiAgICB9KTtcbiAgfSwgW2dldFBoYXNlLCBzZXRQaGFzZV0pO1xuICBjb25zdCBzdGFydFBlbmRpbmdEcmFnID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCkge1xuICAgICEoZ2V0UGhhc2UoKS50eXBlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gbW92ZSBmcm9tIElETEUgdG8gUEVORElORyBkcmFnJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBsb25nUHJlc3NUaW1lcklkID0gc2V0VGltZW91dChzdGFydERyYWdnaW5nLCB0aW1lRm9yTG9uZ1ByZXNzKTtcbiAgICBzZXRQaGFzZSh7XG4gICAgICB0eXBlOiAnUEVORElORycsXG4gICAgICBwb2ludCxcbiAgICAgIGFjdGlvbnMsXG4gICAgICBsb25nUHJlc3NUaW1lcklkXG4gICAgfSk7XG4gICAgYmluZENhcHR1cmluZ0V2ZW50cygpO1xuICB9LCBbYmluZENhcHR1cmluZ0V2ZW50cywgZ2V0UGhhc2UsIHNldFBoYXNlLCBzdGFydERyYWdnaW5nXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHBoYXNlLmxvbmdQcmVzc1RpbWVySWQpO1xuICAgICAgICBzZXRQaGFzZShpZGxlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZ2V0UGhhc2UsIGxpc3RlbkZvckNhcHR1cmUsIHNldFBoYXNlXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gd2Via2l0SGFjaygpIHtcbiAgICBjb25zdCB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgIGV2ZW50TmFtZTogJ3RvdWNobW92ZScsXG4gICAgICBmbjogKCkgPT4ge30sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gdW5iaW5kO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVZhbGlkYXRlU2Vuc29ySG9va3Moc2Vuc29ySG9va3MpIHtcbiAgdXNlRGV2KCgpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c1JlZiA9IHVzZVByZXZpb3VzKHNlbnNvckhvb2tzKTtcbiAgICB1c2VEZXZTZXR1cFdhcm5pbmcoKCkgPT4ge1xuICAgICAgIShwcmV2aW91c1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gc2Vuc29ySG9va3MubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjaGFuZ2UgdGhlIGFtb3VudCBvZiBzZW5zb3IgaG9va3MgYWZ0ZXIgbW91bnRpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5jb25zdCBpbnRlcmFjdGl2ZVRhZ05hbWVzID0gWydpbnB1dCcsICdidXR0b24nLCAndGV4dGFyZWEnLCAnc2VsZWN0JywgJ29wdGlvbicsICdvcHRncm91cCcsICd2aWRlbycsICdhdWRpbyddO1xuZnVuY3Rpb24gaXNBbkludGVyYWN0aXZlRWxlbWVudChwYXJlbnQsIGN1cnJlbnQpIHtcbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBoYXNBbkludGVyYWN0aXZlVGFnID0gaW50ZXJhY3RpdmVUYWdOYW1lcy5pbmNsdWRlcyhjdXJyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gIGlmIChoYXNBbkludGVyYWN0aXZlVGFnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYXR0cmlidXRlID0gY3VycmVudC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICBpZiAoYXR0cmlidXRlID09PSAndHJ1ZScgfHwgYXR0cmlidXRlID09PSAnJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjdXJyZW50ID09PSBwYXJlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50LCBjdXJyZW50LnBhcmVudEVsZW1lbnQpO1xufVxuZnVuY3Rpb24gaXNFdmVudEluSW50ZXJhY3RpdmVFbGVtZW50KGRyYWdnYWJsZSwgZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBpZiAoIWlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNBbkludGVyYWN0aXZlRWxlbWVudChkcmFnZ2FibGUsIHRhcmdldCk7XG59XG5cbnZhciBnZXRCb3JkZXJCb3hDZW50ZXJQb3NpdGlvbiA9IGVsID0+IGdldFJlY3QoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLmNlbnRlcjtcblxuZnVuY3Rpb24gaXNFbGVtZW50KGVsKSB7XG4gIHJldHVybiBlbCBpbnN0YW5jZW9mIGdldFdpbmRvd0Zyb21FbChlbCkuRWxlbWVudDtcbn1cblxuY29uc3Qgc3VwcG9ydGVkTWF0Y2hlc05hbWUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gJ21hdGNoZXMnO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbYmFzZSwgJ21zTWF0Y2hlc1NlbGVjdG9yJywgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvciddO1xuICBjb25zdCB2YWx1ZSA9IGNhbmRpZGF0ZXMuZmluZChuYW1lID0+IG5hbWUgaW4gRWxlbWVudC5wcm90b3R5cGUpO1xuICByZXR1cm4gdmFsdWUgfHwgYmFzZTtcbn0pKCk7XG5mdW5jdGlvbiBjbG9zZXN0UG9ueWZpbGwoZWwsIHNlbGVjdG9yKSB7XG4gIGlmIChlbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGVsW3N1cHBvcnRlZE1hdGNoZXNOYW1lXShzZWxlY3RvcikpIHtcbiAgICByZXR1cm4gZWw7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3RQb255ZmlsbChlbC5wYXJlbnRFbGVtZW50LCBzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBjbG9zZXN0KGVsLCBzZWxlY3Rvcikge1xuICBpZiAoZWwuY2xvc2VzdCkge1xuICAgIHJldHVybiBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgfVxuICByZXR1cm4gY2xvc2VzdFBvbnlmaWxsKGVsLCBzZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKGNvbnRleHRJZCkge1xuICByZXR1cm4gYFske2RyYWdIYW5kbGUuY29udGV4dElkfT1cIiR7Y29udGV4dElkfVwiXWA7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2VzdERyYWdIYW5kbGVGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGlmICghaXNFbGVtZW50KHRhcmdldCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdldmVudC50YXJnZXQgbXVzdCBiZSBhIEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGNvbnRleHRJZCk7XG4gIGNvbnN0IGhhbmRsZSA9IGNsb3Nlc3QodGFyZ2V0LCBzZWxlY3Rvcik7XG4gIGlmICghaGFuZGxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc0h0bWxFbGVtZW50KGhhbmRsZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdkcmFnIGhhbmRsZSBtdXN0IGJlIGEgSFRNTEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaGFuZGxlO1xufVxuZnVuY3Rpb24gdHJ5R2V0Q2xvc2VzdERyYWdnYWJsZUlkRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpIHtcbiAgY29uc3QgaGFuZGxlID0gZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpO1xuICBpZiAoIWhhbmRsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBoYW5kbGUuZ2V0QXR0cmlidXRlKGRyYWdIYW5kbGUuZHJhZ2dhYmxlSWQpO1xufVxuXG5mdW5jdGlvbiBmaW5kRHJhZ2dhYmxlKGNvbnRleHRJZCwgZHJhZ2dhYmxlSWQpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBgWyR7ZHJhZ2dhYmxlLmNvbnRleHRJZH09XCIke2NvbnRleHRJZH1cIl1gO1xuICBjb25zdCBwb3NzaWJsZSA9IHF1ZXJ5U2VsZWN0b3JBbGwoZG9jdW1lbnQsIHNlbGVjdG9yKTtcbiAgY29uc3QgZHJhZ2dhYmxlJDEgPSBwb3NzaWJsZS5maW5kKGVsID0+IHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGRyYWdnYWJsZS5pZCkgPT09IGRyYWdnYWJsZUlkO1xuICB9KTtcbiAgaWYgKCFkcmFnZ2FibGUkMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaXNIdG1sRWxlbWVudChkcmFnZ2FibGUkMSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdEcmFnZ2FibGUgZWxlbWVudCBpcyBub3QgYSBIVE1MRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBkcmFnZ2FibGUkMTtcbn1cblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIGlzQWN0aXZlKHtcbiAgZXhwZWN0ZWQsXG4gIHBoYXNlLFxuICBpc0xvY2tBY3RpdmUsXG4gIHNob3VsZFdhcm5cbn0pIHtcbiAgaWYgKCFpc0xvY2tBY3RpdmUoKSkge1xuICAgIGlmIChzaG91bGRXYXJuKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgICAgQ2Fubm90IHBlcmZvcm0gYWN0aW9uLlxuICAgICAgICBUaGUgc2Vuc29yIG5vIGxvbmdlciBoYXMgYW4gYWN0aW9uIGxvY2suXG5cbiAgICAgICAgVGlwczpcblxuICAgICAgICAtIFRocm93IGF3YXkgeW91ciBhY3Rpb24gaGFuZGxlcnMgd2hlbiBmb3JjZVN0b3AoKSBpcyBjYWxsZWRcbiAgICAgICAgLSBDaGVjayBhY3Rpb25zLmlzQWN0aXZlKCkgaWYgeW91IHJlYWxseSBuZWVkIHRvXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChleHBlY3RlZCAhPT0gcGhhc2UpIHtcbiAgICBpZiAoc2hvdWxkV2Fybikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICAgIENhbm5vdCBwZXJmb3JtIGFjdGlvbi5cbiAgICAgICAgVGhlIGFjdGlvbnMgeW91IHVzZWQgYmVsb25nIHRvIGFuIG91dGRhdGVkIHBoYXNlXG5cbiAgICAgICAgQ3VycmVudCBwaGFzZTogJHtleHBlY3RlZH1cbiAgICAgICAgWW91IGNhbGxlZCBhbiBhY3Rpb24gZnJvbSBvdXRkYXRlZCBwaGFzZTogJHtwaGFzZX1cblxuICAgICAgICBUaXBzOlxuXG4gICAgICAgIC0gRG8gbm90IHVzZSBwcmVEcmFnQWN0aW9ucyBhY3Rpb25zIGFmdGVyIGNhbGxpbmcgcHJlRHJhZ0FjdGlvbnMubGlmdCgpXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2FuU3RhcnQoe1xuICBsb2NrQVBJLFxuICBzdG9yZSxcbiAgcmVnaXN0cnksXG4gIGRyYWdnYWJsZUlkXG59KSB7XG4gIGlmIChsb2NrQVBJLmlzQ2xhaW1lZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmZpbmRCeUlkKGRyYWdnYWJsZUlkKTtcbiAgaWYgKCFlbnRyeSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFVuYWJsZSB0byBmaW5kIGRyYWdnYWJsZSB3aXRoIGlkOiAke2RyYWdnYWJsZUlkfWApIDogdm9pZCAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWVudHJ5Lm9wdGlvbnMuaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghY2FuU3RhcnREcmFnKHN0b3JlLmdldFN0YXRlKCksIGRyYWdnYWJsZUlkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRyeVN0YXJ0KHtcbiAgbG9ja0FQSSxcbiAgY29udGV4dElkLFxuICBzdG9yZSxcbiAgcmVnaXN0cnksXG4gIGRyYWdnYWJsZUlkLFxuICBmb3JjZVNlbnNvclN0b3AsXG4gIHNvdXJjZUV2ZW50XG59KSB7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gY2FuU3RhcnQoe1xuICAgIGxvY2tBUEksXG4gICAgc3RvcmUsXG4gICAgcmVnaXN0cnksXG4gICAgZHJhZ2dhYmxlSWRcbiAgfSk7XG4gIGlmICghc2hvdWxkU3RhcnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKGRyYWdnYWJsZUlkKTtcbiAgY29uc3QgZWwgPSBmaW5kRHJhZ2dhYmxlKGNvbnRleHRJZCwgZW50cnkuZGVzY3JpcHRvci5pZCk7XG4gIGlmICghZWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBVbmFibGUgdG8gZmluZCBkcmFnZ2FibGUgZWxlbWVudCB3aXRoIGlkOiAke2RyYWdnYWJsZUlkfWApIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChzb3VyY2VFdmVudCAmJiAhZW50cnkub3B0aW9ucy5jYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyAmJiBpc0V2ZW50SW5JbnRlcmFjdGl2ZUVsZW1lbnQoZWwsIHNvdXJjZUV2ZW50KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGxvY2sgPSBsb2NrQVBJLmNsYWltKGZvcmNlU2Vuc29yU3RvcCB8fCBub29wJDIpO1xuICBsZXQgcGhhc2UgPSAnUFJFX0RSQUcnO1xuICBmdW5jdGlvbiBnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcygpIHtcbiAgICByZXR1cm4gZW50cnkub3B0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcztcbiAgfVxuICBmdW5jdGlvbiBpc0xvY2tBY3RpdmUoKSB7XG4gICAgcmV0dXJuIGxvY2tBUEkuaXNBY3RpdmUobG9jayk7XG4gIH1cbiAgZnVuY3Rpb24gdHJ5RGlzcGF0Y2goZXhwZWN0ZWQsIGdldEFjdGlvbikge1xuICAgIGlmIChpc0FjdGl2ZSh7XG4gICAgICBleHBlY3RlZCxcbiAgICAgIHBoYXNlLFxuICAgICAgaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybjogdHJ1ZVxuICAgIH0pKSB7XG4gICAgICBzdG9yZS5kaXNwYXRjaChnZXRBY3Rpb24oKSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nID0gdHJ5RGlzcGF0Y2guYmluZChudWxsLCAnRFJBR0dJTkcnKTtcbiAgZnVuY3Rpb24gbGlmdChhcmdzKSB7XG4gICAgZnVuY3Rpb24gY29tcGxldGVkKCkge1xuICAgICAgbG9ja0FQSS5yZWxlYXNlKCk7XG4gICAgICBwaGFzZSA9ICdDT01QTEVURUQnO1xuICAgIH1cbiAgICBpZiAocGhhc2UgIT09ICdQUkVfRFJBRycpIHtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGxpZnQgaW4gcGhhc2UgJHtwaGFzZX1gKSA6IGludmFyaWFudCgpIDtcbiAgICB9XG4gICAgc3RvcmUuZGlzcGF0Y2gobGlmdCQxKGFyZ3MubGlmdEFjdGlvbkFyZ3MpKTtcbiAgICBwaGFzZSA9ICdEUkFHR0lORyc7XG4gICAgZnVuY3Rpb24gZmluaXNoKHJlYXNvbiwgb3B0aW9ucyA9IHtcbiAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiBmYWxzZVxuICAgIH0pIHtcbiAgICAgIGFyZ3MuY2xlYW51cCgpO1xuICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkQmxvY2tOZXh0Q2xpY2spIHtcbiAgICAgICAgY29uc3QgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFt7XG4gICAgICAgICAgZXZlbnROYW1lOiAnY2xpY2snLFxuICAgICAgICAgIGZuOiBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICAgIHNldFRpbWVvdXQodW5iaW5kKTtcbiAgICAgIH1cbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZHJvcCh7XG4gICAgICAgIHJlYXNvblxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmU6ICgpID0+IGlzQWN0aXZlKHtcbiAgICAgICAgZXhwZWN0ZWQ6ICdEUkFHR0lORycsXG4gICAgICAgIHBoYXNlLFxuICAgICAgICBpc0xvY2tBY3RpdmUsXG4gICAgICAgIHNob3VsZFdhcm46IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICAgIGRyb3A6IG9wdGlvbnMgPT4gZmluaXNoKCdEUk9QJywgb3B0aW9ucyksXG4gICAgICBjYW5jZWw6IG9wdGlvbnMgPT4gZmluaXNoKCdDQU5DRUwnLCBvcHRpb25zKSxcbiAgICAgIC4uLmFyZ3MuYWN0aW9uc1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZmx1aWRMaWZ0KGNsaWVudFNlbGVjdGlvbikge1xuICAgIGNvbnN0IG1vdmUkMSA9IHJhZlNjaGQoY2xpZW50ID0+IHtcbiAgICAgIHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKCgpID0+IG1vdmUoe1xuICAgICAgICBjbGllbnRcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBjb25zdCBhcGkgPSBsaWZ0KHtcbiAgICAgIGxpZnRBY3Rpb25BcmdzOiB7XG4gICAgICAgIGlkOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgY2xpZW50U2VsZWN0aW9uLFxuICAgICAgICBtb3ZlbWVudE1vZGU6ICdGTFVJRCdcbiAgICAgIH0sXG4gICAgICBjbGVhbnVwOiAoKSA9PiBtb3ZlJDEuY2FuY2VsKCksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIG1vdmU6IG1vdmUkMVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hcGksXG4gICAgICBtb3ZlOiBtb3ZlJDFcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNuYXBMaWZ0KCkge1xuICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICBtb3ZlVXA6ICgpID0+IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVVcCksXG4gICAgICBtb3ZlUmlnaHQ6ICgpID0+IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVSaWdodCksXG4gICAgICBtb3ZlRG93bjogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZURvd24pLFxuICAgICAgbW92ZUxlZnQ6ICgpID0+IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVMZWZ0KVxuICAgIH07XG4gICAgcmV0dXJuIGxpZnQoe1xuICAgICAgbGlmdEFjdGlvbkFyZ3M6IHtcbiAgICAgICAgaWQ6IGRyYWdnYWJsZUlkLFxuICAgICAgICBjbGllbnRTZWxlY3Rpb246IGdldEJvcmRlckJveENlbnRlclBvc2l0aW9uKGVsKSxcbiAgICAgICAgbW92ZW1lbnRNb2RlOiAnU05BUCdcbiAgICAgIH0sXG4gICAgICBjbGVhbnVwOiBub29wJDIsXG4gICAgICBhY3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnRQcmVEcmFnKCkge1xuICAgIGNvbnN0IHNob3VsZFJlbGVhc2UgPSBpc0FjdGl2ZSh7XG4gICAgICBleHBlY3RlZDogJ1BSRV9EUkFHJyxcbiAgICAgIHBoYXNlLFxuICAgICAgaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybjogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChzaG91bGRSZWxlYXNlKSB7XG4gICAgICBsb2NrQVBJLnJlbGVhc2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcHJlRHJhZyA9IHtcbiAgICBpc0FjdGl2ZTogKCkgPT4gaXNBY3RpdmUoe1xuICAgICAgZXhwZWN0ZWQ6ICdQUkVfRFJBRycsXG4gICAgICBwaGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IGZhbHNlXG4gICAgfSksXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGZsdWlkTGlmdCxcbiAgICBzbmFwTGlmdCxcbiAgICBhYm9ydDogYWJvcnRQcmVEcmFnXG4gIH07XG4gIHJldHVybiBwcmVEcmFnO1xufVxuY29uc3QgZGVmYXVsdFNlbnNvcnMgPSBbdXNlTW91c2VTZW5zb3IsIHVzZUtleWJvYXJkU2Vuc29yLCB1c2VUb3VjaFNlbnNvcl07XG5mdW5jdGlvbiB1c2VTZW5zb3JNYXJzaGFsKHtcbiAgY29udGV4dElkLFxuICBzdG9yZSxcbiAgcmVnaXN0cnksXG4gIGN1c3RvbVNlbnNvcnMsXG4gIGVuYWJsZURlZmF1bHRTZW5zb3JzXG59KSB7XG4gIGNvbnN0IHVzZVNlbnNvcnMgPSBbLi4uKGVuYWJsZURlZmF1bHRTZW5zb3JzID8gZGVmYXVsdFNlbnNvcnMgOiBbXSksIC4uLihjdXN0b21TZW5zb3JzIHx8IFtdKV07XG4gIGNvbnN0IGxvY2tBUEkgPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGUoKSlbMF07XG4gIGNvbnN0IHRyeUFiYW5kb25Mb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5QWJhbmRvbkxvY2socHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICBpZiAoaXNEcmFnZ2luZyhwcmV2aW91cykgJiYgIWlzRHJhZ2dpbmcoY3VycmVudCkpIHtcbiAgICAgIGxvY2tBUEkudHJ5QWJhbmRvbigpO1xuICAgIH1cbiAgfSwgW2xvY2tBUEldKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiBsaXN0ZW5Ub1N0b3JlKCkge1xuICAgIGxldCBwcmV2aW91cyA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdG9yZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICB0cnlBYmFuZG9uTG9jayhwcmV2aW91cywgY3VycmVudCk7XG4gICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBbbG9ja0FQSSwgc3RvcmUsIHRyeUFiYW5kb25Mb2NrXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBsb2NrQVBJLnRyeUFiYW5kb247XG4gIH0sIFtsb2NrQVBJLnRyeUFiYW5kb25dKTtcbiAgY29uc3QgY2FuR2V0TG9jayA9IHVzZUNhbGxiYWNrKGRyYWdnYWJsZUlkID0+IHtcbiAgICByZXR1cm4gY2FuU3RhcnQoe1xuICAgICAgbG9ja0FQSSxcbiAgICAgIHJlZ2lzdHJ5LFxuICAgICAgc3RvcmUsXG4gICAgICBkcmFnZ2FibGVJZFxuICAgIH0pO1xuICB9LCBbbG9ja0FQSSwgcmVnaXN0cnksIHN0b3JlXSk7XG4gIGNvbnN0IHRyeUdldExvY2sgPSB1c2VDYWxsYmFjaygoZHJhZ2dhYmxlSWQsIGZvcmNlU3RvcCwgb3B0aW9ucykgPT4gdHJ5U3RhcnQoe1xuICAgIGxvY2tBUEksXG4gICAgcmVnaXN0cnksXG4gICAgY29udGV4dElkLFxuICAgIHN0b3JlLFxuICAgIGRyYWdnYWJsZUlkLFxuICAgIGZvcmNlU2Vuc29yU3RvcDogZm9yY2VTdG9wIHx8IG51bGwsXG4gICAgc291cmNlRXZlbnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zb3VyY2VFdmVudCA/IG9wdGlvbnMuc291cmNlRXZlbnQgOiBudWxsXG4gIH0pLCBbY29udGV4dElkLCBsb2NrQVBJLCByZWdpc3RyeSwgc3RvcmVdKTtcbiAgY29uc3QgZmluZENsb3Nlc3REcmFnZ2FibGVJZCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KSwgW2NvbnRleHRJZF0pO1xuICBjb25zdCBmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSA9IHVzZUNhbGxiYWNrKGlkID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5maW5kQnlJZChpZCk7XG4gICAgcmV0dXJuIGVudHJ5ID8gZW50cnkub3B0aW9ucyA6IG51bGw7XG4gIH0sIFtyZWdpc3RyeS5kcmFnZ2FibGVdKTtcbiAgY29uc3QgdHJ5UmVsZWFzZUxvY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlSZWxlYXNlTG9jaygpIHtcbiAgICBpZiAoIWxvY2tBUEkuaXNDbGFpbWVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9ja0FQSS50cnlBYmFuZG9uKCk7XG4gICAgaWYgKHN0b3JlLmdldFN0YXRlKCkucGhhc2UgIT09ICdJRExFJykge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZmx1c2goKSk7XG4gICAgfVxuICB9LCBbbG9ja0FQSSwgc3RvcmVdKTtcbiAgY29uc3QgaXNMb2NrQ2xhaW1lZCA9IHVzZUNhbGxiYWNrKCgpID0+IGxvY2tBUEkuaXNDbGFpbWVkKCksIFtsb2NrQVBJXSk7XG4gIGNvbnN0IGFwaSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjYW5HZXRMb2NrLFxuICAgIHRyeUdldExvY2ssXG4gICAgZmluZENsb3Nlc3REcmFnZ2FibGVJZCxcbiAgICBmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSxcbiAgICB0cnlSZWxlYXNlTG9jayxcbiAgICBpc0xvY2tDbGFpbWVkXG4gIH0pLCBbY2FuR2V0TG9jaywgdHJ5R2V0TG9jaywgZmluZENsb3Nlc3REcmFnZ2FibGVJZCwgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUsIHRyeVJlbGVhc2VMb2NrLCBpc0xvY2tDbGFpbWVkXSk7XG4gIHVzZVZhbGlkYXRlU2Vuc29ySG9va3ModXNlU2Vuc29ycyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdXNlU2Vuc29ycy5sZW5ndGg7IGkrKykge1xuICAgIHVzZVNlbnNvcnNbaV0oYXBpKTtcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVSZXNwb25kZXJzID0gcHJvcHMgPT4gKHtcbiAgb25CZWZvcmVDYXB0dXJlOiB0ID0+IHtcbiAgICBjb25zdCBvbkJlZm9yZUNhcHVyZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKHByb3BzLm9uQmVmb3JlQ2FwdHVyZSkge1xuICAgICAgICBwcm9wcy5vbkJlZm9yZUNhcHR1cmUodCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmbHVzaFN5bmMob25CZWZvcmVDYXB1cmVDYWxsYmFjayk7XG4gIH0sXG4gIG9uQmVmb3JlRHJhZ1N0YXJ0OiBwcm9wcy5vbkJlZm9yZURyYWdTdGFydCxcbiAgb25EcmFnU3RhcnQ6IHByb3BzLm9uRHJhZ1N0YXJ0LFxuICBvbkRyYWdFbmQ6IHByb3BzLm9uRHJhZ0VuZCxcbiAgb25EcmFnVXBkYXRlOiBwcm9wcy5vbkRyYWdVcGRhdGVcbn0pO1xuY29uc3QgY3JlYXRlQXV0b1Njcm9sbGVyT3B0aW9ucyA9IHByb3BzID0+ICh7XG4gIC4uLmRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zLFxuICAuLi5wcm9wcy5hdXRvU2Nyb2xsZXJPcHRpb25zLFxuICBkdXJhdGlvbkRhbXBlbmluZzoge1xuICAgIC4uLmRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zLmR1cmF0aW9uRGFtcGVuaW5nLFxuICAgIC4uLnByb3BzLmF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfVxufSk7XG5mdW5jdGlvbiBnZXRTdG9yZShsYXp5UmVmKSB7XG4gICFsYXp5UmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBzdG9yZSBmcm9tIGxhenkgcmVmJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGxhenlSZWYuY3VycmVudDtcbn1cbmZ1bmN0aW9uIEFwcChwcm9wcykge1xuICBjb25zdCB7XG4gICAgY29udGV4dElkLFxuICAgIHNldENhbGxiYWNrcyxcbiAgICBzZW5zb3JzLFxuICAgIG5vbmNlLFxuICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGxhenlTdG9yZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlU3RhcnR1cFZhbGlkYXRpb24oKTtcbiAgY29uc3QgbGFzdFByb3BzUmVmID0gdXNlUHJldmlvdXMocHJvcHMpO1xuICBjb25zdCBnZXRSZXNwb25kZXJzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVSZXNwb25kZXJzKGxhc3RQcm9wc1JlZi5jdXJyZW50KTtcbiAgfSwgW2xhc3RQcm9wc1JlZl0pO1xuICBjb25zdCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVBdXRvU2Nyb2xsZXJPcHRpb25zKGxhc3RQcm9wc1JlZi5jdXJyZW50KTtcbiAgfSwgW2xhc3RQcm9wc1JlZl0pO1xuICBjb25zdCBhbm5vdW5jZSA9IHVzZUFubm91bmNlcihjb250ZXh0SWQpO1xuICBjb25zdCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCA9IHVzZUhpZGRlblRleHRFbGVtZW50KHtcbiAgICBjb250ZXh0SWQsXG4gICAgdGV4dDogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zXG4gIH0pO1xuICBjb25zdCBzdHlsZU1hcnNoYWwgPSB1c2VTdHlsZU1hcnNoYWwoY29udGV4dElkLCBub25jZSk7XG4gIGNvbnN0IGxhenlEaXNwYXRjaCA9IHVzZUNhbGxiYWNrKGFjdGlvbiA9PiB7XG4gICAgZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5kaXNwYXRjaChhY3Rpb24pO1xuICB9LCBbXSk7XG4gIGNvbnN0IG1hcnNoYWxDYWxsYmFja3MgPSB1c2VNZW1vKCgpID0+IGJpbmRBY3Rpb25DcmVhdG9ycyh7XG4gICAgcHVibGlzaFdoaWxlRHJhZ2dpbmcsXG4gICAgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsLFxuICAgIHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkLFxuICAgIGNvbGxlY3Rpb25TdGFydGluZ1xuICB9LCBsYXp5RGlzcGF0Y2gpLCBbbGF6eURpc3BhdGNoXSk7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gdXNlUmVnaXN0cnkoKTtcbiAgY29uc3QgZGltZW5zaW9uTWFyc2hhbCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVEaW1lbnNpb25NYXJzaGFsKHJlZ2lzdHJ5LCBtYXJzaGFsQ2FsbGJhY2tzKTtcbiAgfSwgW3JlZ2lzdHJ5LCBtYXJzaGFsQ2FsbGJhY2tzXSk7XG4gIGNvbnN0IGF1dG9TY3JvbGxlciA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlQXV0b1Njcm9sbGVyKHtcbiAgICBzY3JvbGxXaW5kb3csXG4gICAgc2Nyb2xsRHJvcHBhYmxlOiBkaW1lbnNpb25NYXJzaGFsLnNjcm9sbERyb3BwYWJsZSxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zLFxuICAgIC4uLmJpbmRBY3Rpb25DcmVhdG9ycyh7XG4gICAgICBtb3ZlXG4gICAgfSwgbGF6eURpc3BhdGNoKVxuICB9KSwgW2RpbWVuc2lvbk1hcnNoYWwuc2Nyb2xsRHJvcHBhYmxlLCBsYXp5RGlzcGF0Y2gsIGdldEF1dG9TY3JvbGxlck9wdGlvbnNdKTtcbiAgY29uc3QgZm9jdXNNYXJzaGFsID0gdXNlRm9jdXNNYXJzaGFsKGNvbnRleHRJZCk7XG4gIGNvbnN0IHN0b3JlID0gdXNlTWVtbygoKSA9PiBjcmVhdGVTdG9yZSh7XG4gICAgYW5ub3VuY2UsXG4gICAgYXV0b1Njcm9sbGVyLFxuICAgIGRpbWVuc2lvbk1hcnNoYWwsXG4gICAgZm9jdXNNYXJzaGFsLFxuICAgIGdldFJlc3BvbmRlcnMsXG4gICAgc3R5bGVNYXJzaGFsXG4gIH0pLCBbYW5ub3VuY2UsIGF1dG9TY3JvbGxlciwgZGltZW5zaW9uTWFyc2hhbCwgZm9jdXNNYXJzaGFsLCBnZXRSZXNwb25kZXJzLCBzdHlsZU1hcnNoYWxdKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAobGF6eVN0b3JlUmVmLmN1cnJlbnQgJiYgbGF6eVN0b3JlUmVmLmN1cnJlbnQgIT09IHN0b3JlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCd1bmV4cGVjdGVkIHN0b3JlIGNoYW5nZScpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICBsYXp5U3RvcmVSZWYuY3VycmVudCA9IHN0b3JlO1xuICBjb25zdCB0cnlSZXNldFN0b3JlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBnZXRTdG9yZShsYXp5U3RvcmVSZWYpO1xuICAgIGNvbnN0IHN0YXRlID0gY3VycmVudC5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5waGFzZSAhPT0gJ0lETEUnKSB7XG4gICAgICBjdXJyZW50LmRpc3BhdGNoKGZsdXNoKCkpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBpc0RyYWdnaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5pc0RyYWdnaW5nO1xuICB9LCBbXSk7XG4gIGNvbnN0IGFwcENhbGxiYWNrcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpc0RyYWdnaW5nLFxuICAgIHRyeUFib3J0OiB0cnlSZXNldFN0b3JlXG4gIH0pLCBbaXNEcmFnZ2luZywgdHJ5UmVzZXRTdG9yZV0pO1xuICBzZXRDYWxsYmFja3MoYXBwQ2FsbGJhY2tzKTtcbiAgY29uc3QgZ2V0Q2FuTGlmdCA9IHVzZUNhbGxiYWNrKGlkID0+IGNhblN0YXJ0RHJhZyhnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmdldFN0YXRlKCksIGlkKSwgW10pO1xuICBjb25zdCBnZXRJc01vdmVtZW50QWxsb3dlZCA9IHVzZUNhbGxiYWNrKCgpID0+IGlzTW92ZW1lbnRBbGxvd2VkKGdldFN0b3JlKGxhenlTdG9yZVJlZikuZ2V0U3RhdGUoKSksIFtdKTtcbiAgY29uc3QgYXBwQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBtYXJzaGFsOiBkaW1lbnNpb25NYXJzaGFsLFxuICAgIGZvY3VzOiBmb2N1c01hcnNoYWwsXG4gICAgY29udGV4dElkLFxuICAgIGNhbkxpZnQ6IGdldENhbkxpZnQsXG4gICAgaXNNb3ZlbWVudEFsbG93ZWQ6IGdldElzTW92ZW1lbnRBbGxvd2VkLFxuICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLFxuICAgIHJlZ2lzdHJ5XG4gIH0pLCBbY29udGV4dElkLCBkaW1lbnNpb25NYXJzaGFsLCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCwgZm9jdXNNYXJzaGFsLCBnZXRDYW5MaWZ0LCBnZXRJc01vdmVtZW50QWxsb3dlZCwgcmVnaXN0cnldKTtcbiAgdXNlU2Vuc29yTWFyc2hhbCh7XG4gICAgY29udGV4dElkLFxuICAgIHN0b3JlLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGN1c3RvbVNlbnNvcnM6IHNlbnNvcnMgfHwgbnVsbCxcbiAgICBlbmFibGVEZWZhdWx0U2Vuc29yczogcHJvcHMuZW5hYmxlRGVmYXVsdFNlbnNvcnMgIT09IGZhbHNlXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiB0cnlSZXNldFN0b3JlO1xuICB9LCBbdHJ5UmVzZXRTdG9yZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBcHBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGFwcENvbnRleHRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlciwge1xuICAgIGNvbnRleHQ6IFN0b3JlQ29udGV4dCxcbiAgICBzdG9yZTogc3RvcmVcbiAgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn1cblxuZnVuY3Rpb24gdXNlVW5pcXVlQ29udGV4dElkKCkge1xuICByZXR1cm4gUmVhY3QudXNlSWQoKTtcbn1cblxuZnVuY3Rpb24gRHJhZ0Ryb3BDb250ZXh0KHByb3BzKSB7XG4gIGNvbnN0IGNvbnRleHRJZCA9IHVzZVVuaXF1ZUNvbnRleHRJZCgpO1xuICBjb25zdCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMgPSBwcm9wcy5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMgfHwgcHJlc2V0LmRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucztcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwgbnVsbCwgc2V0Q2FsbGJhY2tzID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXBwLCB7XG4gICAgbm9uY2U6IHByb3BzLm5vbmNlLFxuICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgIHNldENhbGxiYWNrczogc2V0Q2FsbGJhY2tzLFxuICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uczogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zLFxuICAgIGVuYWJsZURlZmF1bHRTZW5zb3JzOiBwcm9wcy5lbmFibGVEZWZhdWx0U2Vuc29ycyxcbiAgICBzZW5zb3JzOiBwcm9wcy5zZW5zb3JzLFxuICAgIG9uQmVmb3JlQ2FwdHVyZTogcHJvcHMub25CZWZvcmVDYXB0dXJlLFxuICAgIG9uQmVmb3JlRHJhZ1N0YXJ0OiBwcm9wcy5vbkJlZm9yZURyYWdTdGFydCxcbiAgICBvbkRyYWdTdGFydDogcHJvcHMub25EcmFnU3RhcnQsXG4gICAgb25EcmFnVXBkYXRlOiBwcm9wcy5vbkRyYWdVcGRhdGUsXG4gICAgb25EcmFnRW5kOiBwcm9wcy5vbkRyYWdFbmQsXG4gICAgYXV0b1Njcm9sbGVyT3B0aW9uczogcHJvcHMuYXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9LCBwcm9wcy5jaGlsZHJlbikpO1xufVxuXG5jb25zdCB6SW5kZXhPcHRpb25zID0ge1xuICBkcmFnZ2luZzogNTAwMCxcbiAgZHJvcEFuaW1hdGluZzogNDUwMFxufTtcbmNvbnN0IGdldERyYWdnaW5nVHJhbnNpdGlvbiA9IChzaG91bGRBbmltYXRlRHJhZ01vdmVtZW50LCBkcm9wcGluZykgPT4ge1xuICBpZiAoZHJvcHBpbmcpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbnMuZHJvcChkcm9wcGluZy5kdXJhdGlvbik7XG4gIH1cbiAgaWYgKHNob3VsZEFuaW1hdGVEcmFnTW92ZW1lbnQpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbnMuc25hcDtcbiAgfVxuICByZXR1cm4gdHJhbnNpdGlvbnMuZmx1aWQ7XG59O1xuY29uc3QgZ2V0RHJhZ2dpbmdPcGFjaXR5ID0gKGlzQ29tYmluaW5nLCBpc0Ryb3BBbmltYXRpbmcpID0+IHtcbiAgaWYgKCFpc0NvbWJpbmluZykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGlzRHJvcEFuaW1hdGluZyA/IGNvbWJpbmUub3BhY2l0eS5kcm9wIDogY29tYmluZS5vcGFjaXR5LmNvbWJpbmluZztcbn07XG5jb25zdCBnZXRTaG91bGREcmFnZ2luZ0FuaW1hdGUgPSBkcmFnZ2luZyA9PiB7XG4gIGlmIChkcmFnZ2luZy5mb3JjZVNob3VsZEFuaW1hdGUgIT0gbnVsbCkge1xuICAgIHJldHVybiBkcmFnZ2luZy5mb3JjZVNob3VsZEFuaW1hdGU7XG4gIH1cbiAgcmV0dXJuIGRyYWdnaW5nLm1vZGUgPT09ICdTTkFQJztcbn07XG5mdW5jdGlvbiBnZXREcmFnZ2luZ1N0eWxlKGRyYWdnaW5nKSB7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IGRyYWdnaW5nLmRpbWVuc2lvbjtcbiAgY29uc3QgYm94ID0gZGltZW5zaW9uLmNsaWVudDtcbiAgY29uc3Qge1xuICAgIG9mZnNldCxcbiAgICBjb21iaW5lV2l0aCxcbiAgICBkcm9wcGluZ1xuICB9ID0gZHJhZ2dpbmc7XG4gIGNvbnN0IGlzQ29tYmluaW5nID0gQm9vbGVhbihjb21iaW5lV2l0aCk7XG4gIGNvbnN0IHNob3VsZEFuaW1hdGUgPSBnZXRTaG91bGREcmFnZ2luZ0FuaW1hdGUoZHJhZ2dpbmcpO1xuICBjb25zdCBpc0Ryb3BBbmltYXRpbmcgPSBCb29sZWFuKGRyb3BwaW5nKTtcbiAgY29uc3QgdHJhbnNmb3JtID0gaXNEcm9wQW5pbWF0aW5nID8gdHJhbnNmb3Jtcy5kcm9wKG9mZnNldCwgaXNDb21iaW5pbmcpIDogdHJhbnNmb3Jtcy5tb3ZlVG8ob2Zmc2V0KTtcbiAgY29uc3Qgc3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgdG9wOiBib3gubWFyZ2luQm94LnRvcCxcbiAgICBsZWZ0OiBib3gubWFyZ2luQm94LmxlZnQsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgd2lkdGg6IGJveC5ib3JkZXJCb3gud2lkdGgsXG4gICAgaGVpZ2h0OiBib3guYm9yZGVyQm94LmhlaWdodCxcbiAgICB0cmFuc2l0aW9uOiBnZXREcmFnZ2luZ1RyYW5zaXRpb24oc2hvdWxkQW5pbWF0ZSwgZHJvcHBpbmcpLFxuICAgIHRyYW5zZm9ybSxcbiAgICBvcGFjaXR5OiBnZXREcmFnZ2luZ09wYWNpdHkoaXNDb21iaW5pbmcsIGlzRHJvcEFuaW1hdGluZyksXG4gICAgekluZGV4OiBpc0Ryb3BBbmltYXRpbmcgPyB6SW5kZXhPcHRpb25zLmRyb3BBbmltYXRpbmcgOiB6SW5kZXhPcHRpb25zLmRyYWdnaW5nLFxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICB9O1xuICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTdHlsZShzZWNvbmRhcnkpIHtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybXMubW92ZVRvKHNlY29uZGFyeS5vZmZzZXQpLFxuICAgIHRyYW5zaXRpb246IHNlY29uZGFyeS5zaG91bGRBbmltYXRlRGlzcGxhY2VtZW50ID8gdW5kZWZpbmVkIDogJ25vbmUnXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTdHlsZSQxKG1hcHBlZCkge1xuICByZXR1cm4gbWFwcGVkLnR5cGUgPT09ICdEUkFHR0lORycgPyBnZXREcmFnZ2luZ1N0eWxlKG1hcHBlZCkgOiBnZXRTZWNvbmRhcnlTdHlsZShtYXBwZWQpO1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb24kMShkZXNjcmlwdG9yLCBlbCwgd2luZG93U2Nyb2xsID0gb3JpZ2luKSB7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBjb25zdCBib3JkZXJCb3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgY2xpZW50ID0gY2FsY3VsYXRlQm94KGJvcmRlckJveCwgY29tcHV0ZWRTdHlsZXMpO1xuICBjb25zdCBwYWdlID0gd2l0aFNjcm9sbChjbGllbnQsIHdpbmRvd1Njcm9sbCk7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0ge1xuICAgIGNsaWVudCxcbiAgICB0YWdOYW1lOiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgZGlzcGxheTogY29tcHV0ZWRTdHlsZXMuZGlzcGxheVxuICB9O1xuICBjb25zdCBkaXNwbGFjZUJ5ID0ge1xuICAgIHg6IGNsaWVudC5tYXJnaW5Cb3gud2lkdGgsXG4gICAgeTogY2xpZW50Lm1hcmdpbkJveC5oZWlnaHRcbiAgfTtcbiAgY29uc3QgZGltZW5zaW9uID0ge1xuICAgIGRlc2NyaXB0b3IsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgZGlzcGxhY2VCeSxcbiAgICBjbGllbnQsXG4gICAgcGFnZVxuICB9O1xuICByZXR1cm4gZGltZW5zaW9uO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnZ2FibGVQdWJsaXNoZXIoYXJncykge1xuICBjb25zdCB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkKCdkcmFnZ2FibGUnKTtcbiAgY29uc3Qge1xuICAgIGRlc2NyaXB0b3IsXG4gICAgcmVnaXN0cnksXG4gICAgZ2V0RHJhZ2dhYmxlUmVmLFxuICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGlzRW5hYmxlZFxuICB9ID0gYXJncztcbiAgY29uc3Qgb3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBpc0VuYWJsZWRcbiAgfSksIFtjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cywgaXNFbmFibGVkLCBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzc10pO1xuICBjb25zdCBnZXREaW1lbnNpb24gPSB1c2VDYWxsYmFjayh3aW5kb3dTY3JvbGwgPT4ge1xuICAgIGNvbnN0IGVsID0gZ2V0RHJhZ2dhYmxlUmVmKCk7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGdldCBkaW1lbnNpb24gd2hlbiBubyByZWYgaXMgc2V0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZ2V0RGltZW5zaW9uJDEoZGVzY3JpcHRvciwgZWwsIHdpbmRvd1Njcm9sbCk7XG4gIH0sIFtkZXNjcmlwdG9yLCBnZXREcmFnZ2FibGVSZWZdKTtcbiAgY29uc3QgZW50cnkgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgdW5pcXVlSWQsXG4gICAgZGVzY3JpcHRvcixcbiAgICBvcHRpb25zLFxuICAgIGdldERpbWVuc2lvblxuICB9KSwgW2Rlc2NyaXB0b3IsIGdldERpbWVuc2lvbiwgb3B0aW9ucywgdW5pcXVlSWRdKTtcbiAgY29uc3QgcHVibGlzaGVkUmVmID0gdXNlUmVmKGVudHJ5KTtcbiAgY29uc3QgaXNGaXJzdFB1Ymxpc2hSZWYgPSB1c2VSZWYodHJ1ZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJlZ2lzdHJ5LmRyYWdnYWJsZS5yZWdpc3RlcihwdWJsaXNoZWRSZWYuY3VycmVudCk7XG4gICAgcmV0dXJuICgpID0+IHJlZ2lzdHJ5LmRyYWdnYWJsZS51bnJlZ2lzdGVyKHB1Ymxpc2hlZFJlZi5jdXJyZW50KTtcbiAgfSwgW3JlZ2lzdHJ5LmRyYWdnYWJsZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNGaXJzdFB1Ymxpc2hSZWYuY3VycmVudCkge1xuICAgICAgaXNGaXJzdFB1Ymxpc2hSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gcHVibGlzaGVkUmVmLmN1cnJlbnQ7XG4gICAgcHVibGlzaGVkUmVmLmN1cnJlbnQgPSBlbnRyeTtcbiAgICByZWdpc3RyeS5kcmFnZ2FibGUudXBkYXRlKGVudHJ5LCBsYXN0KTtcbiAgfSwgW2VudHJ5LCByZWdpc3RyeS5kcmFnZ2FibGVdKTtcbn1cblxudmFyIERyb3BwYWJsZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5mdW5jdGlvbiBjaGVja0lzVmFsaWRJbm5lclJlZihlbCkge1xuICAhKGVsICYmIGlzSHRtbEVsZW1lbnQoZWwpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFxuICAgIHByb3ZpZGVkLmlubmVyUmVmIGhhcyBub3QgYmVlbiBwcm92aWRlZCB3aXRoIGEgSFRNTEVsZW1lbnQuXG5cbiAgICBZb3UgY2FuIGZpbmQgYSBndWlkZSBvbiB1c2luZyB0aGUgaW5uZXJSZWYgY2FsbGJhY2sgZnVuY3Rpb25zIGF0OlxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2d1aWRlcy91c2luZy1pbm5lci1yZWYubWRcbiAgYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gdXNlVmFsaWRhdGlvbiQxKHByb3BzLCBjb250ZXh0SWQsIGdldFJlZikge1xuICB1c2VEZXZTZXR1cFdhcm5pbmcoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHByZWZpeChpZCkge1xuICAgICAgcmV0dXJuIGBEcmFnZ2FibGVbaWQ6ICR7aWR9XTogYDtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBwcm9wcy5kcmFnZ2FibGVJZDtcbiAgICAhaWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdEcmFnZ2FibGUgcmVxdWlyZXMgYSBkcmFnZ2FibGVJZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgRHJhZ2dhYmxlIHJlcXVpcmVzIGEgW3N0cmluZ10gZHJhZ2dhYmxlSWQuXG4gICAgICBQcm92aWRlZDogW3R5cGU6ICR7dHlwZW9mIGlkfV0gKHZhbHVlOiAke2lkfSlgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIU51bWJlci5pc0ludGVnZXIocHJvcHMuaW5kZXgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHtwcmVmaXgoaWQpfSByZXF1aXJlcyBhbiBpbnRlZ2VyIGluZGV4IHByb3BgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgaWYgKHByb3BzLm1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNoZWNrSXNWYWxpZElubmVyUmVmKGdldFJlZigpKTtcbiAgICBpZiAocHJvcHMuaXNFbmFibGVkKSB7XG4gICAgICAhZmluZERyYWdIYW5kbGUoY29udGV4dElkLCBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke3ByZWZpeChpZCl9IFVuYWJsZSB0byBmaW5kIGRyYWcgaGFuZGxlYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VDbG9uZVByb3BWYWxpZGF0aW9uKGlzQ2xvbmUpIHtcbiAgdXNlRGV2KCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsUmVmID0gdXNlUmVmKGlzQ2xvbmUpO1xuICAgIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgICAhKGlzQ2xvbmUgPT09IGluaXRpYWxSZWYuY3VycmVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdEcmFnZ2FibGUgaXNDbG9uZSBwcm9wIHZhbHVlIGNoYW5nZWQgZHVyaW5nIGNvbXBvbmVudCBsaWZlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH0sIFtpc0Nsb25lXSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VSZXF1aXJlZENvbnRleHQoQ29udGV4dCkge1xuICBjb25zdCByZXN1bHQgPSB1c2VDb250ZXh0KENvbnRleHQpO1xuICAhcmVzdWx0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgcmVxdWlyZWQgY29udGV4dCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRIdG1sNURuZChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuY29uc3QgRHJhZ2dhYmxlID0gcHJvcHMgPT4ge1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldFJlZiA9IHVzZUNhbGxiYWNrKChlbCA9IG51bGwpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGVsO1xuICB9LCBbXSk7XG4gIGNvbnN0IGdldFJlZiA9IHVzZUNhbGxiYWNrKCgpID0+IHJlZi5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0SWQsXG4gICAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsXG4gICAgcmVnaXN0cnlcbiAgfSA9IHVzZVJlcXVpcmVkQ29udGV4dChBcHBDb250ZXh0KTtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgZHJvcHBhYmxlSWRcbiAgfSA9IHVzZVJlcXVpcmVkQ29udGV4dChEcm9wcGFibGVDb250ZXh0KTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpZDogcHJvcHMuZHJhZ2dhYmxlSWQsXG4gICAgaW5kZXg6IHByb3BzLmluZGV4LFxuICAgIHR5cGUsXG4gICAgZHJvcHBhYmxlSWRcbiAgfSksIFtwcm9wcy5kcmFnZ2FibGVJZCwgcHJvcHMuaW5kZXgsIHR5cGUsIGRyb3BwYWJsZUlkXSk7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBkcmFnZ2FibGVJZCxcbiAgICBpc0VuYWJsZWQsXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgaXNDbG9uZSxcbiAgICBtYXBwZWQsXG4gICAgZHJvcEFuaW1hdGlvbkZpbmlzaGVkOiBkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb25cbiAgfSA9IHByb3BzO1xuICB1c2VWYWxpZGF0aW9uJDEocHJvcHMsIGNvbnRleHRJZCwgZ2V0UmVmKTtcbiAgdXNlQ2xvbmVQcm9wVmFsaWRhdGlvbihpc0Nsb25lKTtcbiAgaWYgKCFpc0Nsb25lKSB7XG4gICAgY29uc3QgZm9yUHVibGlzaGVyID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgZGVzY3JpcHRvcixcbiAgICAgIHJlZ2lzdHJ5LFxuICAgICAgZ2V0RHJhZ2dhYmxlUmVmOiBnZXRSZWYsXG4gICAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgaXNFbmFibGVkXG4gICAgfSksIFtkZXNjcmlwdG9yLCByZWdpc3RyeSwgZ2V0UmVmLCBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cywgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsIGlzRW5hYmxlZF0pO1xuICAgIHVzZURyYWdnYWJsZVB1Ymxpc2hlcihmb3JQdWJsaXNoZXIpO1xuICB9XG4gIGNvbnN0IGRyYWdIYW5kbGVQcm9wcyA9IHVzZU1lbW8oKCkgPT4gaXNFbmFibGVkID8ge1xuICAgIHRhYkluZGV4OiAwLFxuICAgIHJvbGU6ICdidXR0b24nLFxuICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsXG4gICAgJ2RhdGEtcmZkLWRyYWctaGFuZGxlLWRyYWdnYWJsZS1pZCc6IGRyYWdnYWJsZUlkLFxuICAgICdkYXRhLXJmZC1kcmFnLWhhbmRsZS1jb250ZXh0LWlkJzogY29udGV4dElkLFxuICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgb25EcmFnU3RhcnQ6IHByZXZlbnRIdG1sNURuZFxuICB9IDogbnVsbCwgW2NvbnRleHRJZCwgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsIGRyYWdnYWJsZUlkLCBpc0VuYWJsZWRdKTtcbiAgY29uc3Qgb25Nb3ZlRW5kID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmIChtYXBwZWQudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW1hcHBlZC5kcm9wcGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQucHJvcGVydHlOYW1lICE9PSAndHJhbnNmb3JtJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmbHVzaFN5bmMoZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uKTtcbiAgfSwgW2Ryb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvbiwgbWFwcGVkXSk7XG4gIGNvbnN0IHByb3ZpZGVkID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRTdHlsZSQxKG1hcHBlZCk7XG4gICAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gbWFwcGVkLnR5cGUgPT09ICdEUkFHR0lORycgJiYgbWFwcGVkLmRyb3BwaW5nID8gb25Nb3ZlRW5kIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGlubmVyUmVmOiBzZXRSZWYsXG4gICAgICBkcmFnZ2FibGVQcm9wczoge1xuICAgICAgICAnZGF0YS1yZmQtZHJhZ2dhYmxlLWNvbnRleHQtaWQnOiBjb250ZXh0SWQsXG4gICAgICAgICdkYXRhLXJmZC1kcmFnZ2FibGUtaWQnOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIG9uVHJhbnNpdGlvbkVuZFxuICAgICAgfSxcbiAgICAgIGRyYWdIYW5kbGVQcm9wc1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW2NvbnRleHRJZCwgZHJhZ0hhbmRsZVByb3BzLCBkcmFnZ2FibGVJZCwgbWFwcGVkLCBvbk1vdmVFbmQsIHNldFJlZl0pO1xuICBjb25zdCBydWJyaWMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZHJhZ2dhYmxlSWQ6IGRlc2NyaXB0b3IuaWQsXG4gICAgdHlwZTogZGVzY3JpcHRvci50eXBlLFxuICAgIHNvdXJjZToge1xuICAgICAgaW5kZXg6IGRlc2NyaXB0b3IuaW5kZXgsXG4gICAgICBkcm9wcGFibGVJZDogZGVzY3JpcHRvci5kcm9wcGFibGVJZFxuICAgIH1cbiAgfSksIFtkZXNjcmlwdG9yLmRyb3BwYWJsZUlkLCBkZXNjcmlwdG9yLmlkLCBkZXNjcmlwdG9yLmluZGV4LCBkZXNjcmlwdG9yLnR5cGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKHByb3ZpZGVkLCBtYXBwZWQuc25hcHNob3QsIHJ1YnJpYykpO1xufTtcblxudmFyIGlzU3RyaWN0RXF1YWwgPSAoYSwgYikgPT4gYSA9PT0gYjtcblxudmFyIHdoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdCA9IHJlc3VsdCA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21iaW5lLFxuICAgIGRlc3RpbmF0aW9uXG4gIH0gPSByZXN1bHQ7XG4gIGlmIChkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBkZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgfVxuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiBjb21iaW5lLmRyb3BwYWJsZUlkO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgZ2V0Q29tYmluZVdpdGhGcm9tUmVzdWx0ID0gcmVzdWx0ID0+IHtcbiAgcmV0dXJuIHJlc3VsdC5jb21iaW5lID8gcmVzdWx0LmNvbWJpbmUuZHJhZ2dhYmxlSWQgOiBudWxsO1xufTtcbmNvbnN0IGdldENvbWJpbmVXaXRoRnJvbUltcGFjdCA9IGltcGFjdCA9PiB7XG4gIHJldHVybiBpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJyA/IGltcGFjdC5hdC5jb21iaW5lLmRyYWdnYWJsZUlkIDogbnVsbDtcbn07XG5mdW5jdGlvbiBnZXREcmFnZ2FibGVTZWxlY3RvcigpIHtcbiAgY29uc3QgbWVtb2l6ZWRPZmZzZXQgPSBtZW1vaXplT25lKCh4LCB5KSA9PiAoe1xuICAgIHgsXG4gICAgeVxuICB9KSk7XG4gIGNvbnN0IGdldE1lbW9pemVkU25hcHNob3QgPSBtZW1vaXplT25lKChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIgPSBudWxsLCBjb21iaW5lV2l0aCA9IG51bGwsIGRyb3BwaW5nID0gbnVsbCkgPT4gKHtcbiAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgIGlzQ2xvbmUsXG4gICAgaXNEcm9wQW5pbWF0aW5nOiBCb29sZWFuKGRyb3BwaW5nKSxcbiAgICBkcm9wQW5pbWF0aW9uOiBkcm9wcGluZyxcbiAgICBtb2RlLFxuICAgIGRyYWdnaW5nT3ZlcixcbiAgICBjb21iaW5lV2l0aCxcbiAgICBjb21iaW5lVGFyZ2V0Rm9yOiBudWxsXG4gIH0pKTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVPbmUoKG9mZnNldCwgbW9kZSwgZGltZW5zaW9uLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIgPSBudWxsLCBjb21iaW5lV2l0aCA9IG51bGwsIGZvcmNlU2hvdWxkQW5pbWF0ZSA9IG51bGwpID0+ICh7XG4gICAgbWFwcGVkOiB7XG4gICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgZHJvcHBpbmc6IG51bGwsXG4gICAgICBkcmFnZ2luZ092ZXIsXG4gICAgICBjb21iaW5lV2l0aCxcbiAgICAgIG1vZGUsXG4gICAgICBvZmZzZXQsXG4gICAgICBkaW1lbnNpb24sXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGUsXG4gICAgICBzbmFwc2hvdDogZ2V0TWVtb2l6ZWRTbmFwc2hvdChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBudWxsKVxuICAgIH1cbiAgfSkpO1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IHtcbiAgICBpZiAoaXNEcmFnZ2luZyhzdGF0ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWQgIT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0O1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW293blByb3BzLmRyYWdnYWJsZUlkXTtcbiAgICAgIGNvbnN0IGRyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCk7XG4gICAgICBjb25zdCBjb21iaW5lV2l0aCA9IGdldENvbWJpbmVXaXRoRnJvbUltcGFjdChzdGF0ZS5pbXBhY3QpO1xuICAgICAgY29uc3QgZm9yY2VTaG91bGRBbmltYXRlID0gc3RhdGUuZm9yY2VTaG91bGRBbmltYXRlO1xuICAgICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMobWVtb2l6ZWRPZmZzZXQob2Zmc2V0LngsIG9mZnNldC55KSwgc3RhdGUubW92ZW1lbnRNb2RlLCBkaW1lbnNpb24sIG93blByb3BzLmlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGZvcmNlU2hvdWxkQW5pbWF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuICAgICAgaWYgKGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQgIT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNDbG9uZSA9IG93blByb3BzLmlzQ2xvbmU7XG4gICAgICBjb25zdCBkaW1lbnNpb24gPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbb3duUHJvcHMuZHJhZ2dhYmxlSWRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIGNvbnN0IG1vZGUgPSByZXN1bHQubW9kZTtcbiAgICAgIGNvbnN0IGRyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdChyZXN1bHQpO1xuICAgICAgY29uc3QgY29tYmluZVdpdGggPSBnZXRDb21iaW5lV2l0aEZyb21SZXN1bHQocmVzdWx0KTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gc3RhdGUuZHJvcER1cmF0aW9uO1xuICAgICAgY29uc3QgZHJvcHBpbmcgPSB7XG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBjdXJ2ZTogY3VydmVzLmRyb3AsXG4gICAgICAgIG1vdmVUbzogc3RhdGUubmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgb3BhY2l0eTogY29tYmluZVdpdGggPyBjb21iaW5lLm9wYWNpdHkuZHJvcCA6IG51bGwsXG4gICAgICAgIHNjYWxlOiBjb21iaW5lV2l0aCA/IGNvbWJpbmUuc2NhbGUuZHJvcCA6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXBwZWQ6IHtcbiAgICAgICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgICAgIG9mZnNldDogc3RhdGUubmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgICBkaW1lbnNpb24sXG4gICAgICAgICAgZHJvcHBpbmcsXG4gICAgICAgICAgZHJhZ2dpbmdPdmVyLFxuICAgICAgICAgIGNvbWJpbmVXaXRoLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiBudWxsLFxuICAgICAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KG1vZGUsIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGRyb3BwaW5nKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U25hcHNob3QoY29tYmluZVRhcmdldEZvciA9IG51bGwpIHtcbiAgcmV0dXJuIHtcbiAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICBpc0Ryb3BBbmltYXRpbmc6IGZhbHNlLFxuICAgIGlzQ2xvbmU6IGZhbHNlLFxuICAgIGRyb3BBbmltYXRpb246IG51bGwsXG4gICAgbW9kZTogbnVsbCxcbiAgICBkcmFnZ2luZ092ZXI6IG51bGwsXG4gICAgY29tYmluZVRhcmdldEZvcixcbiAgICBjb21iaW5lV2l0aDogbnVsbFxuICB9O1xufVxuY29uc3QgYXRSZXN0ID0ge1xuICBtYXBwZWQ6IHtcbiAgICB0eXBlOiAnU0VDT05EQVJZJyxcbiAgICBvZmZzZXQ6IG9yaWdpbixcbiAgICBjb21iaW5lVGFyZ2V0Rm9yOiBudWxsLFxuICAgIHNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQ6IHRydWUsXG4gICAgc25hcHNob3Q6IGdldFNlY29uZGFyeVNuYXBzaG90KG51bGwpXG4gIH1cbn07XG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTZWxlY3RvcigpIHtcbiAgY29uc3QgbWVtb2l6ZWRPZmZzZXQgPSBtZW1vaXplT25lKCh4LCB5KSA9PiAoe1xuICAgIHgsXG4gICAgeVxuICB9KSk7XG4gIGNvbnN0IGdldE1lbW9pemVkU25hcHNob3QgPSBtZW1vaXplT25lKGdldFNlY29uZGFyeVNuYXBzaG90KTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVPbmUoKG9mZnNldCwgY29tYmluZVRhcmdldEZvciA9IG51bGwsIHNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQpID0+ICh7XG4gICAgbWFwcGVkOiB7XG4gICAgICB0eXBlOiAnU0VDT05EQVJZJyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGNvbWJpbmVUYXJnZXRGb3IsXG4gICAgICBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50LFxuICAgICAgc25hcHNob3Q6IGdldE1lbW9pemVkU25hcHNob3QoY29tYmluZVRhcmdldEZvcilcbiAgICB9XG4gIH0pKTtcbiAgY29uc3QgZ2V0RmFsbGJhY2sgPSBjb21iaW5lVGFyZ2V0Rm9yID0+IHtcbiAgICByZXR1cm4gY29tYmluZVRhcmdldEZvciA/IGdldE1lbW9pemVkUHJvcHMob3JpZ2luLCBjb21iaW5lVGFyZ2V0Rm9yLCB0cnVlKSA6IG51bGw7XG4gIH07XG4gIGNvbnN0IGdldFByb3BzID0gKG93bklkLCBkcmFnZ2luZ0lkLCBpbXBhY3QsIGFmdGVyQ3JpdGljYWwpID0+IHtcbiAgICBjb25zdCB2aXN1YWxEaXNwbGFjZW1lbnQgPSBpbXBhY3QuZGlzcGxhY2VkLnZpc2libGVbb3duSWRdO1xuICAgIGNvbnN0IGlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QgPSBCb29sZWFuKGFmdGVyQ3JpdGljYWwuaW5WaXJ0dWFsTGlzdCAmJiBhZnRlckNyaXRpY2FsLmVmZmVjdGVkW293bklkXSk7XG4gICAgY29uc3QgY29tYmluZSA9IHRyeUdldENvbWJpbmUoaW1wYWN0KTtcbiAgICBjb25zdCBjb21iaW5lVGFyZ2V0Rm9yID0gY29tYmluZSAmJiBjb21iaW5lLmRyYWdnYWJsZUlkID09PSBvd25JZCA/IGRyYWdnaW5nSWQgOiBudWxsO1xuICAgIGlmICghdmlzdWFsRGlzcGxhY2VtZW50KSB7XG4gICAgICBpZiAoIWlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QpIHtcbiAgICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKGNvbWJpbmVUYXJnZXRGb3IpO1xuICAgICAgfVxuICAgICAgaWYgKGltcGFjdC5kaXNwbGFjZWQuaW52aXNpYmxlW293bklkXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5nZSA9IG5lZ2F0ZShhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IG1lbW9pemVkT2Zmc2V0KGNoYW5nZS54LCBjaGFuZ2UueSk7XG4gICAgICByZXR1cm4gZ2V0TWVtb2l6ZWRQcm9wcyhvZmZzZXQsIGNvbWJpbmVUYXJnZXRGb3IsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCkge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKGNvbWJpbmVUYXJnZXRGb3IpO1xuICAgIH1cbiAgICBjb25zdCBkaXNwbGFjZUJ5ID0gaW1wYWN0LmRpc3BsYWNlZEJ5LnBvaW50O1xuICAgIGNvbnN0IG9mZnNldCA9IG1lbW9pemVkT2Zmc2V0KGRpc3BsYWNlQnkueCwgZGlzcGxhY2VCeS55KTtcbiAgICByZXR1cm4gZ2V0TWVtb2l6ZWRQcm9wcyhvZmZzZXQsIGNvbWJpbmVUYXJnZXRGb3IsIHZpc3VhbERpc3BsYWNlbWVudC5zaG91bGRBbmltYXRlKTtcbiAgfTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiB7XG4gICAgaWYgKGlzRHJhZ2dpbmcoc3RhdGUpKSB7XG4gICAgICBpZiAoc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkID09PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQcm9wcyhvd25Qcm9wcy5kcmFnZ2FibGVJZCwgc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkLCBzdGF0ZS5pbXBhY3QsIHN0YXRlLmFmdGVyQ3JpdGljYWwpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcbiAgICAgIGlmIChjb21wbGV0ZWQucmVzdWx0LmRyYWdnYWJsZUlkID09PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQcm9wcyhvd25Qcm9wcy5kcmFnZ2FibGVJZCwgY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCwgY29tcGxldGVkLmltcGFjdCwgY29tcGxldGVkLmFmdGVyQ3JpdGljYWwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuY29uc3QgbWFrZU1hcFN0YXRlVG9Qcm9wcyQxID0gKCkgPT4ge1xuICBjb25zdCBkcmFnZ2luZ1NlbGVjdG9yID0gZ2V0RHJhZ2dhYmxlU2VsZWN0b3IoKTtcbiAgY29uc3Qgc2Vjb25kYXJ5U2VsZWN0b3IgPSBnZXRTZWNvbmRhcnlTZWxlY3RvcigpO1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IGRyYWdnaW5nU2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB8fCBzZWNvbmRhcnlTZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHx8IGF0UmVzdDtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyQxID0ge1xuICBkcm9wQW5pbWF0aW9uRmluaXNoZWQ6IGRyb3BBbmltYXRpb25GaW5pc2hlZFxufTtcbmNvbnN0IENvbm5lY3RlZERyYWdnYWJsZSA9IGNvbm5lY3QobWFrZU1hcFN0YXRlVG9Qcm9wcyQxLCBtYXBEaXNwYXRjaFRvUHJvcHMkMSwgbnVsbCwge1xuICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbDogaXNTdHJpY3RFcXVhbFxufSkoRHJhZ2dhYmxlKTtcblxuZnVuY3Rpb24gUHJpdmF0ZURyYWdnYWJsZShwcm9wcykge1xuICBjb25zdCBkcm9wcGFibGVDb250ZXh0ID0gdXNlUmVxdWlyZWRDb250ZXh0KERyb3BwYWJsZUNvbnRleHQpO1xuICBjb25zdCBpc1VzaW5nQ2xvbmVGb3IgPSBkcm9wcGFibGVDb250ZXh0LmlzVXNpbmdDbG9uZUZvcjtcbiAgaWYgKGlzVXNpbmdDbG9uZUZvciA9PT0gcHJvcHMuZHJhZ2dhYmxlSWQgJiYgIXByb3BzLmlzQ2xvbmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0ZWREcmFnZ2FibGUsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIFB1YmxpY0RyYWdnYWJsZShwcm9wcykge1xuICBjb25zdCBpc0VuYWJsZWQgPSB0eXBlb2YgcHJvcHMuaXNEcmFnRGlzYWJsZWQgPT09ICdib29sZWFuJyA/ICFwcm9wcy5pc0RyYWdEaXNhYmxlZCA6IHRydWU7XG4gIGNvbnN0IGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzID0gQm9vbGVhbihwcm9wcy5kaXNhYmxlSW50ZXJhY3RpdmVFbGVtZW50QmxvY2tpbmcpO1xuICBjb25zdCBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyA9IEJvb2xlYW4ocHJvcHMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChQcml2YXRlRHJhZ2dhYmxlLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBpc0Nsb25lOiBmYWxzZSxcbiAgICBpc0VuYWJsZWQ6IGlzRW5hYmxlZCxcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50czogY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IHNob3VsZFJlc3BlY3RGb3JjZVByZXNzXG4gIH0pKTtcbn1cblxuY29uc3QgaXNFcXVhbCA9IGJhc2UgPT4gdmFsdWUgPT4gYmFzZSA9PT0gdmFsdWU7XG5jb25zdCBpc1Njcm9sbCA9IGlzRXF1YWwoJ3Njcm9sbCcpO1xuY29uc3QgaXNBdXRvID0gaXNFcXVhbCgnYXV0bycpO1xuY29uc3QgaXNWaXNpYmxlID0gaXNFcXVhbCgndmlzaWJsZScpO1xuY29uc3QgaXNFaXRoZXIgPSAob3ZlcmZsb3csIGZuKSA9PiBmbihvdmVyZmxvdy5vdmVyZmxvd1gpIHx8IGZuKG92ZXJmbG93Lm92ZXJmbG93WSk7XG5jb25zdCBpc0JvdGggPSAob3ZlcmZsb3csIGZuKSA9PiBmbihvdmVyZmxvdy5vdmVyZmxvd1gpICYmIGZuKG92ZXJmbG93Lm92ZXJmbG93WSk7XG5jb25zdCBpc0VsZW1lbnRTY3JvbGxhYmxlID0gZWwgPT4ge1xuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgY29uc3Qgb3ZlcmZsb3cgPSB7XG4gICAgb3ZlcmZsb3dYOiBzdHlsZS5vdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZOiBzdHlsZS5vdmVyZmxvd1lcbiAgfTtcbiAgcmV0dXJuIGlzRWl0aGVyKG92ZXJmbG93LCBpc1Njcm9sbCkgfHwgaXNFaXRoZXIob3ZlcmZsb3csIGlzQXV0byk7XG59O1xuY29uc3QgaXNCb2R5U2Nyb2xsYWJsZSA9ICgpID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG4gIGNvbnN0IGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICFodG1sID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgaWYgKCFpc0VsZW1lbnRTY3JvbGxhYmxlKGJvZHkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGh0bWxTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuICBjb25zdCBodG1sT3ZlcmZsb3cgPSB7XG4gICAgb3ZlcmZsb3dYOiBodG1sU3R5bGUub3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WTogaHRtbFN0eWxlLm92ZXJmbG93WVxuICB9O1xuICBpZiAoaXNCb3RoKGh0bWxPdmVyZmxvdywgaXNWaXNpYmxlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICBXZSBoYXZlIGRldGVjdGVkIHRoYXQgeW91ciA8Ym9keT4gZWxlbWVudCBtaWdodCBiZSBhIHNjcm9sbCBjb250YWluZXIuXG4gICAgV2UgaGF2ZSBmb3VuZCBubyByZWxpYWJsZSB3YXkgb2YgZGV0ZWN0aW5nIHdoZXRoZXIgdGhlIDxib2R5PiBlbGVtZW50IGlzIGEgc2Nyb2xsIGNvbnRhaW5lci5cbiAgICBVbmRlciBtb3N0IGNpcmN1bXN0YW5jZXMgYSA8Ym9keT4gc2Nyb2xsIGJhciB3aWxsIGJlIG9uIHRoZSA8aHRtbD4gZWxlbWVudCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KVxuXG4gICAgQmVjYXVzZSB3ZSBjYW5ub3QgZGV0ZXJtaW5lIGlmIHRoZSA8Ym9keT4gaXMgYSBzY3JvbGwgY29udGFpbmVyLCBhbmQgZ2VuZXJhbGx5IGl0IGlzIG5vdCBvbmUsXG4gICAgd2Ugd2lsbCBiZSB0cmVhdGluZyB0aGUgPGJvZHk+IGFzICpub3QqIGEgc2Nyb2xsIGNvbnRhaW5lclxuXG4gICAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvZ3VpZGVzL2hvdy13ZS1kZXRlY3Qtc2Nyb2xsLWNvbnRhaW5lcnMubWRcbiAgYCkgOiB2b2lkIDA7XG4gIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBnZXRDbG9zZXN0U2Nyb2xsYWJsZSA9IGVsID0+IHtcbiAgaWYgKGVsID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gaXNCb2R5U2Nyb2xsYWJsZSgpID8gZWwgOiBudWxsO1xuICB9XG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc0VsZW1lbnRTY3JvbGxhYmxlKGVsKSkge1xuICAgIHJldHVybiBnZXRDbG9zZXN0U2Nyb2xsYWJsZShlbC5wYXJlbnRFbGVtZW50KTtcbiAgfVxuICByZXR1cm4gZWw7XG59O1xuXG52YXIgY2hlY2tGb3JOZXN0ZWRTY3JvbGxDb250YWluZXJzID0gc2Nyb2xsYWJsZSA9PiB7XG4gIGlmICghc2Nyb2xsYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhbm90aGVyU2Nyb2xsUGFyZW50ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGUoc2Nyb2xsYWJsZS5wYXJlbnRFbGVtZW50KTtcbiAgaWYgKCFhbm90aGVyU2Nyb2xsUGFyZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIERyb3BwYWJsZTogdW5zdXBwb3J0ZWQgbmVzdGVkIHNjcm9sbCBjb250YWluZXIgZGV0ZWN0ZWQuXG4gICAgQSBEcm9wcGFibGUgY2FuIG9ubHkgaGF2ZSBvbmUgc2Nyb2xsIHBhcmVudCAod2hpY2ggY2FuIGJlIGl0c2VsZilcbiAgICBOZXN0ZWQgc2Nyb2xsIGNvbnRhaW5lcnMgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlxuXG4gICAgV2UgaG9wZSB0byBzdXBwb3J0IG5lc3RlZCBzY3JvbGwgY29udGFpbmVycyBzb29uOiBodHRwczovL2dpdGh1Yi5jb20vYXRsYXNzaWFuL3JlYWN0LWJlYXV0aWZ1bC1kbmQvaXNzdWVzLzEzMVxuICBgKSA6IHZvaWQgMDtcbn07XG5cbnZhciBnZXRTY3JvbGwgPSBlbCA9PiAoe1xuICB4OiBlbC5zY3JvbGxMZWZ0LFxuICB5OiBlbC5zY3JvbGxUb3Bcbn0pO1xuXG5jb25zdCBnZXRJc0ZpeGVkID0gZWwgPT4ge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBpZiAoc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZ2V0SXNGaXhlZChlbC5wYXJlbnRFbGVtZW50KTtcbn07XG52YXIgZ2V0RW52ID0gc3RhcnQgPT4ge1xuICBjb25zdCBjbG9zZXN0U2Nyb2xsYWJsZSA9IGdldENsb3Nlc3RTY3JvbGxhYmxlKHN0YXJ0KTtcbiAgY29uc3QgaXNGaXhlZE9uUGFnZSA9IGdldElzRml4ZWQoc3RhcnQpO1xuICByZXR1cm4ge1xuICAgIGNsb3Nlc3RTY3JvbGxhYmxlLFxuICAgIGlzRml4ZWRPblBhZ2VcbiAgfTtcbn07XG5cbnZhciBnZXREcm9wcGFibGVEaW1lbnNpb24gPSAoe1xuICBkZXNjcmlwdG9yLFxuICBpc0VuYWJsZWQsXG4gIGlzQ29tYmluZUVuYWJsZWQsXG4gIGlzRml4ZWRPblBhZ2UsXG4gIGRpcmVjdGlvbixcbiAgY2xpZW50LFxuICBwYWdlLFxuICBjbG9zZXN0XG59KSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gKCgpID0+IHtcbiAgICBpZiAoIWNsb3Nlc3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxTaXplLFxuICAgICAgY2xpZW50OiBmcmFtZUNsaWVudFxuICAgIH0gPSBjbG9zZXN0O1xuICAgIGNvbnN0IG1heFNjcm9sbCA9IGdldE1heFNjcm9sbCh7XG4gICAgICBzY3JvbGxIZWlnaHQ6IHNjcm9sbFNpemUuc2Nyb2xsSGVpZ2h0LFxuICAgICAgc2Nyb2xsV2lkdGg6IHNjcm9sbFNpemUuc2Nyb2xsV2lkdGgsXG4gICAgICBoZWlnaHQ6IGZyYW1lQ2xpZW50LnBhZGRpbmdCb3guaGVpZ2h0LFxuICAgICAgd2lkdGg6IGZyYW1lQ2xpZW50LnBhZGRpbmdCb3gud2lkdGhcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZU1hcmdpbkJveDogY2xvc2VzdC5wYWdlLm1hcmdpbkJveCxcbiAgICAgIGZyYW1lQ2xpZW50LFxuICAgICAgc2Nyb2xsU2l6ZSxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0OiBjbG9zZXN0LnNob3VsZENsaXBTdWJqZWN0LFxuICAgICAgc2Nyb2xsOiB7XG4gICAgICAgIGluaXRpYWw6IGNsb3Nlc3Quc2Nyb2xsLFxuICAgICAgICBjdXJyZW50OiBjbG9zZXN0LnNjcm9sbCxcbiAgICAgICAgbWF4OiBtYXhTY3JvbGwsXG4gICAgICAgIGRpZmY6IHtcbiAgICAgICAgICB2YWx1ZTogb3JpZ2luLFxuICAgICAgICAgIGRpc3BsYWNlbWVudDogb3JpZ2luXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuICBjb25zdCBheGlzID0gZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gdmVydGljYWwgOiBob3Jpem9udGFsO1xuICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgYXhpcyxcbiAgICBmcmFtZVxuICB9KTtcbiAgY29uc3QgZGltZW5zaW9uID0ge1xuICAgIGRlc2NyaXB0b3IsXG4gICAgaXNDb21iaW5lRW5hYmxlZCxcbiAgICBpc0ZpeGVkT25QYWdlLFxuICAgIGF4aXMsXG4gICAgaXNFbmFibGVkLFxuICAgIGNsaWVudCxcbiAgICBwYWdlLFxuICAgIGZyYW1lLFxuICAgIHN1YmplY3RcbiAgfTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn07XG5cbmNvbnN0IGdldENsaWVudCA9ICh0YXJnZXRSZWYsIGNsb3Nlc3RTY3JvbGxhYmxlKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBnZXRCb3godGFyZ2V0UmVmKTtcbiAgaWYgKCFjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGlmICh0YXJnZXRSZWYgIT09IGNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgY29uc3QgdG9wID0gYmFzZS5wYWRkaW5nQm94LnRvcCAtIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbFRvcDtcbiAgY29uc3QgbGVmdCA9IGJhc2UucGFkZGluZ0JveC5sZWZ0IC0gY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsTGVmdDtcbiAgY29uc3QgYm90dG9tID0gdG9wICsgY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0O1xuICBjb25zdCByaWdodCA9IGxlZnQgKyBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxXaWR0aDtcbiAgY29uc3QgcGFkZGluZ0JveCA9IHtcbiAgICB0b3AsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tLFxuICAgIGxlZnRcbiAgfTtcbiAgY29uc3QgYm9yZGVyQm94ID0gZXhwYW5kKHBhZGRpbmdCb3gsIGJhc2UuYm9yZGVyKTtcbiAgY29uc3QgY2xpZW50ID0gY3JlYXRlQm94KHtcbiAgICBib3JkZXJCb3gsXG4gICAgbWFyZ2luOiBiYXNlLm1hcmdpbixcbiAgICBib3JkZXI6IGJhc2UuYm9yZGVyLFxuICAgIHBhZGRpbmc6IGJhc2UucGFkZGluZ1xuICB9KTtcbiAgcmV0dXJuIGNsaWVudDtcbn07XG52YXIgZ2V0RGltZW5zaW9uID0gKHtcbiAgcmVmLFxuICBkZXNjcmlwdG9yLFxuICBlbnYsXG4gIHdpbmRvd1Njcm9sbCxcbiAgZGlyZWN0aW9uLFxuICBpc0Ryb3BEaXNhYmxlZCxcbiAgaXNDb21iaW5lRW5hYmxlZCxcbiAgc2hvdWxkQ2xpcFN1YmplY3Rcbn0pID0+IHtcbiAgY29uc3QgY2xvc2VzdFNjcm9sbGFibGUgPSBlbnYuY2xvc2VzdFNjcm9sbGFibGU7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudChyZWYsIGNsb3Nlc3RTY3JvbGxhYmxlKTtcbiAgY29uc3QgcGFnZSA9IHdpdGhTY3JvbGwoY2xpZW50LCB3aW5kb3dTY3JvbGwpO1xuICBjb25zdCBjbG9zZXN0ID0gKCgpID0+IHtcbiAgICBpZiAoIWNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZnJhbWVDbGllbnQgPSBnZXRCb3goY2xvc2VzdFNjcm9sbGFibGUpO1xuICAgIGNvbnN0IHNjcm9sbFNpemUgPSB7XG4gICAgICBzY3JvbGxIZWlnaHQ6IGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxXaWR0aFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudDogZnJhbWVDbGllbnQsXG4gICAgICBwYWdlOiB3aXRoU2Nyb2xsKGZyYW1lQ2xpZW50LCB3aW5kb3dTY3JvbGwpLFxuICAgICAgc2Nyb2xsOiBnZXRTY3JvbGwoY2xvc2VzdFNjcm9sbGFibGUpLFxuICAgICAgc2Nyb2xsU2l6ZSxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0XG4gICAgfTtcbiAgfSkoKTtcbiAgY29uc3QgZGltZW5zaW9uID0gZ2V0RHJvcHBhYmxlRGltZW5zaW9uKHtcbiAgICBkZXNjcmlwdG9yLFxuICAgIGlzRW5hYmxlZDogIWlzRHJvcERpc2FibGVkLFxuICAgIGlzQ29tYmluZUVuYWJsZWQsXG4gICAgaXNGaXhlZE9uUGFnZTogZW52LmlzRml4ZWRPblBhZ2UsXG4gICAgZGlyZWN0aW9uLFxuICAgIGNsaWVudCxcbiAgICBwYWdlLFxuICAgIGNsb3Nlc3RcbiAgfSk7XG4gIHJldHVybiBkaW1lbnNpb247XG59O1xuXG5jb25zdCBpbW1lZGlhdGUgPSB7XG4gIHBhc3NpdmU6IGZhbHNlXG59O1xuY29uc3QgZGVsYXllZCA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcbnZhciBnZXRMaXN0ZW5lck9wdGlvbnMgPSBvcHRpb25zID0+IG9wdGlvbnMuc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5ID8gaW1tZWRpYXRlIDogZGVsYXllZDtcblxuY29uc3QgZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyA9IGRyYWdnaW5nID0+IGRyYWdnaW5nICYmIGRyYWdnaW5nLmVudi5jbG9zZXN0U2Nyb2xsYWJsZSB8fCBudWxsO1xuZnVuY3Rpb24gdXNlRHJvcHBhYmxlUHVibGlzaGVyKGFyZ3MpIHtcbiAgY29uc3Qgd2hpbGVEcmFnZ2luZ1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgYXBwQ29udGV4dCA9IHVzZVJlcXVpcmVkQ29udGV4dChBcHBDb250ZXh0KTtcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VVbmlxdWVJZCgnZHJvcHBhYmxlJyk7XG4gIGNvbnN0IHtcbiAgICByZWdpc3RyeSxcbiAgICBtYXJzaGFsXG4gIH0gPSBhcHBDb250ZXh0O1xuICBjb25zdCBwcmV2aW91c1JlZiA9IHVzZVByZXZpb3VzKGFyZ3MpO1xuICBjb25zdCBkZXNjcmlwdG9yID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlkOiBhcmdzLmRyb3BwYWJsZUlkLFxuICAgIHR5cGU6IGFyZ3MudHlwZSxcbiAgICBtb2RlOiBhcmdzLm1vZGVcbiAgfSksIFthcmdzLmRyb3BwYWJsZUlkLCBhcmdzLm1vZGUsIGFyZ3MudHlwZV0pO1xuICBjb25zdCBwdWJsaXNoZWREZXNjcmlwdG9yUmVmID0gdXNlUmVmKGRlc2NyaXB0b3IpO1xuICBjb25zdCBtZW1vaXplZFVwZGF0ZVNjcm9sbCA9IHVzZU1lbW8oKCkgPT4gbWVtb2l6ZU9uZSgoeCwgeSkgPT4ge1xuICAgICF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgc2Nyb2xsIHdoZW4gZHJhZ2dpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHNjcm9sbCA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZVNjcm9sbChkZXNjcmlwdG9yLmlkLCBzY3JvbGwpO1xuICB9KSwgW2Rlc2NyaXB0b3IuaWQsIG1hcnNoYWxdKTtcbiAgY29uc3QgZ2V0Q2xvc2VzdFNjcm9sbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICBpZiAoIWRyYWdnaW5nIHx8ICFkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIHJldHVybiBnZXRTY3JvbGwoZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlKTtcbiAgfSwgW10pO1xuICBjb25zdCB1cGRhdGVTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsID0gZ2V0Q2xvc2VzdFNjcm9sbCgpO1xuICAgIG1lbW9pemVkVXBkYXRlU2Nyb2xsKHNjcm9sbC54LCBzY3JvbGwueSk7XG4gIH0sIFtnZXRDbG9zZXN0U2Nyb2xsLCBtZW1vaXplZFVwZGF0ZVNjcm9sbF0pO1xuICBjb25zdCBzY2hlZHVsZVNjcm9sbFVwZGF0ZSA9IHVzZU1lbW8oKCkgPT4gcmFmU2NoZCh1cGRhdGVTY3JvbGwpLCBbdXBkYXRlU2Nyb2xsXSk7XG4gIGNvbnN0IG9uQ2xvc2VzdFNjcm9sbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICBjb25zdCBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgIShkcmFnZ2luZyAmJiBjbG9zZXN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHNjcm9sbCBvcHRpb25zIHdoaWxlIHNjcm9sbGluZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGRyYWdnaW5nLnNjcm9sbE9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5KSB7XG4gICAgICB1cGRhdGVTY3JvbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGVTY3JvbGxVcGRhdGUoKTtcbiAgfSwgW3NjaGVkdWxlU2Nyb2xsVXBkYXRlLCB1cGRhdGVTY3JvbGxdKTtcbiAgY29uc3QgZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwgPSB1c2VDYWxsYmFjaygod2luZG93U2Nyb2xsLCBvcHRpb25zKSA9PiB7XG4gICAgISF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29sbGVjdCBhIGRyb3BwYWJsZSB3aGlsZSBhIGRyYWcgaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBwcmV2aW91cyA9IHByZXZpb3VzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcmVmID0gcHJldmlvdXMuZ2V0RHJvcHBhYmxlUmVmKCk7XG4gICAgIXJlZiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjb2xsZWN0IHdpdGhvdXQgYSBkcm9wcGFibGUgcmVmJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBlbnYgPSBnZXRFbnYocmVmKTtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHtcbiAgICAgIHJlZixcbiAgICAgIGRlc2NyaXB0b3IsXG4gICAgICBlbnYsXG4gICAgICBzY3JvbGxPcHRpb25zOiBvcHRpb25zXG4gICAgfTtcbiAgICB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPSBkcmFnZ2luZztcbiAgICBjb25zdCBkaW1lbnNpb24gPSBnZXREaW1lbnNpb24oe1xuICAgICAgcmVmLFxuICAgICAgZGVzY3JpcHRvcixcbiAgICAgIGVudixcbiAgICAgIHdpbmRvd1Njcm9sbCxcbiAgICAgIGRpcmVjdGlvbjogcHJldmlvdXMuZGlyZWN0aW9uLFxuICAgICAgaXNEcm9wRGlzYWJsZWQ6IHByZXZpb3VzLmlzRHJvcERpc2FibGVkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZDogcHJldmlvdXMuaXNDb21iaW5lRW5hYmxlZCxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0OiAhcHJldmlvdXMuaWdub3JlQ29udGFpbmVyQ2xpcHBpbmdcbiAgICB9KTtcbiAgICBjb25zdCBzY3JvbGxhYmxlID0gZW52LmNsb3Nlc3RTY3JvbGxhYmxlO1xuICAgIGlmIChzY3JvbGxhYmxlKSB7XG4gICAgICBzY3JvbGxhYmxlLnNldEF0dHJpYnV0ZShzY3JvbGxDb250YWluZXIuY29udGV4dElkLCBhcHBDb250ZXh0LmNvbnRleHRJZCk7XG4gICAgICBzY3JvbGxhYmxlLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uQ2xvc2VzdFNjcm9sbCwgZ2V0TGlzdGVuZXJPcHRpb25zKGRyYWdnaW5nLnNjcm9sbE9wdGlvbnMpKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyhzY3JvbGxhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbiAgfSwgW2FwcENvbnRleHQuY29udGV4dElkLCBkZXNjcmlwdG9yLCBvbkNsb3Nlc3RTY3JvbGwsIHByZXZpb3VzUmVmXSk7XG4gIGNvbnN0IGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICEoZHJhZ2dpbmcgJiYgY2xvc2VzdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSByZWNvbGxlY3QgRHJvcHBhYmxlIGNsaWVudCBmb3IgRHJvcHBhYmxlcyB0aGF0IGhhdmUgYSBzY3JvbGwgY29udGFpbmVyJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZ2V0U2Nyb2xsKGNsb3Nlc3QpO1xuICB9LCBbXSk7XG4gIGNvbnN0IGRyYWdTdG9wcGVkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdG9wIGRyYWcgd2hlbiBubyBhY3RpdmUgZHJhZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgIHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCA9IG51bGw7XG4gICAgaWYgKCFjbG9zZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlU2Nyb2xsVXBkYXRlLmNhbmNlbCgpO1xuICAgIGNsb3Nlc3QucmVtb3ZlQXR0cmlidXRlKHNjcm9sbENvbnRhaW5lci5jb250ZXh0SWQpO1xuICAgIGNsb3Nlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25DbG9zZXN0U2Nyb2xsLCBnZXRMaXN0ZW5lck9wdGlvbnMoZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucykpO1xuICB9LCBbb25DbG9zZXN0U2Nyb2xsLCBzY2hlZHVsZVNjcm9sbFVwZGF0ZV0pO1xuICBjb25zdCBzY3JvbGwgPSB1c2VDYWxsYmFjayhjaGFuZ2UgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzY3JvbGwgd2hlbiB0aGVyZSBpcyBubyBkcmFnJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgIWNsb3Nlc3QgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2Nyb2xsIGEgZHJvcHBhYmxlIHdpdGggbm8gY2xvc2VzdCBzY3JvbGxhYmxlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjbG9zZXN0LnNjcm9sbFRvcCArPSBjaGFuZ2UueTtcbiAgICBjbG9zZXN0LnNjcm9sbExlZnQgKz0gY2hhbmdlLng7XG4gIH0sIFtdKTtcbiAgY29uc3QgY2FsbGJhY2tzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsLFxuICAgICAgZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZyxcbiAgICAgIGRyYWdTdG9wcGVkLFxuICAgICAgc2Nyb2xsXG4gICAgfTtcbiAgfSwgW2RyYWdTdG9wcGVkLCBnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCwgZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZywgc2Nyb2xsXSk7XG4gIGNvbnN0IGVudHJ5ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHVuaXF1ZUlkLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgY2FsbGJhY2tzXG4gIH0pLCBbY2FsbGJhY2tzLCBkZXNjcmlwdG9yLCB1bmlxdWVJZF0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQgPSBlbnRyeS5kZXNjcmlwdG9yO1xuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5yZWdpc3RlcihlbnRyeSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnVW5zdXBwb3J0ZWQ6IGNoYW5naW5nIHRoZSBkcm9wcGFibGVJZCBvciB0eXBlIG9mIGEgRHJvcHBhYmxlIGR1cmluZyBhIGRyYWcnKSA6IHZvaWQgMDtcbiAgICAgICAgZHJhZ1N0b3BwZWQoKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS51bnJlZ2lzdGVyKGVudHJ5KTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2tzLCBkZXNjcmlwdG9yLCBkcmFnU3RvcHBlZCwgZW50cnksIG1hcnNoYWwsIHJlZ2lzdHJ5LmRyb3BwYWJsZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZChwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQuaWQsICFhcmdzLmlzRHJvcERpc2FibGVkKTtcbiAgfSwgW2FyZ3MuaXNEcm9wRGlzYWJsZWQsIG1hcnNoYWxdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWFyc2hhbC51cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkKHB1Ymxpc2hlZERlc2NyaXB0b3JSZWYuY3VycmVudC5pZCwgYXJncy5pc0NvbWJpbmVFbmFibGVkKTtcbiAgfSwgW2FyZ3MuaXNDb21iaW5lRW5hYmxlZCwgbWFyc2hhbF0pO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbmNvbnN0IGVtcHR5ID0ge1xuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICBtYXJnaW46IG5vU3BhY2luZ1xufTtcbmNvbnN0IGdldFNpemUgPSAoe1xuICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICBwbGFjZWhvbGRlcixcbiAgYW5pbWF0ZVxufSkgPT4ge1xuICBpZiAoaXNBbmltYXRpbmdPcGVuT25Nb3VudCkge1xuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuICBpZiAoYW5pbWF0ZSA9PT0gJ2Nsb3NlJykge1xuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhlaWdodDogcGxhY2Vob2xkZXIuY2xpZW50LmJvcmRlckJveC5oZWlnaHQsXG4gICAgd2lkdGg6IHBsYWNlaG9sZGVyLmNsaWVudC5ib3JkZXJCb3gud2lkdGgsXG4gICAgbWFyZ2luOiBwbGFjZWhvbGRlci5jbGllbnQubWFyZ2luXG4gIH07XG59O1xuY29uc3QgZ2V0U3R5bGUgPSAoe1xuICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICBwbGFjZWhvbGRlcixcbiAgYW5pbWF0ZVxufSkgPT4ge1xuICBjb25zdCBzaXplID0gZ2V0U2l6ZSh7XG4gICAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgICBwbGFjZWhvbGRlcixcbiAgICBhbmltYXRlXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRpc3BsYXk6IHBsYWNlaG9sZGVyLmRpc3BsYXksXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICBtYXJnaW5Ub3A6IHNpemUubWFyZ2luLnRvcCxcbiAgICBtYXJnaW5SaWdodDogc2l6ZS5tYXJnaW4ucmlnaHQsXG4gICAgbWFyZ2luQm90dG9tOiBzaXplLm1hcmdpbi5ib3R0b20sXG4gICAgbWFyZ2luTGVmdDogc2l6ZS5tYXJnaW4ubGVmdCxcbiAgICBmbGV4U2hyaW5rOiAnMCcsXG4gICAgZmxleEdyb3c6ICcwJyxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgdHJhbnNpdGlvbjogYW5pbWF0ZSAhPT0gJ25vbmUnID8gdHJhbnNpdGlvbnMucGxhY2Vob2xkZXIgOiBudWxsXG4gIH07XG59O1xuY29uc3QgUGxhY2Vob2xkZXIgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IGFuaW1hdGVPcGVuVGltZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50KTtcbiAgICBhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICB9LCBbXSk7XG4gIGNvbnN0IHtcbiAgICBhbmltYXRlLFxuICAgIG9uVHJhbnNpdGlvbkVuZCxcbiAgICBvbkNsb3NlLFxuICAgIGNvbnRleHRJZFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFtpc0FuaW1hdGluZ09wZW5Pbk1vdW50LCBzZXRJc0FuaW1hdGluZ09wZW5Pbk1vdW50XSA9IHVzZVN0YXRlKHByb3BzLmFuaW1hdGUgPT09ICdvcGVuJyk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0FuaW1hdGluZ09wZW5Pbk1vdW50KSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGUgIT09ICdvcGVuJykge1xuICAgICAgdHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyKCk7XG4gICAgICBzZXRJc0FuaW1hdGluZ09wZW5Pbk1vdW50KGZhbHNlKTtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudChmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcjtcbiAgfSwgW2FuaW1hdGUsIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcl0pO1xuICBjb25zdCBvblNpemVDaGFuZ2VFbmQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ2hlaWdodCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25UcmFuc2l0aW9uRW5kKCk7XG4gICAgaWYgKGFuaW1hdGUgPT09ICdjbG9zZScpIHtcbiAgICAgIG9uQ2xvc2UoKTtcbiAgICB9XG4gIH0sIFthbmltYXRlLCBvbkNsb3NlLCBvblRyYW5zaXRpb25FbmRdKTtcbiAgY29uc3Qgc3R5bGUgPSBnZXRTdHlsZSh7XG4gICAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgICBhbmltYXRlOiBwcm9wcy5hbmltYXRlLFxuICAgIHBsYWNlaG9sZGVyOiBwcm9wcy5wbGFjZWhvbGRlclxuICB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQocHJvcHMucGxhY2Vob2xkZXIudGFnTmFtZSwge1xuICAgIHN0eWxlLFxuICAgICdkYXRhLXJmZC1wbGFjZWhvbGRlci1jb250ZXh0LWlkJzogY29udGV4dElkLFxuICAgIG9uVHJhbnNpdGlvbkVuZDogb25TaXplQ2hhbmdlRW5kLFxuICAgIHJlZjogcHJvcHMuaW5uZXJSZWZcbiAgfSk7XG59O1xudmFyIFBsYWNlaG9sZGVyJDEgPSBSZWFjdC5tZW1vKFBsYWNlaG9sZGVyKTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbn1cbmZ1bmN0aW9uIHJ1bkNoZWNrcyhhcmdzLCBjaGVja3MpIHtcbiAgY2hlY2tzLmZvckVhY2goY2hlY2sgPT4gY2hlY2soYXJncykpO1xufVxuY29uc3Qgc2hhcmVkID0gW2Z1bmN0aW9uIHJlcXVpcmVkKHtcbiAgcHJvcHNcbn0pIHtcbiAgIXByb3BzLmRyb3BwYWJsZUlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQSBEcm9wcGFibGUgcmVxdWlyZXMgYSBkcm9wcGFibGVJZCBwcm9wJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgISh0eXBlb2YgcHJvcHMuZHJvcHBhYmxlSWQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYEEgRHJvcHBhYmxlIHJlcXVpcmVzIGEgW3N0cmluZ10gZHJvcHBhYmxlSWQuIFByb3ZpZGVkOiBbJHt0eXBlb2YgcHJvcHMuZHJvcHBhYmxlSWR9XWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG59LCBmdW5jdGlvbiBib29sZWFuKHtcbiAgcHJvcHNcbn0pIHtcbiAgIWlzQm9vbGVhbihwcm9wcy5pc0Ryb3BEaXNhYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0Ryb3BEaXNhYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICFpc0Jvb2xlYW4ocHJvcHMuaXNDb21iaW5lRW5hYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0NvbWJpbmVFbmFibGVkIG11c3QgYmUgYSBib29sZWFuJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgIWlzQm9vbGVhbihwcm9wcy5pZ25vcmVDb250YWluZXJDbGlwcGluZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpZ25vcmVDb250YWluZXJDbGlwcGluZyBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG59LCBmdW5jdGlvbiByZWYoe1xuICBnZXREcm9wcGFibGVSZWZcbn0pIHtcbiAgY2hlY2tJc1ZhbGlkSW5uZXJSZWYoZ2V0RHJvcHBhYmxlUmVmKCkpO1xufV07XG5jb25zdCBzdGFuZGFyZCA9IFtmdW5jdGlvbiBwbGFjZWhvbGRlcih7XG4gIHByb3BzLFxuICBnZXRQbGFjZWhvbGRlclJlZlxufSkge1xuICBpZiAoIXByb3BzLnBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlZiA9IGdldFBsYWNlaG9sZGVyUmVmKCk7XG4gIGlmIChyZWYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBEcm9wcGFibGUgc2V0dXAgaXNzdWUgW2Ryb3BwYWJsZUlkOiBcIiR7cHJvcHMuZHJvcHBhYmxlSWR9XCJdOlxuICAgICAgRHJvcHBhYmxlUHJvdmlkZWQgPiBwbGFjZWhvbGRlciBjb3VsZCBub3QgYmUgZm91bmQuXG5cbiAgICAgIFBsZWFzZSBiZSBzdXJlIHRvIGFkZCB0aGUge3Byb3ZpZGVkLnBsYWNlaG9sZGVyfSBSZWFjdCBOb2RlIGFzIGEgY2hpbGQgb2YgeW91ciBEcm9wcGFibGUuXG4gICAgICBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9hcGkvZHJvcHBhYmxlLm1kXG4gICAgYCkgOiB2b2lkIDA7XG59XTtcbmNvbnN0IHZpcnR1YWwgPSBbZnVuY3Rpb24gaGFzQ2xvbmUoe1xuICBwcm9wc1xufSkge1xuICAhcHJvcHMucmVuZGVyQ2xvbmUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IHByb3ZpZGUgYSBjbG9uZSByZW5kZXIgZnVuY3Rpb24gKHJlbmRlckNsb25lKSBmb3IgdmlydHVhbCBsaXN0cycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG59LCBmdW5jdGlvbiBoYXNOb1BsYWNlaG9sZGVyKHtcbiAgZ2V0UGxhY2Vob2xkZXJSZWZcbn0pIHtcbiAgISFnZXRQbGFjZWhvbGRlclJlZigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdmlydHVhbCBsaXN0IHRvIG5vdCBoYXZlIGEgcGxhY2Vob2xkZXInKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xufV07XG5mdW5jdGlvbiB1c2VWYWxpZGF0aW9uKGFyZ3MpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICBydW5DaGVja3MoYXJncywgc2hhcmVkKTtcbiAgICBpZiAoYXJncy5wcm9wcy5tb2RlID09PSAnc3RhbmRhcmQnKSB7XG4gICAgICBydW5DaGVja3MoYXJncywgc3RhbmRhcmQpO1xuICAgIH1cbiAgICBpZiAoYXJncy5wcm9wcy5tb2RlID09PSAndmlydHVhbCcpIHtcbiAgICAgIHJ1bkNoZWNrcyhhcmdzLCB2aXJ0dWFsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5jbGFzcyBBbmltYXRlSW5PdXQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5wcm9wcy5vbiksXG4gICAgICBkYXRhOiB0aGlzLnByb3BzLm9uLFxuICAgICAgYW5pbWF0ZTogdGhpcy5wcm9wcy5zaG91bGRBbmltYXRlICYmIHRoaXMucHJvcHMub24gPyAnb3BlbicgOiAnbm9uZSdcbiAgICB9O1xuICAgIHRoaXMub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmFuaW1hdGUgIT09ICdjbG9zZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzVmlzaWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAoIXByb3BzLnNob3VsZEFuaW1hdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmlzaWJsZTogQm9vbGVhbihwcm9wcy5vbiksXG4gICAgICAgIGRhdGE6IHByb3BzLm9uLFxuICAgICAgICBhbmltYXRlOiAnbm9uZSdcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcm9wcy5vbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBkYXRhOiBwcm9wcy5vbixcbiAgICAgICAgYW5pbWF0ZTogJ29wZW4nXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGRhdGE6IHN0YXRlLmRhdGEsXG4gICAgICAgIGFuaW1hdGU6ICdjbG9zZSdcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgYW5pbWF0ZTogJ2Nsb3NlJyxcbiAgICAgIGRhdGE6IG51bGxcbiAgICB9O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZWQgPSB7XG4gICAgICBvbkNsb3NlOiB0aGlzLm9uQ2xvc2UsXG4gICAgICBkYXRhOiB0aGlzLnN0YXRlLmRhdGEsXG4gICAgICBhbmltYXRlOiB0aGlzLnN0YXRlLmFuaW1hdGVcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHByb3ZpZGVkKTtcbiAgfVxufVxuXG5jb25zdCBEcm9wcGFibGUgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xuICAhYXBwQ29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIGFwcCBjb250ZXh0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3Qge1xuICAgIGNvbnRleHRJZCxcbiAgICBpc01vdmVtZW50QWxsb3dlZFxuICB9ID0gYXBwQ29udGV4dDtcbiAgY29uc3QgZHJvcHBhYmxlUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBwbGFjZWhvbGRlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGRyb3BwYWJsZUlkLFxuICAgIHR5cGUsXG4gICAgbW9kZSxcbiAgICBkaXJlY3Rpb24sXG4gICAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcsXG4gICAgaXNEcm9wRGlzYWJsZWQsXG4gICAgaXNDb21iaW5lRW5hYmxlZCxcbiAgICBzbmFwc2hvdCxcbiAgICB1c2VDbG9uZSxcbiAgICB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCxcbiAgICBnZXRDb250YWluZXJGb3JDbG9uZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGdldERyb3BwYWJsZVJlZiA9IHVzZUNhbGxiYWNrKCgpID0+IGRyb3BwYWJsZVJlZi5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IHNldERyb3BwYWJsZVJlZiA9IHVzZUNhbGxiYWNrKCh2YWx1ZSA9IG51bGwpID0+IHtcbiAgICBkcm9wcGFibGVSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbXSk7XG4gIGNvbnN0IGdldFBsYWNlaG9sZGVyUmVmID0gdXNlQ2FsbGJhY2soKCkgPT4gcGxhY2Vob2xkZXJSZWYuY3VycmVudCwgW10pO1xuICBjb25zdCBzZXRQbGFjZWhvbGRlclJlZiA9IHVzZUNhbGxiYWNrKCh2YWx1ZSA9IG51bGwpID0+IHtcbiAgICBwbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFtdKTtcbiAgdXNlVmFsaWRhdGlvbih7XG4gICAgcHJvcHMsXG4gICAgZ2V0RHJvcHBhYmxlUmVmLFxuICAgIGdldFBsYWNlaG9sZGVyUmVmXG4gIH0pO1xuICBjb25zdCBvblBsYWNlaG9sZGVyVHJhbnNpdGlvbkVuZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoaXNNb3ZlbWVudEFsbG93ZWQoKSkge1xuICAgICAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwoe1xuICAgICAgICBtYXhTY3JvbGw6IGdldE1heFdpbmRvd1Njcm9sbCgpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtpc01vdmVtZW50QWxsb3dlZCwgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGxdKTtcbiAgdXNlRHJvcHBhYmxlUHVibGlzaGVyKHtcbiAgICBkcm9wcGFibGVJZCxcbiAgICB0eXBlLFxuICAgIG1vZGUsXG4gICAgZGlyZWN0aW9uLFxuICAgIGlzRHJvcERpc2FibGVkLFxuICAgIGlzQ29tYmluZUVuYWJsZWQsXG4gICAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcsXG4gICAgZ2V0RHJvcHBhYmxlUmVmXG4gIH0pO1xuICBjb25zdCBwbGFjZWhvbGRlciA9IHVzZU1lbW8oKCkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChBbmltYXRlSW5PdXQsIHtcbiAgICBvbjogcHJvcHMucGxhY2Vob2xkZXIsXG4gICAgc2hvdWxkQW5pbWF0ZTogcHJvcHMuc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyXG4gIH0sICh7XG4gICAgb25DbG9zZSxcbiAgICBkYXRhLFxuICAgIGFuaW1hdGVcbiAgfSkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChQbGFjZWhvbGRlciQxLCB7XG4gICAgcGxhY2Vob2xkZXI6IGRhdGEsXG4gICAgb25DbG9zZTogb25DbG9zZSxcbiAgICBpbm5lclJlZjogc2V0UGxhY2Vob2xkZXJSZWYsXG4gICAgYW5pbWF0ZTogYW5pbWF0ZSxcbiAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICBvblRyYW5zaXRpb25FbmQ6IG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kXG4gIH0pKSwgW2NvbnRleHRJZCwgb25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmQsIHByb3BzLnBsYWNlaG9sZGVyLCBwcm9wcy5zaG91bGRBbmltYXRlUGxhY2Vob2xkZXIsIHNldFBsYWNlaG9sZGVyUmVmXSk7XG4gIGNvbnN0IHByb3ZpZGVkID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlubmVyUmVmOiBzZXREcm9wcGFibGVSZWYsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgZHJvcHBhYmxlUHJvcHM6IHtcbiAgICAgICdkYXRhLXJmZC1kcm9wcGFibGUtaWQnOiBkcm9wcGFibGVJZCxcbiAgICAgICdkYXRhLXJmZC1kcm9wcGFibGUtY29udGV4dC1pZCc6IGNvbnRleHRJZFxuICAgIH1cbiAgfSksIFtjb250ZXh0SWQsIGRyb3BwYWJsZUlkLCBwbGFjZWhvbGRlciwgc2V0RHJvcHBhYmxlUmVmXSk7XG4gIGNvbnN0IGlzVXNpbmdDbG9uZUZvciA9IHVzZUNsb25lID8gdXNlQ2xvbmUuZHJhZ2dpbmcuZHJhZ2dhYmxlSWQgOiBudWxsO1xuICBjb25zdCBkcm9wcGFibGVDb250ZXh0ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGRyb3BwYWJsZUlkLFxuICAgIHR5cGUsXG4gICAgaXNVc2luZ0Nsb25lRm9yXG4gIH0pLCBbZHJvcHBhYmxlSWQsIGlzVXNpbmdDbG9uZUZvciwgdHlwZV0pO1xuICBmdW5jdGlvbiBnZXRDbG9uZSgpIHtcbiAgICBpZiAoIXVzZUNsb25lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZHJhZ2dpbmcsXG4gICAgICByZW5kZXJcbiAgICB9ID0gdXNlQ2xvbmU7XG4gICAgY29uc3Qgbm9kZSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpdmF0ZURyYWdnYWJsZSwge1xuICAgICAgZHJhZ2dhYmxlSWQ6IGRyYWdnaW5nLmRyYWdnYWJsZUlkLFxuICAgICAgaW5kZXg6IGRyYWdnaW5nLnNvdXJjZS5pbmRleCxcbiAgICAgIGlzQ2xvbmU6IHRydWUsXG4gICAgICBpc0VuYWJsZWQ6IHRydWUsXG4gICAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogZmFsc2UsXG4gICAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50czogdHJ1ZVxuICAgIH0sIChkcmFnZ2FibGVQcm92aWRlZCwgZHJhZ2dhYmxlU25hcHNob3QpID0+IHJlbmRlcihkcmFnZ2FibGVQcm92aWRlZCwgZHJhZ2dhYmxlU25hcHNob3QsIGRyYWdnaW5nKSk7XG4gICAgcmV0dXJuIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChub2RlLCBnZXRDb250YWluZXJGb3JDbG9uZSgpKTtcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wcGFibGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRyb3BwYWJsZUNvbnRleHRcbiAgfSwgY2hpbGRyZW4ocHJvdmlkZWQsIHNuYXBzaG90KSwgZ2V0Q2xvbmUoKSk7XG59O1xuXG5mdW5jdGlvbiBnZXRCb2R5KCkge1xuICAhZG9jdW1lbnQuYm9keSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2RvY3VtZW50LmJvZHkgaXMgbm90IHJlYWR5JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG59XG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIG1vZGU6ICdzdGFuZGFyZCcsXG4gIHR5cGU6ICdERUZBVUxUJyxcbiAgZGlyZWN0aW9uOiAndmVydGljYWwnLFxuICBpc0Ryb3BEaXNhYmxlZDogZmFsc2UsXG4gIGlzQ29tYmluZUVuYWJsZWQ6IGZhbHNlLFxuICBpZ25vcmVDb250YWluZXJDbGlwcGluZzogZmFsc2UsXG4gIHJlbmRlckNsb25lOiBudWxsLFxuICBnZXRDb250YWluZXJGb3JDbG9uZTogZ2V0Qm9keVxufTtcbmNvbnN0IGF0dGFjaERlZmF1bHRQcm9wc1RvT3duUHJvcHMgPSBvd25Qcm9wcyA9PiB7XG4gIGxldCBtZXJnZWRQcm9wcyA9IHtcbiAgICAuLi5vd25Qcm9wc1xuICB9O1xuICBsZXQgZGVmYXVsdFByb3BLZXk7XG4gIGZvciAoZGVmYXVsdFByb3BLZXkgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKG93blByb3BzW2RlZmF1bHRQcm9wS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtZXJnZWRQcm9wcyA9IHtcbiAgICAgICAgLi4ubWVyZ2VkUHJvcHMsXG4gICAgICAgIFtkZWZhdWx0UHJvcEtleV06IGRlZmF1bHRQcm9wc1tkZWZhdWx0UHJvcEtleV1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRQcm9wcztcbn07XG5jb25zdCBpc01hdGNoaW5nVHlwZSA9ICh0eXBlLCBjcml0aWNhbCkgPT4gdHlwZSA9PT0gY3JpdGljYWwuZHJvcHBhYmxlLnR5cGU7XG5jb25zdCBnZXREcmFnZ2FibGUgPSAoY3JpdGljYWwsIGRpbWVuc2lvbnMpID0+IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tjcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuY29uc3QgbWFrZU1hcFN0YXRlVG9Qcm9wcyA9ICgpID0+IHtcbiAgY29uc3QgaWRsZVdpdGhBbmltYXRpb24gPSB7XG4gICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiB0cnVlLFxuICAgIHNuYXBzaG90OiB7XG4gICAgICBpc0RyYWdnaW5nT3ZlcjogZmFsc2UsXG4gICAgICBkcmFnZ2luZ092ZXJXaXRoOiBudWxsLFxuICAgICAgZHJhZ2dpbmdGcm9tVGhpc1dpdGg6IG51bGwsXG4gICAgICBpc1VzaW5nUGxhY2Vob2xkZXI6IGZhbHNlXG4gICAgfSxcbiAgICB1c2VDbG9uZTogbnVsbFxuICB9O1xuICBjb25zdCBpZGxlV2l0aG91dEFuaW1hdGlvbiA9IHtcbiAgICAuLi5pZGxlV2l0aEFuaW1hdGlvbixcbiAgICBzaG91bGRBbmltYXRlUGxhY2Vob2xkZXI6IGZhbHNlXG4gIH07XG4gIGNvbnN0IGdldERyYWdnYWJsZVJ1YnJpYyA9IG1lbW9pemVPbmUoZGVzY3JpcHRvciA9PiAoe1xuICAgIGRyYWdnYWJsZUlkOiBkZXNjcmlwdG9yLmlkLFxuICAgIHR5cGU6IGRlc2NyaXB0b3IudHlwZSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIGluZGV4OiBkZXNjcmlwdG9yLmluZGV4LFxuICAgICAgZHJvcHBhYmxlSWQ6IGRlc2NyaXB0b3IuZHJvcHBhYmxlSWRcbiAgICB9XG4gIH0pKTtcbiAgY29uc3QgZ2V0TWFwUHJvcHMgPSBtZW1vaXplT25lKChpZCwgaXNFbmFibGVkLCBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLCBpc0RyYWdnaW5nT3ZlckZvckltcGFjdCwgZHJhZ2dpbmcsIHJlbmRlckNsb25lKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBkcmFnZ2luZy5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGlzSG9tZSA9IGRyYWdnaW5nLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQgPT09IGlkO1xuICAgIGlmIChpc0hvbWUpIHtcbiAgICAgIGNvbnN0IHVzZUNsb25lID0gcmVuZGVyQ2xvbmUgPyB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyQ2xvbmUsXG4gICAgICAgIGRyYWdnaW5nOiBnZXREcmFnZ2FibGVSdWJyaWMoZHJhZ2dpbmcuZGVzY3JpcHRvcilcbiAgICAgIH0gOiBudWxsO1xuICAgICAgY29uc3Qgc25hcHNob3QgPSB7XG4gICAgICAgIGlzRHJhZ2dpbmdPdmVyOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLFxuICAgICAgICBkcmFnZ2luZ092ZXJXaXRoOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyID8gZHJhZ2dhYmxlSWQgOiBudWxsLFxuICAgICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogZHJhZ2dhYmxlSWQsXG4gICAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBsYWNlaG9sZGVyOiBkcmFnZ2luZy5wbGFjZWhvbGRlcixcbiAgICAgICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiBmYWxzZSxcbiAgICAgICAgc25hcHNob3QsXG4gICAgICAgIHVzZUNsb25lXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWlzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzRHJhZ2dpbmdPdmVyRm9ySW1wYWN0KSB7XG4gICAgICByZXR1cm4gaWRsZVdpdGhBbmltYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHNuYXBzaG90ID0ge1xuICAgICAgaXNEcmFnZ2luZ092ZXI6IGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIsXG4gICAgICBkcmFnZ2luZ092ZXJXaXRoOiBkcmFnZ2FibGVJZCxcbiAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBudWxsLFxuICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcGxhY2Vob2xkZXI6IGRyYWdnaW5nLnBsYWNlaG9sZGVyLFxuICAgICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiB0cnVlLFxuICAgICAgc25hcHNob3QsXG4gICAgICB1c2VDbG9uZTogbnVsbFxuICAgIH07XG4gIH0pO1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IHtcbiAgICBjb25zdCBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMgPSBhdHRhY2hEZWZhdWx0UHJvcHNUb093blByb3BzKG93blByb3BzKTtcbiAgICBjb25zdCBpZCA9IG93blByb3BzV2l0aERlZmF1bHRQcm9wcy5kcm9wcGFibGVJZDtcbiAgICBjb25zdCB0eXBlID0gb3duUHJvcHNXaXRoRGVmYXVsdFByb3BzLnR5cGU7XG4gICAgY29uc3QgaXNFbmFibGVkID0gIW93blByb3BzV2l0aERlZmF1bHRQcm9wcy5pc0Ryb3BEaXNhYmxlZDtcbiAgICBjb25zdCByZW5kZXJDbG9uZSA9IG93blByb3BzV2l0aERlZmF1bHRQcm9wcy5yZW5kZXJDbG9uZTtcbiAgICBpZiAoaXNEcmFnZ2luZyhzdGF0ZSkpIHtcbiAgICAgIGNvbnN0IGNyaXRpY2FsID0gc3RhdGUuY3JpdGljYWw7XG4gICAgICBpZiAoIWlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNyaXRpY2FsKSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2luZyA9IGdldERyYWdnYWJsZShjcml0aWNhbCwgc3RhdGUuZGltZW5zaW9ucyk7XG4gICAgICBjb25zdCBpc0RyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCkgPT09IGlkO1xuICAgICAgcmV0dXJuIGdldE1hcFByb3BzKGlkLCBpc0VuYWJsZWQsIGlzRHJhZ2dpbmdPdmVyLCBpc0RyYWdnaW5nT3ZlciwgZHJhZ2dpbmcsIHJlbmRlckNsb25lKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoIWlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNvbXBsZXRlZC5jcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dpbmcgPSBnZXREcmFnZ2FibGUoY29tcGxldGVkLmNyaXRpY2FsLCBzdGF0ZS5kaW1lbnNpb25zKTtcbiAgICAgIHJldHVybiBnZXRNYXBQcm9wcyhpZCwgaXNFbmFibGVkLCB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQoY29tcGxldGVkLnJlc3VsdCkgPT09IGlkLCB3aGF0SXNEcmFnZ2VkT3Zlcihjb21wbGV0ZWQuaW1wYWN0KSA9PT0gaWQsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnICYmIHN0YXRlLmNvbXBsZXRlZCAmJiAhc3RhdGUuc2hvdWxkRmx1c2gpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcbiAgICAgIGlmICghaXNNYXRjaGluZ1R5cGUodHlwZSwgY29tcGxldGVkLmNyaXRpY2FsKSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCB3YXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoY29tcGxldGVkLmltcGFjdCkgPT09IGlkO1xuICAgICAgY29uc3Qgd2FzQ29tYmluaW5nID0gQm9vbGVhbihjb21wbGV0ZWQuaW1wYWN0LmF0ICYmIGNvbXBsZXRlZC5pbXBhY3QuYXQudHlwZSA9PT0gJ0NPTUJJTkUnKTtcbiAgICAgIGNvbnN0IGlzSG9tZSA9IGNvbXBsZXRlZC5jcml0aWNhbC5kcm9wcGFibGUuaWQgPT09IGlkO1xuICAgICAgaWYgKHdhc092ZXIpIHtcbiAgICAgICAgcmV0dXJuIHdhc0NvbWJpbmluZyA/IGlkbGVXaXRoQW5pbWF0aW9uIDogaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG4gICAgICBpZiAoaXNIb21lKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aEFuaW1hdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICB9O1xuICByZXR1cm4gc2VsZWN0b3I7XG59O1xuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0ge1xuICB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbDogdXBkYXRlVmlld3BvcnRNYXhTY3JvbGxcbn07XG5jb25zdCBDb25uZWN0ZWREcm9wcGFibGUgPSBjb25uZWN0KG1ha2VNYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uYXR0YWNoRGVmYXVsdFByb3BzVG9Pd25Qcm9wcyhvd25Qcm9wcyksXG4gICAgLi4uc3RhdGVQcm9wcyxcbiAgICAuLi5kaXNwYXRjaFByb3BzXG4gIH07XG59LCB7XG4gIGNvbnRleHQ6IFN0b3JlQ29udGV4dCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsOiBpc1N0cmljdEVxdWFsXG59KShEcm9wcGFibGUpO1xuXG5leHBvcnQgeyBEcmFnRHJvcENvbnRleHQsIFB1YmxpY0RyYWdnYWJsZSBhcyBEcmFnZ2FibGUsIENvbm5lY3RlZERyb3BwYWJsZSBhcyBEcm9wcGFibGUsIHVzZUtleWJvYXJkU2Vuc29yLCB1c2VNb3VzZVNlbnNvciwgdXNlVG91Y2hTZW5zb3IgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlQ29udGV4dCIsIlJlYWN0RE9NIiwiZmx1c2hTeW5jIiwiY3JlYXRlU3RvcmUiLCJjcmVhdGVTdG9yZSQxIiwiY29tcG9zZSIsImFwcGx5TWlkZGxld2FyZSIsImJpbmRBY3Rpb25DcmVhdG9ycyIsIlByb3ZpZGVyIiwiY29ubmVjdCIsImdldFJlY3QiLCJleHBhbmQiLCJvZmZzZXQiLCJ3aXRoU2Nyb2xsIiwiY2FsY3VsYXRlQm94IiwiZ2V0Qm94IiwiY3JlYXRlQm94IiwicmFmU2NoZCIsIl9leHRlbmRzIiwiaXNQcm9kdWN0aW9uJDEiLCJwcm9jZXNzIiwic3BhY2VzQW5kVGFicyIsImxpbmVTdGFydFdpdGhTcGFjZXMiLCJjbGVhbiQyIiwidmFsdWUiLCJyZXBsYWNlIiwidHJpbSIsImdldERldk1lc3NhZ2UiLCJtZXNzYWdlIiwiZ2V0Rm9ybWF0dGVkTWVzc2FnZSIsImlzRGlzYWJsZWRGbGFnIiwibG9nIiwidHlwZSIsIndpbmRvdyIsImNvbnNvbGUiLCJ3YXJuaW5nIiwiYmluZCIsImVycm9yIiwibm9vcCQyIiwiZ2V0T3B0aW9ucyIsInNoYXJlZCIsImZyb21CaW5kaW5nIiwiYmluZEV2ZW50cyIsImVsIiwiYmluZGluZ3MiLCJzaGFyZWRPcHRpb25zIiwidW5iaW5kaW5ncyIsIm1hcCIsImJpbmRpbmciLCJvcHRpb25zIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImZuIiwidW5iaW5kIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVuYmluZEFsbCIsImZvckVhY2giLCJpc1Byb2R1Y3Rpb24iLCJwcmVmaXgkMSIsIlJiZEludmFyaWFudCIsIkVycm9yIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJFcnJvckJvdW5kYXJ5IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJhcmdzIiwiY2FsbGJhY2tzIiwib25XaW5kb3dFcnJvciIsImV2ZW50IiwiZ2V0Q2FsbGJhY2tzIiwiaXNEcmFnZ2luZyIsInRyeUFib3J0IiwiZXJyIiwicHJldmVudERlZmF1bHQiLCJzZXRDYWxsYmFja3MiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudERpZENhdGNoIiwic2V0U3RhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbmRlciIsInByb3BzIiwiY2hpbGRyZW4iLCJkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMiLCJwb3NpdGlvbiIsImluZGV4Iiwib25EcmFnU3RhcnQiLCJzdGFydCIsInNvdXJjZSIsIndpdGhMb2NhdGlvbiIsImRlc3RpbmF0aW9uIiwiaXNJbkhvbWVMaXN0IiwiZHJvcHBhYmxlSWQiLCJzdGFydFBvc2l0aW9uIiwiZW5kUG9zaXRpb24iLCJ3aXRoQ29tYmluZSIsImlkIiwiY29tYmluZSIsImluSG9tZUxpc3QiLCJkcmFnZ2FibGVJZCIsIm9uRHJhZ1VwZGF0ZSIsInVwZGF0ZSIsImxvY2F0aW9uIiwicmV0dXJuZWRUb1N0YXJ0Iiwib25EcmFnRW5kIiwicmVzdWx0IiwicmVhc29uIiwicHJlc2V0IiwiaXNFcXVhbCQyIiwiZmlyc3QiLCJzZWNvbmQiLCJOdW1iZXIiLCJpc05hTiIsImFyZUlucHV0c0VxdWFsIiwibmV3SW5wdXRzIiwibGFzdElucHV0cyIsImxlbmd0aCIsImkiLCJ1c2VNZW1vIiwiZ2V0UmVzdWx0IiwiaW5wdXRzIiwiaW5pdGlhbCIsImlzRmlyc3RSdW4iLCJjb21taXR0ZWQiLCJ1c2VDYWNoZSIsImN1cnJlbnQiLCJCb29sZWFuIiwiY2FjaGUiLCJ1c2VDYWxsYmFjayIsImNhbGxiYWNrIiwib3JpZ2luIiwieCIsInkiLCJhZGQiLCJwb2ludDEiLCJwb2ludDIiLCJzdWJ0cmFjdCIsImlzRXF1YWwkMSIsIm5lZ2F0ZSIsInBvaW50IiwicGF0Y2giLCJsaW5lIiwib3RoZXJWYWx1ZSIsImRpc3RhbmNlIiwiTWF0aCIsInNxcnQiLCJjbG9zZXN0JDEiLCJ0YXJnZXQiLCJwb2ludHMiLCJtaW4iLCJhcHBseSIsImV4ZWN1dGVDbGlwIiwiZnJhbWUiLCJzdWJqZWN0IiwidG9wIiwibWF4IiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJvZmZzZXRCeVBvc2l0aW9uIiwic3BhY2luZyIsImdldENvcm5lcnMiLCJub1NwYWNpbmciLCJzY3JvbGwkMSIsInNjcm9sbCIsImRpZmYiLCJkaXNwbGFjZW1lbnQiLCJpbmNyZWFzZSIsImF4aXMiLCJ3aXRoUGxhY2Vob2xkZXIiLCJpbmNyZWFzZWRCeSIsImVuZCIsImNsaXAiLCJzaG91bGRDbGlwU3ViamVjdCIsInBhZ2VNYXJnaW5Cb3giLCJnZXRTdWJqZWN0IiwicGFnZSIsInNjcm9sbGVkIiwibWFyZ2luQm94IiwiaW5jcmVhc2VkIiwiY2xpcHBlZCIsImFjdGl2ZSIsInNjcm9sbERyb3BwYWJsZSIsImRyb3BwYWJsZSIsIm5ld1Njcm9sbCIsInNjcm9sbGFibGUiLCJzY3JvbGxEaWZmIiwic2Nyb2xsRGlzcGxhY2VtZW50IiwibWVtb2l6ZU9uZSIsInJlc3VsdEZuIiwiaXNFcXVhbCIsIm1lbW9pemVkIiwibmV3QXJncyIsImxhc3RUaGlzIiwibGFzdEFyZ3MiLCJsYXN0UmVzdWx0IiwiY2xlYXIiLCJ0b0Ryb3BwYWJsZU1hcCIsImRyb3BwYWJsZXMiLCJyZWR1Y2UiLCJwcmV2aW91cyIsImRlc2NyaXB0b3IiLCJ0b0RyYWdnYWJsZU1hcCIsImRyYWdnYWJsZXMiLCJ0b0Ryb3BwYWJsZUxpc3QiLCJPYmplY3QiLCJ2YWx1ZXMiLCJ0b0RyYWdnYWJsZUxpc3QiLCJnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlIiwiZmlsdGVyIiwiZHJhZ2dhYmxlIiwic29ydCIsImEiLCJiIiwidHJ5R2V0RGVzdGluYXRpb24iLCJpbXBhY3QiLCJhdCIsInRyeUdldENvbWJpbmUiLCJyZW1vdmVEcmFnZ2FibGVGcm9tTGlzdCIsInJlbW92ZSIsImxpc3QiLCJpdGVtIiwibW92ZVRvTmV4dENvbWJpbmUiLCJpc01vdmluZ0ZvcndhcmQiLCJpbnNpZGVEZXN0aW5hdGlvbiIsInByZXZpb3VzSW1wYWN0IiwiaXNDb21iaW5lRW5hYmxlZCIsImdldEltcGFjdCIsImFsbCIsImRpc3BsYWNlZCIsImNsb3Nlc3RJZCIsIndpdGhvdXREcmFnZ2FibGUiLCJsYXN0IiwiaW5kZXhPZkNsb3Nlc3QiLCJmaW5kSW5kZXgiLCJkIiwicHJvcG9zZWRJbmRleCIsImJlZm9yZSIsImlzSG9tZU9mIiwibm9EaXNwbGFjZWRCeSIsImVtcHR5R3JvdXBzIiwiaW52aXNpYmxlIiwidmlzaWJsZSIsIm5vSW1wYWN0IiwiZGlzcGxhY2VkQnkiLCJpc1dpdGhpbiIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lIiwiaXNXaXRoaW5WZXJ0aWNhbCIsImlzV2l0aGluSG9yaXpvbnRhbCIsImlzQ29udGFpbmVkIiwiaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSIsImlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSIsImlzUGFydGlhbGx5Q29udGFpbmVkIiwiaXNCaWdnZXJWZXJ0aWNhbGx5IiwiaXNCaWdnZXJIb3Jpem9udGFsbHkiLCJpc1RhcmdldEJpZ2dlclRoYW5GcmFtZSIsImlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzIiwiaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSIsInZlcnRpY2FsIiwiZGlyZWN0aW9uIiwiY3Jvc3NBeGlzTGluZSIsInNpemUiLCJjcm9zc0F4aXNTdGFydCIsImNyb3NzQXhpc0VuZCIsImNyb3NzQXhpc1NpemUiLCJob3Jpem9udGFsIiwiaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZU9uQXhpcyIsImdldERyb3BwYWJsZURpc3BsYWNlZCIsImlzVmlzaWJsZUluRHJvcHBhYmxlIiwiaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4iLCJpc1Zpc2libGVJblZpZXdwb3J0Iiwidmlld3BvcnQiLCJpc1Zpc2libGUkMSIsInRvQmVEaXNwbGFjZWQiLCJ3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50IiwiZGlzcGxhY2VkVGFyZ2V0IiwiaXNQYXJ0aWFsbHlWaXNpYmxlIiwiaXNUb3RhbGx5VmlzaWJsZSIsImlzVG90YWxseVZpc2libGVPbkF4aXMiLCJnZXRTaG91bGRBbmltYXRlIiwiZm9yY2VTaG91bGRBbmltYXRlIiwic2hvdWxkQW5pbWF0ZSIsImdldFRhcmdldCIsImV4cGFuZEJ5IiwiZ2V0RGlzcGxhY2VtZW50R3JvdXBzIiwiYWZ0ZXJEcmFnZ2luZyIsImdyb3VwcyIsInB1c2giLCJpc1Zpc2libGUiLCJnZXRJbmRleE9mTGFzdEl0ZW0iLCJpbmRleE9mTGFzdEl0ZW0iLCJnb0F0RW5kIiwibmV3SW5kZXgiLCJjYWxjdWxhdGVSZW9yZGVySW1wYWN0IiwibWF0Y2giLCJmaW5kIiwid2l0aG91dERyYWdnaW5nIiwic2xpY2VGcm9tIiwiaW5kZXhPZiIsImltcGFjdGVkIiwic2xpY2UiLCJkaWRTdGFydEFmdGVyQ3JpdGljYWwiLCJhZnRlckNyaXRpY2FsIiwiZWZmZWN0ZWQiLCJmcm9tQ29tYmluZSIsImNvbWJpbmVJZCIsImNvbWJpbmVXaXRoIiwiY29tYmluZVdpdGhJbmRleCIsImRpZENvbWJpbmVXaXRoU3RhcnRBZnRlckNyaXRpY2FsIiwiZnJvbVJlb3JkZXIiLCJjdXJyZW50SW5kZXgiLCJmaXJzdEluZGV4IiwibGFzdEluZGV4IiwibW92ZVRvTmV4dEluZGV4Iiwid2FzQXQiLCJnZXRDb21iaW5lZEl0ZW1EaXNwbGFjZW1lbnQiLCJpc0Rpc3BsYWNlZCIsIndoZW5Db21iaW5pbmciLCJjZW50ZXIiLCJib3JkZXJCb3giLCJkaXNwbGFjZUJ5IiwiZGlzdGFuY2VGcm9tU3RhcnRUb0JvcmRlckJveENlbnRlciIsImJveCIsIm1hcmdpbiIsImRpc3RhbmNlRnJvbUVuZFRvQm9yZGVyQm94Q2VudGVyIiwiZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyIiwiaXNNb3ZpbmciLCJnb0FmdGVyIiwibW92ZVJlbGF0aXZlVG8iLCJnb0JlZm9yZSIsImdvSW50b1N0YXJ0IiwibW92ZUludG8iLCJjb250ZW50Qm94Iiwid2hlblJlb3JkZXJpbmciLCJkcmFnZ2FibGVQYWdlIiwiY2xvc2VzdEFmdGVyIiwiY2xvc2VzdCIsIndpdGhEaXNwbGFjZW1lbnQiLCJnZXRSZXN1bHRXaXRob3V0RHJvcHBhYmxlRGlzcGxhY2VtZW50Iiwib3JpZ2luYWwiLCJnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCIsIndpdGhvdXREaXNwbGFjZW1lbnQiLCJzY3JvbGxWaWV3cG9ydCIsInVwZGF0ZWQiLCJnZXREcmFnZ2FibGVzJDEiLCJpZHMiLCJ0cnlHZXRWaXNpYmxlIiwic3BlY3VsYXRpdmVseUluY3JlYXNlIiwibWF4U2Nyb2xsQ2hhbmdlIiwic2Nyb2xsZWRWaWV3cG9ydCIsInNjcm9sbGVkRHJvcHBhYmxlIiwid2l0aFZpZXdwb3J0U2Nyb2xsIiwid2l0aERyb3BwYWJsZVNjcm9sbCIsIm5ld0ltcGFjdCIsIndpdGhWaWV3cG9ydERpc3BsYWNlbWVudCIsImdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyIiwicGFnZUJvcmRlckJveENlbnRlciIsIndpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlIiwiY2xpZW50IiwiaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24iLCJuZXdQYWdlQm9yZGVyQm94Q2VudGVyIiwib25seU9uTWFpbkF4aXMiLCJjaGFuZ2VOZWVkZWQiLCJzaGlmdGVkIiwibW92ZVRvTmV4dFBsYWNlIiwicHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyIiwicHJldmlvdXNDbGllbnRTZWxlY3Rpb24iLCJpc0VuYWJsZWQiLCJpc1Zpc2libGVJbk5ld0xvY2F0aW9uIiwiY2xpZW50U2VsZWN0aW9uIiwic2Nyb2xsSnVtcFJlcXVlc3QiLCJjYXV0aW91cyIsImdldEtub3duQWN0aXZlIiwicmVjdCIsImdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUiLCJpc0JldHdlZW5Tb3VyY2VDbGlwcGVkIiwiY2FuZGlkYXRlcyIsImFjdGl2ZU9mVGFyZ2V0IiwiaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkIiwiYXJyYXkiLCJjb250YWlucyIsImlzV2l0aGluRHJvcHBhYmxlIiwiZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIiLCJnZXRDdXJyZW50UGFnZUJvcmRlckJveCIsImdldENsb3Nlc3REcmFnZ2FibGUiLCJzb3J0ZWQiLCJkaXN0YW5jZVRvQSIsImRpc3RhbmNlVG9CIiwiZ2V0RGlzcGxhY2VkQnkiLCJnZXRSZXF1aXJlZEdyb3d0aEZvclBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJTaXplIiwibW9kZSIsImF2YWlsYWJsZVNwYWNlIiwiaW5zaWRlRHJvcHBhYmxlIiwic3BhY2VVc2VkIiwic3VtIiwiZGltZW5zaW9uIiwicmVxdWlyZWRTcGFjZSIsIm5lZWRzVG9Hcm93QnkiLCJ3aXRoTWF4U2Nyb2xsIiwiYWRkUGxhY2Vob2xkZXIiLCJyZXF1aXJlZEdyb3d0aCIsImFkZGVkIiwib2xkRnJhbWVNYXhTY3JvbGwiLCJtYXhTY3JvbGwiLCJuZXdGcmFtZSIsInJlbW92ZVBsYWNlaG9sZGVyIiwib2xkTWF4U2Nyb2xsIiwibW92ZVRvTmV3RHJvcHBhYmxlIiwicHJvcG9zZWQiLCJwcm9wb3NlZFBhZ2VCb3JkZXJCb3hDZW50ZXIiLCJpc0dvaW5nQmVmb3JlVGFyZ2V0IiwicmVsYXRpdmVUbyIsIm1vdmVDcm9zc0F4aXMiLCJpc092ZXIiLCJ3aGF0SXNEcmFnZ2VkT3ZlciIsImdldERyb3BwYWJsZU92ZXIkMSIsIm1vdmVJbkRpcmVjdGlvbiIsInN0YXRlIiwiaXNBY3R1YWxseU92ZXIiLCJkaW1lbnNpb25zIiwiaXNNYWluQXhpc01vdmVtZW50QWxsb3dlZCIsImhvbWUiLCJjcml0aWNhbCIsImlzTW92aW5nT25NYWluQXhpcyIsImJvcmRlckJveENlbnRlciIsInNlbGVjdGlvbiIsImlzTW92ZW1lbnRBbGxvd2VkIiwicGhhc2UiLCJpc1Bvc2l0aW9uSW5GcmFtZSIsInJ1biIsImdldEhhc092ZXJsYXAiLCJnZXRGdXJ0aGVzdEF3YXkiLCJwYWdlQm9yZGVyQm94Iiwic3RhcnRDZW50ZXIiLCJjYW5kaWRhdGUiLCJnZXREcm9wcGFibGVPdmVyIiwiY2hpbGRDZW50ZXIiLCJpc1N0YXJ0Q29udGFpbmVkIiwiaXNFbmRDb250YWluZWQiLCJvZmZzZXRSZWN0QnlQb3NpdGlvbiIsImFyZWEiLCJnZXRJc0Rpc3BsYWNlZCIsImF0SW5kZXgiLCJnZXRSZW9yZGVySW1wYWN0IiwicGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGwiLCJ0YXJnZXRSZWN0IiwidGFyZ2V0U3RhcnQiLCJ0YXJnZXRFbmQiLCJjaGlsZCIsImRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxIiwiY29tYmluZVRocmVzaG9sZERpdmlzb3IiLCJnZXRDb21iaW5lSW1wYWN0IiwiY2hpbGRSZWN0IiwiY2hpbGRTaXplIiwidGhyZXNob2xkIiwiZ2V0RHJhZ0ltcGFjdCIsInBhZ2VPZmZzZXQiLCJkZXN0aW5hdGlvbklkIiwicGF0Y2hEcm9wcGFibGVNYXAiLCJjbGVhclVudXNlZFBsYWNlaG9sZGVyIiwibm93IiwibGFzdERyb3BwYWJsZSIsInJlY29tcHV0ZVBsYWNlaG9sZGVycyIsImNsZWFuZWQiLCJwYXRjaGVkIiwiZm9yY2VkQ2xpZW50U2VsZWN0aW9uIiwiZm9yY2VkRGltZW5zaW9ucyIsImZvcmNlZFZpZXdwb3J0IiwiZm9yY2VkSW1wYWN0Iiwid2l0aFVwZGF0ZWRQbGFjZWhvbGRlcnMiLCJnZXREcmFnZ2FibGVzIiwicmVjb21wdXRlIiwiZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyIiwicmVmcmVzaFNuYXAiLCJtb3ZlbWVudE1vZGUiLCJuZWVkc1Zpc2liaWxpdHlDaGVjayIsImdldEhvbWVMb2NhdGlvbiIsImdldExpZnRFZmZlY3QiLCJpbnNpZGVIb21lIiwicmF3SW5kZXgiLCJpblZpcnR1YWxMaXN0IiwicGF0Y2hEaW1lbnNpb25NYXAiLCJrZXkiLCJmaW5pc2giLCJvZmZzZXREcmFnZ2FibGUiLCJvZmZzZXQkMSIsImluaXRpYWxXaW5kb3dTY3JvbGwiLCJtb3ZlZCIsInBsYWNlaG9sZGVyIiwiZ2V0RnJhbWUiLCJhZGp1c3RBZGRpdGlvbnNGb3JTY3JvbGxDaGFuZ2VzIiwiYWRkaXRpb25zIiwidXBkYXRlZERyb3BwYWJsZXMiLCJ3aW5kb3dTY3JvbGxDaGFuZ2UiLCJtb2RpZmllZCIsImRyb3BwYWJsZVNjcm9sbENoYW5nZSIsInRvdGFsQ2hhbmdlIiwicHVibGlzaFdoaWxlRHJhZ2dpbmdJblZpcnR1YWwiLCJwdWJsaXNoZWQiLCJ3aXRoU2Nyb2xsQ2hhbmdlIiwiZXhpc3RpbmciLCJ1cGRhdGVkQWRkaXRpb25zIiwicmVtb3ZhbHMiLCJ3YXNPdmVySWQiLCJ3YXNPdmVyIiwib25MaWZ0SW1wYWN0IiwiZHJhZ2dpbmdTdGF0ZSIsImRyb3BQZW5kaW5nIiwiaXNXYWl0aW5nIiwiaXNTbmFwcGluZyIsInBvc3REcm9wcGFibGVDaGFuZ2UiLCJpc0VuYWJsZWRDaGFuZ2luZyIsInJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0IiwiaWRsZSQyIiwiY29tcGxldGVkIiwic2hvdWxkRmx1c2giLCJyZWR1Y2VyIiwiYWN0aW9uIiwicGF5bG9hZCIsImlzV2luZG93U2Nyb2xsQWxsb3dlZCIsImV2ZXJ5IiwiaXNGaXhlZE9uUGFnZSIsIlN0cmluZyIsIm5ld1N0YXRlIiwiZHJvcER1cmF0aW9uIiwibmV3SG9tZUNsaWVudE9mZnNldCIsImd1YXJkIiwicHJlZGljYXRlIiwiYmVmb3JlSW5pdGlhbENhcHR1cmUiLCJsaWZ0JDEiLCJpbml0aWFsUHVibGlzaCIsInB1Ymxpc2hXaGlsZURyYWdnaW5nIiwiY29sbGVjdGlvblN0YXJ0aW5nIiwidXBkYXRlRHJvcHBhYmxlU2Nyb2xsIiwidXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkIiwidXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCIsIm1vdmUiLCJtb3ZlQnlXaW5kb3dTY3JvbGwiLCJ1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCIsIm1vdmVVcCIsIm1vdmVEb3duIiwibW92ZVJpZ2h0IiwibW92ZUxlZnQiLCJmbHVzaCIsImFuaW1hdGVEcm9wIiwiY29tcGxldGVEcm9wIiwiZHJvcCIsImRyb3BBbmltYXRpb25GaW5pc2hlZCIsImNoZWNrSW5kZXhlcyIsImluZGV4ZXMiLCJlcnJvcnMiLCJrZXlzIiwiZm9ybWF0dGVkIiwiaGFzRXJyb3IiLCJqb2luIiwidmFsaWRhdGVEaW1lbnNpb25zIiwibGlmdCIsIm1hcnNoYWwiLCJnZXRTdGF0ZSIsImRpc3BhdGNoIiwibmV4dCIsInNjcm9sbE9wdGlvbnMiLCJzaG91bGRQdWJsaXNoSW1tZWRpYXRlbHkiLCJyZXF1ZXN0Iiwic3RhcnRQdWJsaXNoaW5nIiwic3R5bGUiLCJkcmFnZ2luZyIsImRyb3BwaW5nIiwicmVzdGluZyIsImN1cnZlcyIsIm91dE9mVGhlV2F5Iiwib3BhY2l0eSIsImNvbWJpbmluZyIsInNjYWxlIiwidGltaW5ncyIsIm1pbkRyb3BUaW1lIiwibWF4RHJvcFRpbWUiLCJvdXRPZlRoZVdheVRpbWluZyIsInRyYW5zaXRpb25zIiwiZmx1aWQiLCJzbmFwIiwiZHVyYXRpb24iLCJ0aW1pbmciLCJtb3ZlVG8iLCJ1bmRlZmluZWQiLCJ0cmFuc2Zvcm1zIiwiaXNDb21iaW5pbmciLCJ0cmFuc2xhdGUiLCJkcm9wVGltZVJhbmdlIiwibWF4RHJvcFRpbWVBdERpc3RhbmNlIiwiY2FuY2VsRHJvcE1vZGlmaWVyIiwiZ2V0RHJvcER1cmF0aW9uIiwiZGlzdGFuY2UkMSIsInBlcmNlbnRhZ2UiLCJ3aXRoRHVyYXRpb24iLCJ0b0ZpeGVkIiwiZ2V0TmV3SG9tZUNsaWVudE9mZnNldCIsIm5ld0NsaWVudENlbnRlciIsImdldERyb3BJbXBhY3QiLCJsYXN0SW1wYWN0IiwicmVjb21wdXRlZEhvbWVJbXBhY3QiLCJkaWREcm9wSW5zaWRlRHJvcHBhYmxlIiwid2l0aG91dE1vdmVtZW50IiwiZHJvcE1pZGRsZXdhcmUiLCJpc1dhaXRpbmdGb3JEcm9wIiwiaXNBbmltYXRpb25SZXF1aXJlZCIsImdldFdpbmRvd1Njcm9sbCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dTY3JvbGxCaW5kaW5nIiwicGFzc2l2ZSIsImNhcHR1cmUiLCJkb2N1bWVudCIsImdldFNjcm9sbExpc3RlbmVyIiwib25XaW5kb3dTY3JvbGwiLCJ1cGRhdGVTY3JvbGwiLCJzY2hlZHVsZWQiLCJpc0FjdGl2ZSIsInN0b3AiLCJjYW5jZWwiLCJzaG91bGRTdG9wJDEiLCJzY3JvbGxMaXN0ZW5lciIsInN0b3JlIiwibGlzdGVuZXIiLCJnZXRFeHBpcmluZ0Fubm91bmNlIiwiYW5ub3VuY2UiLCJ3YXNDYWxsZWQiLCJpc0V4cGlyZWQiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZ2V0QXN5bmNNYXJzaGFsIiwiZW50cmllcyIsImV4ZWN1dGUiLCJ0aW1lcklkIiwiZW50cnkiLCJzcGxpY2UiLCJzaGFsbG93IiwiYXJlTG9jYXRpb25zRXF1YWwiLCJpc0NvbWJpbmVFcXVhbCIsImlzQ3JpdGljYWxFcXVhbCIsImlzRHJhZ2dhYmxlRXF1YWwiLCJpc0Ryb3BwYWJsZUVxdWFsIiwid2l0aFRpbWluZ3MiLCJnZXREcmFnU3RhcnQiLCJyZXNwb25kZXIiLCJkYXRhIiwiZ2V0RGVmYXVsdE1lc3NhZ2UiLCJ3aWxsRXhwaXJlIiwicHJvdmlkZWQiLCJnZXRQdWJsaXNoZXIiLCJnZXRSZXNwb25kZXJzIiwiYXN5bmNNYXJzaGFsIiwiYmVmb3JlQ2FwdHVyZSIsIm9uQmVmb3JlQ2FwdHVyZSIsImJlZm9yZVN0YXJ0Iiwib25CZWZvcmVEcmFnU3RhcnQiLCJsYXN0Q3JpdGljYWwiLCJsYXN0TG9jYXRpb24iLCJsYXN0Q29tYmluZSIsImhhc0NyaXRpY2FsQ2hhbmdlZCIsImhhc0xvY2F0aW9uQ2hhbmdlZCIsImhhc0dyb3VwaW5nQ2hhbmdlZCIsImFib3J0IiwicmVzcG9uZGVycyIsInB1Ymxpc2hlciIsImRyb3BBbmltYXRpb25GaW5pc2hNaWRkbGV3YXJlIiwiZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGxNaWRkbGV3YXJlIiwiZnJhbWVJZCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwib25jZSIsImZsdXNoRHJvcEFuaW1hdGlvbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImRpbWVuc2lvbk1hcnNoYWxTdG9wcGVyIiwic3RvcFB1Ymxpc2hpbmciLCJmb2N1cyIsImlzV2F0Y2hpbmciLCJ0cnlSZWNvcmRGb2N1cyIsInRyeVJlc3RvcmVGb2N1c1JlY29yZGVkIiwidHJ5U2hpZnRSZWNvcmQiLCJzaG91bGRTdG9wIiwiYXV0b1Njcm9sbCIsImF1dG9TY3JvbGxlciIsInBlbmRpbmdEcm9wIiwicG9zdEFjdGlvblN0YXRlIiwiY29tcG9zZUVuaGFuY2VycyIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyIsIm5hbWUiLCJkaW1lbnNpb25NYXJzaGFsIiwiZm9jdXNNYXJzaGFsIiwic3R5bGVNYXJzaGFsIiwiY2xlYW4kMSIsImNyZWF0ZVB1Ymxpc2hlciIsInJlZ2lzdHJ5Iiwic3RhZ2luZyIsImNvbGxlY3QiLCJnZXRCeUlkIiwiZ2V0RGltZW5zaW9uIiwiZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZyIsInB1Ymxpc2giLCJnZXRNYXhTY3JvbGwiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxXaWR0aCIsImFkanVzdGVkTWF4U2Nyb2xsIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZG9jIiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0TWF4V2luZG93U2Nyb2xsIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJnZXRWaWV3cG9ydCIsImdldEluaXRpYWxQdWJsaXNoIiwid2luZG93U2Nyb2xsIiwiZ2V0QWxsQnlUeXBlIiwiZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwiLCJzaG91bGRQdWJsaXNoVXBkYXRlIiwiY3JlYXRlRGltZW5zaW9uTWFyc2hhbCIsImNvbGxlY3Rpb24iLCJleGlzdHMiLCJjaGFuZ2UiLCJkcmFnU3RvcHBlZCIsInVuc3Vic2NyaWJlIiwic3Vic2NyaWJlciIsInN1YnNjcmliZSIsImNhblN0YXJ0RHJhZyIsInNjcm9sbFdpbmRvdyIsInNjcm9sbEJ5IiwiZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZXMiLCJnZXRTY3JvbGxhYmxlRHJvcHBhYmxlT3ZlciIsIm1heWJlIiwiZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUiLCJkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucyIsInN0YXJ0RnJvbVBlcmNlbnRhZ2UiLCJtYXhTY3JvbGxBdFBlcmNlbnRhZ2UiLCJtYXhQaXhlbFNjcm9sbCIsImVhc2UiLCJkdXJhdGlvbkRhbXBlbmluZyIsInN0b3BEYW1wZW5pbmdBdCIsImFjY2VsZXJhdGVBdCIsImRpc2FibGVkIiwiZ2V0RGlzdGFuY2VUaHJlc2hvbGRzIiwiY29udGFpbmVyIiwiZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyIsImF1dG9TY3JvbGxlck9wdGlvbnMiLCJzdGFydFNjcm9sbGluZ0Zyb20iLCJtYXhTY3JvbGxWYWx1ZUF0IiwidGhyZXNob2xkcyIsImdldFBlcmNlbnRhZ2UiLCJzdGFydE9mUmFuZ2UiLCJlbmRPZlJhbmdlIiwicmFuZ2UiLCJjdXJyZW50SW5SYW5nZSIsIm1pblNjcm9sbCIsImdldFZhbHVlRnJvbURpc3RhbmNlIiwiZGlzdGFuY2VUb0VkZ2UiLCJwZXJjZW50YWdlRnJvbU1heFNjcm9sbFZhbHVlQXQiLCJwZXJjZW50YWdlRnJvbVN0YXJ0U2Nyb2xsaW5nRnJvbSIsImNlaWwiLCJkYW1wZW5WYWx1ZUJ5VGltZSIsInByb3Bvc2VkU2Nyb2xsIiwiZHJhZ1N0YXJ0VGltZSIsInN0b3BBdCIsIkRhdGUiLCJydW5UaW1lIiwiYmV0d2VlbkFjY2VsZXJhdGVBdEFuZFN0b3BBdFBlcmNlbnRhZ2UiLCJnZXRWYWx1ZSIsInNob3VsZFVzZVRpbWVEYW1wZW5pbmciLCJnZXRTY3JvbGxPbkF4aXMiLCJkaXN0YW5jZVRvRWRnZXMiLCJpc0Nsb3NlclRvRW5kIiwiYWRqdXN0Rm9yU2l6ZUxpbWl0cyIsImlzVG9vQmlnVmVydGljYWxseSIsImlzVG9vQmlnSG9yaXpvbnRhbGx5IiwiY2xlYW4iLCJnZXRTY3JvbGwkMSIsInJlcXVpcmVkIiwibGltaXRlZCIsInNtYWxsZXN0U2lnbmVkIiwiZ2V0T3ZlcmxhcCIsImdldFJlbWFpbmRlciIsInRhcmdldFNjcm9sbCIsIm92ZXJsYXAiLCJjYW5QYXJ0aWFsbHlTY3JvbGwiLCJyYXdNYXgiLCJzbWFsbGVzdENoYW5nZSIsImNhblNjcm9sbFdpbmRvdyIsImdldFdpbmRvd092ZXJsYXAiLCJjYW5TY3JvbGxEcm9wcGFibGUiLCJnZXREcm9wcGFibGVPdmVybGFwIiwiZ2V0V2luZG93U2Nyb2xsQ2hhbmdlIiwiZ2V0RHJvcHBhYmxlU2Nyb2xsQ2hhbmdlIiwiY3JlYXRlRmx1aWRTY3JvbGxlciIsInNjaGVkdWxlV2luZG93U2Nyb2xsIiwic2NoZWR1bGVEcm9wcGFibGVTY3JvbGwiLCJ0cnlTY3JvbGwiLCJzdGFydCQxIiwid2FzU2Nyb2xsTmVlZGVkIiwiZmFrZVNjcm9sbENhbGxiYWNrIiwiY3JlYXRlSnVtcFNjcm9sbGVyIiwibW92ZUJ5T2Zmc2V0Iiwic2Nyb2xsRHJvcHBhYmxlQXNNdWNoQXNJdENhbiIsIndoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwiLCJyZW1haW5kZXIiLCJzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuIiwid2hhdFRoZVdpbmRvd0NhblNjcm9sbCIsImp1bXBTY3JvbGxlciIsImRyb3BwYWJsZVJlbWFpbmRlciIsIndpbmRvd1JlbWFpbmRlciIsImNyZWF0ZUF1dG9TY3JvbGxlciIsImZsdWlkU2Nyb2xsZXIiLCJqdW1wU2Nyb2xsIiwic2Nyb2xsZXIiLCJwcmVmaXgiLCJkcmFnSGFuZGxlIiwiYmFzZSIsImNvbnRleHRJZCIsInNjcm9sbENvbnRhaW5lciIsIm1ha2VHZXRTZWxlY3RvciIsImNvbnRleHQiLCJhdHRyaWJ1dGUiLCJnZXRTdHlsZXMiLCJydWxlcyIsInByb3BlcnR5IiwicnVsZSIsInN0eWxlcyIsInNlbGVjdG9yIiwibm9Qb2ludGVyRXZlbnRzIiwiZ2V0U3R5bGVzJDEiLCJnZXRTZWxlY3RvciIsImRyYWdIYW5kbGUkMSIsImdyYWJDdXJzb3IiLCJhbHdheXMiLCJkcm9wQW5pbWF0aW5nIiwiZHJhZ2dhYmxlJDEiLCJ0cmFuc2l0aW9uIiwidXNlckNhbmNlbCIsImRyb3BwYWJsZSQxIiwiYm9keSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJjcmVhdGVFbGVtZW50IiwiZ2V0SGVhZCIsImhlYWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlU3R5bGVFbCIsIm5vbmNlIiwic2V0QXR0cmlidXRlIiwidXNlU3R5bGVNYXJzaGFsIiwiYWx3YXlzUmVmIiwiZHluYW1pY1JlZiIsInNldER5bmFtaWNTdHlsZSIsInRleHRDb250ZW50Iiwic2V0QWx3YXlzU3R5bGUiLCJkeW5hbWljIiwiYXBwZW5kQ2hpbGQiLCJyZWYiLCJyZW1vdmVDaGlsZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJwYXJlbnROb2RlIiwiQXJyYXkiLCJmcm9tIiwiZ2V0V2luZG93RnJvbUVsIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNIdG1sRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiZmluZERyYWdIYW5kbGUiLCJwb3NzaWJsZSIsImhhbmRsZSIsImdldEF0dHJpYnV0ZSIsInVzZUZvY3VzTWFyc2hhbCIsImVudHJpZXNSZWYiLCJyZWNvcmRSZWYiLCJyZXN0b3JlRm9jdXNGcmFtZVJlZiIsImlzTW91bnRlZFJlZiIsInJlZ2lzdGVyIiwidW5yZWdpc3RlciIsInRyeUdpdmVGb2N1cyIsInRyeUdpdmVGb2N1c1RvIiwiYWN0aXZlRWxlbWVudCIsInJlZGlyZWN0VG8iLCJyZWNvcmQiLCJmb2N1c2VkIiwiY2xlYXJGcmFtZU9uVW5tb3VudCIsImNyZWF0ZVJlZ2lzdHJ5Iiwic3Vic2NyaWJlcnMiLCJjYiIsIm5vdGlmeSIsImZpbmREcmFnZ2FibGVCeUlkIiwiZ2V0RHJhZ2dhYmxlQnlJZCIsImRyYWdnYWJsZUFQSSIsInVuaXF1ZUlkIiwiZmluZEJ5SWQiLCJmaW5kRHJvcHBhYmxlQnlJZCIsImdldERyb3BwYWJsZUJ5SWQiLCJkcm9wcGFibGVBUEkiLCJ1c2VSZWdpc3RyeSIsInVubW91bnQiLCJTdG9yZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiZ2V0Qm9keUVsZW1lbnQiLCJ2aXN1YWxseUhpZGRlbiIsImJvcmRlciIsInBhZGRpbmciLCJvdmVyZmxvdyIsImdldElkIiwidXNlQW5ub3VuY2VyIiwic2V0dXAiLCJjbGVhbnVwIiwiZGVmYXVsdHMiLCJzZXBhcmF0b3IiLCJ1c2VVbmlxdWVJZCIsInVzZUlkIiwiZ2V0RWxlbWVudElkIiwidXNlSGlkZGVuVGV4dEVsZW1lbnQiLCJ0ZXh0IiwibW91bnQiLCJkaXNwbGF5IiwiQXBwQ29udGV4dCIsInBlZXJEZXBlbmRlbmNpZXMiLCJyZWFjdCIsInNlbXZlciIsImdldFZlcnNpb24iLCJleGVjIiwibWFqb3IiLCJtaW5vciIsInJhdyIsImlzU2F0aXNmaWVkIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJjaGVja1JlYWN0VmVyc2lvbiIsInBlZXJEZXBWYWx1ZSIsImFjdHVhbFZhbHVlIiwicGVlckRlcCIsInN1ZmZpeCIsImNoZWNrRG9jdHlwZSIsImRvY3R5cGUiLCJ0b0xvd2VyQ2FzZSIsInB1YmxpY0lkIiwidXNlRGV2IiwidXNlSG9vayIsInVzZURldlNldHVwV2FybmluZyIsImUiLCJ1c2VTdGFydHVwVmFsaWRhdGlvbiIsInZlcnNpb24iLCJ1c2VQcmV2aW91cyIsImNyZWF0ZSIsImxvY2siLCJpc0NsYWltZWQiLCJjbGFpbSIsImFiYW5kb24iLCJuZXdMb2NrIiwicmVsZWFzZSIsInRyeUFiYW5kb24iLCJ0YWIiLCJlbnRlciIsImVzY2FwZSIsInNwYWNlIiwicGFnZVVwIiwicGFnZURvd24iLCJhcnJvd0xlZnQiLCJhcnJvd1VwIiwiYXJyb3dSaWdodCIsImFycm93RG93biIsInByZXZlbnRlZEtleXMiLCJwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMiLCJrZXlDb2RlIiwic3VwcG9ydGVkRXZlbnROYW1lIiwic3VwcG9ydGVkIiwicHJpbWFyeUJ1dHRvbiIsInNsb3BweUNsaWNrVGhyZXNob2xkIiwiaXNTbG9wcHlDbGlja1RocmVzaG9sZEV4Y2VlZGVkIiwiYWJzIiwiaWRsZSQxIiwiZ2V0Q2FwdHVyZUJpbmRpbmdzIiwiZ2V0UGhhc2UiLCJzZXRQaGFzZSIsImJ1dHRvbiIsImNsaWVudFgiLCJjbGllbnRZIiwiYWN0aW9ucyIsInBlbmRpbmciLCJmbHVpZExpZnQiLCJzaG91bGRCbG9ja05leHRDbGljayIsInNob3VsZFJlc3BlY3RGb3JjZVByZXNzIiwidXNlTW91c2VTZW5zb3IiLCJhcGkiLCJwaGFzZVJlZiIsInVuYmluZEV2ZW50c1JlZiIsInN0YXJ0Q2FwdHVyZUJpbmRpbmciLCJvbk1vdXNlRG93biIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwiZmluZENsb3Nlc3REcmFnZ2FibGVJZCIsInRyeUdldExvY2siLCJzb3VyY2VFdmVudCIsInN0YXJ0UGVuZGluZ0RyYWciLCJwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmciLCJmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSIsImNhbkdldExvY2siLCJsaXN0ZW5Gb3JDYXB0dXJlIiwiYmluZENhcHR1cmluZ0V2ZW50cyIsIm5vb3AkMSIsInNjcm9sbEp1bXBLZXlzIiwiZ2V0RHJhZ2dpbmdCaW5kaW5ncyIsInVzZUtleWJvYXJkU2Vuc29yIiwib25LZXlEb3duIiwicHJlRHJhZyIsImlzQ2FwdHVyaW5nIiwic25hcExpZnQiLCJ0cnlTdGFydENhcHR1cmUiLCJpZGxlIiwidGltZUZvckxvbmdQcmVzcyIsImZvcmNlUHJlc3NUaHJlc2hvbGQiLCJnZXRXaW5kb3dCaW5kaW5ncyIsImdldEhhbmRsZUJpbmRpbmdzIiwiaGFzTW92ZWQiLCJ0b3VjaGVzIiwidG91Y2giLCJpc0ZvcmNlUHJlc3MiLCJmb3JjZSIsInNob3VsZFJlc3BlY3QiLCJ1c2VUb3VjaFNlbnNvciIsIm9uVG91Y2hTdGFydCIsImxvbmdQcmVzc1RpbWVySWQiLCJ1bmJpbmRUYXJnZXQiLCJ1bmJpbmRXaW5kb3ciLCJzdGFydERyYWdnaW5nIiwid2Via2l0SGFjayIsInVzZVZhbGlkYXRlU2Vuc29ySG9va3MiLCJzZW5zb3JIb29rcyIsInByZXZpb3VzUmVmIiwiaW50ZXJhY3RpdmVUYWdOYW1lcyIsImlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQiLCJwYXJlbnQiLCJoYXNBbkludGVyYWN0aXZlVGFnIiwiaW5jbHVkZXMiLCJ0YWdOYW1lIiwicGFyZW50RWxlbWVudCIsImlzRXZlbnRJbkludGVyYWN0aXZlRWxlbWVudCIsImdldEJvcmRlckJveENlbnRlclBvc2l0aW9uIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaXNFbGVtZW50IiwiRWxlbWVudCIsInN1cHBvcnRlZE1hdGNoZXNOYW1lIiwiY2xvc2VzdFBvbnlmaWxsIiwiZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50IiwidHJ5R2V0Q2xvc2VzdERyYWdnYWJsZUlkRnJvbUV2ZW50IiwiZmluZERyYWdnYWJsZSIsImlzTG9ja0FjdGl2ZSIsInNob3VsZFdhcm4iLCJjYW5TdGFydCIsImxvY2tBUEkiLCJ0cnlTdGFydCIsImZvcmNlU2Vuc29yU3RvcCIsInNob3VsZFN0YXJ0IiwiY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMiLCJnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyIsInRyeURpc3BhdGNoIiwiZ2V0QWN0aW9uIiwidHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmciLCJsaWZ0QWN0aW9uQXJncyIsIm1vdmUkMSIsImFib3J0UHJlRHJhZyIsInNob3VsZFJlbGVhc2UiLCJkZWZhdWx0U2Vuc29ycyIsInVzZVNlbnNvck1hcnNoYWwiLCJjdXN0b21TZW5zb3JzIiwiZW5hYmxlRGVmYXVsdFNlbnNvcnMiLCJ1c2VTZW5zb3JzIiwidHJ5QWJhbmRvbkxvY2siLCJsaXN0ZW5Ub1N0b3JlIiwiZm9yY2VTdG9wIiwidHJ5UmVsZWFzZUxvY2siLCJpc0xvY2tDbGFpbWVkIiwiY3JlYXRlUmVzcG9uZGVycyIsInQiLCJvbkJlZm9yZUNhcHVyZUNhbGxiYWNrIiwiY3JlYXRlQXV0b1Njcm9sbGVyT3B0aW9ucyIsImdldFN0b3JlIiwibGF6eVJlZiIsIkFwcCIsInNlbnNvcnMiLCJsYXp5U3RvcmVSZWYiLCJsYXN0UHJvcHNSZWYiLCJkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCIsImxhenlEaXNwYXRjaCIsIm1hcnNoYWxDYWxsYmFja3MiLCJ0cnlSZXNldFN0b3JlIiwiYXBwQ2FsbGJhY2tzIiwiZ2V0Q2FuTGlmdCIsImdldElzTW92ZW1lbnRBbGxvd2VkIiwiYXBwQ29udGV4dCIsImNhbkxpZnQiLCJ1c2VVbmlxdWVDb250ZXh0SWQiLCJEcmFnRHJvcENvbnRleHQiLCJ6SW5kZXhPcHRpb25zIiwiZ2V0RHJhZ2dpbmdUcmFuc2l0aW9uIiwic2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCIsImdldERyYWdnaW5nT3BhY2l0eSIsImlzRHJvcEFuaW1hdGluZyIsImdldFNob3VsZERyYWdnaW5nQW5pbWF0ZSIsImdldERyYWdnaW5nU3R5bGUiLCJ0cmFuc2Zvcm0iLCJib3hTaXppbmciLCJ6SW5kZXgiLCJwb2ludGVyRXZlbnRzIiwiZ2V0U2Vjb25kYXJ5U3R5bGUiLCJzZWNvbmRhcnkiLCJzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50IiwiZ2V0U3R5bGUkMSIsIm1hcHBlZCIsImdldERpbWVuc2lvbiQxIiwiY29tcHV0ZWRTdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwidXNlRHJhZ2dhYmxlUHVibGlzaGVyIiwiZ2V0RHJhZ2dhYmxlUmVmIiwicHVibGlzaGVkUmVmIiwiaXNGaXJzdFB1Ymxpc2hSZWYiLCJEcm9wcGFibGVDb250ZXh0IiwiY2hlY2tJc1ZhbGlkSW5uZXJSZWYiLCJ1c2VWYWxpZGF0aW9uJDEiLCJnZXRSZWYiLCJpc0ludGVnZXIiLCJ1c2VDbG9uZVByb3BWYWxpZGF0aW9uIiwiaXNDbG9uZSIsImluaXRpYWxSZWYiLCJ1c2VSZXF1aXJlZENvbnRleHQiLCJDb250ZXh0IiwicHJldmVudEh0bWw1RG5kIiwiRHJhZ2dhYmxlIiwic2V0UmVmIiwiZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uIiwiZm9yUHVibGlzaGVyIiwiZHJhZ0hhbmRsZVByb3BzIiwidGFiSW5kZXgiLCJyb2xlIiwib25Nb3ZlRW5kIiwicHJvcGVydHlOYW1lIiwib25UcmFuc2l0aW9uRW5kIiwiaW5uZXJSZWYiLCJkcmFnZ2FibGVQcm9wcyIsInJ1YnJpYyIsIkZyYWdtZW50Iiwic25hcHNob3QiLCJpc1N0cmljdEVxdWFsIiwid2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0IiwiZ2V0Q29tYmluZVdpdGhGcm9tUmVzdWx0IiwiZ2V0Q29tYmluZVdpdGhGcm9tSW1wYWN0IiwiZ2V0RHJhZ2dhYmxlU2VsZWN0b3IiLCJtZW1vaXplZE9mZnNldCIsImdldE1lbW9pemVkU25hcHNob3QiLCJkcmFnZ2luZ092ZXIiLCJkcm9wQW5pbWF0aW9uIiwiY29tYmluZVRhcmdldEZvciIsImdldE1lbW9pemVkUHJvcHMiLCJvd25Qcm9wcyIsImN1cnZlIiwiZ2V0U2Vjb25kYXJ5U25hcHNob3QiLCJhdFJlc3QiLCJnZXRTZWNvbmRhcnlTZWxlY3RvciIsImdldEZhbGxiYWNrIiwiZ2V0UHJvcHMiLCJvd25JZCIsImRyYWdnaW5nSWQiLCJ2aXN1YWxEaXNwbGFjZW1lbnQiLCJpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0IiwibWFrZU1hcFN0YXRlVG9Qcm9wcyQxIiwiZHJhZ2dpbmdTZWxlY3RvciIsInNlY29uZGFyeVNlbGVjdG9yIiwibWFwRGlzcGF0Y2hUb1Byb3BzJDEiLCJDb25uZWN0ZWREcmFnZ2FibGUiLCJhcmVTdGF0ZVByb3BzRXF1YWwiLCJQcml2YXRlRHJhZ2dhYmxlIiwiZHJvcHBhYmxlQ29udGV4dCIsImlzVXNpbmdDbG9uZUZvciIsIlB1YmxpY0RyYWdnYWJsZSIsImlzRHJhZ0Rpc2FibGVkIiwiZGlzYWJsZUludGVyYWN0aXZlRWxlbWVudEJsb2NraW5nIiwiaXNTY3JvbGwiLCJpc0F1dG8iLCJpc0VpdGhlciIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImlzQm90aCIsImlzRWxlbWVudFNjcm9sbGFibGUiLCJpc0JvZHlTY3JvbGxhYmxlIiwiaHRtbCIsImh0bWxTdHlsZSIsImh0bWxPdmVyZmxvdyIsImdldENsb3Nlc3RTY3JvbGxhYmxlIiwiY2hlY2tGb3JOZXN0ZWRTY3JvbGxDb250YWluZXJzIiwiYW5vdGhlclNjcm9sbFBhcmVudCIsImdldFNjcm9sbCIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJnZXRJc0ZpeGVkIiwiZ2V0RW52IiwiY2xvc2VzdFNjcm9sbGFibGUiLCJnZXREcm9wcGFibGVEaW1lbnNpb24iLCJzY3JvbGxTaXplIiwiZnJhbWVDbGllbnQiLCJwYWRkaW5nQm94IiwiZ2V0Q2xpZW50IiwidGFyZ2V0UmVmIiwiZW52IiwiaXNEcm9wRGlzYWJsZWQiLCJpbW1lZGlhdGUiLCJkZWxheWVkIiwiZ2V0TGlzdGVuZXJPcHRpb25zIiwiZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyIsInVzZURyb3BwYWJsZVB1Ymxpc2hlciIsIndoaWxlRHJhZ2dpbmdSZWYiLCJwdWJsaXNoZWREZXNjcmlwdG9yUmVmIiwibWVtb2l6ZWRVcGRhdGVTY3JvbGwiLCJnZXRDbG9zZXN0U2Nyb2xsIiwic2NoZWR1bGVTY3JvbGxVcGRhdGUiLCJvbkNsb3Nlc3RTY3JvbGwiLCJnZXREcm9wcGFibGVSZWYiLCJpZ25vcmVDb250YWluZXJDbGlwcGluZyIsInJlbW92ZUF0dHJpYnV0ZSIsIm5vb3AiLCJlbXB0eSIsImdldFNpemUiLCJpc0FuaW1hdGluZ09wZW5Pbk1vdW50IiwiYW5pbWF0ZSIsImdldFN0eWxlIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5MZWZ0IiwiZmxleFNocmluayIsImZsZXhHcm93IiwiUGxhY2Vob2xkZXIiLCJhbmltYXRlT3BlblRpbWVyUmVmIiwidHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyIiwib25DbG9zZSIsInNldElzQW5pbWF0aW5nT3Blbk9uTW91bnQiLCJvblNpemVDaGFuZ2VFbmQiLCJQbGFjZWhvbGRlciQxIiwibWVtbyIsImlzQm9vbGVhbiIsInJ1bkNoZWNrcyIsImNoZWNrcyIsImNoZWNrIiwiYm9vbGVhbiIsInN0YW5kYXJkIiwiZ2V0UGxhY2Vob2xkZXJSZWYiLCJ2aXJ0dWFsIiwiaGFzQ2xvbmUiLCJyZW5kZXJDbG9uZSIsImhhc05vUGxhY2Vob2xkZXIiLCJ1c2VWYWxpZGF0aW9uIiwiQW5pbWF0ZUluT3V0IiwiUHVyZUNvbXBvbmVudCIsIm9uIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiRHJvcHBhYmxlIiwiZHJvcHBhYmxlUmVmIiwicGxhY2Vob2xkZXJSZWYiLCJ1c2VDbG9uZSIsImdldENvbnRhaW5lckZvckNsb25lIiwic2V0RHJvcHBhYmxlUmVmIiwic2V0UGxhY2Vob2xkZXJSZWYiLCJvblBsYWNlaG9sZGVyVHJhbnNpdGlvbkVuZCIsInNob3VsZEFuaW1hdGVQbGFjZWhvbGRlciIsImRyb3BwYWJsZVByb3BzIiwiZ2V0Q2xvbmUiLCJub2RlIiwiZHJhZ2dhYmxlUHJvdmlkZWQiLCJkcmFnZ2FibGVTbmFwc2hvdCIsImNyZWF0ZVBvcnRhbCIsImdldEJvZHkiLCJkZWZhdWx0UHJvcHMiLCJhdHRhY2hEZWZhdWx0UHJvcHNUb093blByb3BzIiwibWVyZ2VkUHJvcHMiLCJkZWZhdWx0UHJvcEtleSIsImlzTWF0Y2hpbmdUeXBlIiwiZ2V0RHJhZ2dhYmxlIiwibWFrZU1hcFN0YXRlVG9Qcm9wcyIsImlkbGVXaXRoQW5pbWF0aW9uIiwiaXNEcmFnZ2luZ092ZXIiLCJkcmFnZ2luZ092ZXJXaXRoIiwiZHJhZ2dpbmdGcm9tVGhpc1dpdGgiLCJpc1VzaW5nUGxhY2Vob2xkZXIiLCJpZGxlV2l0aG91dEFuaW1hdGlvbiIsImdldERyYWdnYWJsZVJ1YnJpYyIsImdldE1hcFByb3BzIiwiaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciIsImlzRHJhZ2dpbmdPdmVyRm9ySW1wYWN0IiwiaXNIb21lIiwib3duUHJvcHNXaXRoRGVmYXVsdFByb3BzIiwid2FzQ29tYmluaW5nIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwiQ29ubmVjdGVkRHJvcHBhYmxlIiwic3RhdGVQcm9wcyIsImRpc3BhdGNoUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js\n");

/***/ })

};
;